


from astra import Astra
from . import tools
from .astra import recommended_spacecharge_mesh
from .evaluate import default_astra_merit

from distgen import Generator   
from distgen.writers import write_astra
from distgen.tools import update_nested_dict

from lume import tools as lumetools

from pmd_beamphysics import ParticleGroup

from h5py import File

import json
import os

def set_astra_and_distgen(astra_input, distgen_input, settings, verbose=False):
    """
    Searches astra and distgen input for keys in settings, and sets their values to the appropriate input.
    """
    for k, v in settings.items():
        found=False
        for nl in astra_input:
            if k in astra_input[nl]:
                found = True
                if verbose:
                    print(k, 'is in astra', nl)
                astra_input[nl][k] = settings[k]
        
        if not found:
            distgen_input = update_nested_dict(distgen_input, {k:v}, verbose=verbose)
            #set_nested_dict(distgen_input, k, v)    
    
    return astra_input, distgen_input
    
def run_astra_with_distgen(settings=None,
                           astra_input_file=None,
                           distgen_input_file=None,
                           workdir=None, 
                           astra_bin='$ASTRA_BIN',
                           timeout=2500,
                           verbose=False,
                           auto_set_spacecharge_mesh=True):
    """
    Run Astra with particles generated by distgen. 
    
        settings: dict with keys that can appear in an Astra, 
         or distgen keys with prefix 'distgen:'
        
    Example usage:
        A = run_astra_with_distgen({'lspch':False, 'distgen:n_particle':1000},
                       astra_input_file='astra.yaml',
                       distgen_input_file='distgen.yaml',
                       verbose=True,
                       timeout=None
                      )        
        
    """

    # Call simpler evaluation if there is no generator:
    if not distgen_input_file:
        return run_astra(settings=settings, 
                         astra_input_file=astra_input_file, 
                         workdir=workdir,
                         command=astra_bin, 
                         timeout=timeout, 
                         verbose=verbose)
        
    
    if verbose:
        print('run_astra_with_generator') 

    # Distgen generator
    G = Generator(distgen_input_file, verbose=verbose)  
        
    # Make astra objects
    if astra_input_file.endswith('.yaml'):
        if verbose:
            f'loading Astra as yaml: {astra_input_file}'
        A = Astra.from_yaml(astra_input_file)
        if workdir:
            A.workdir = workdir
            A.configure() # again to make sure things are set properly  
        
    else:
        A = Astra(command=astra_bin, input_file=astra_input_file, workdir=workdir)
    
    
    
    A.timeout=timeout
    A.verbose = verbose
    
    # Special
    A.input['newrun']['l_rm_back'] = True # Remove backwards particles

    # 
    if settings:
        for key, val in settings.items():
            
            found = False
            # Check distgen
            if key.startswith('distgen:'):
                key = key[len('distgen:'):]
                if verbose:
                    print(f'Setting distgen {key} = {val}')
                G[key] = val
                continue
                
            # Check for direct settable attribute
            if ':' in key:
                A[key] = val
                continue
            
            for nl in A.input:
                if key in A.input[nl]:
                    found = True
                    if verbose:
                        print(key, 'is in astra', nl)
                    A.input[nl][key] = val    
                    
            if not found:   
                raise ValueError(f'Key not found: {key}')

    # Attach distgen input. This is non-standard. 
    A.distgen_input = G.input
        
    # Run distgen
    G.run()
    P = G.particles
    # Special flag for cathode start
    if G['start:type'] == 'cathode':
        P.status[:] = -1
    
    # Attach to Astra object
    A.initial_particles = P
    
    if auto_set_spacecharge_mesh:
        n_particles = len(P)
        sc_settings = recommended_spacecharge_mesh(n_particles)
        A.input['charge'].update(sc_settings)
        if verbose:
            print('set spacecharge mesh for n_particles:', n_particles, 'to', sc_settings)        
            
    A.run()
    
    return A

    # Same as run_astra_with_distgen
         # Additional options                          
def evaluate_astra_with_distgen(settings,
                                astra_input_file=None,
                                distgen_input_file=None,
                                workdir=None, 
                                astra_bin='$ASTRA_BIN',
                                timeout=2500,
                                verbose=False,
                                auto_set_spacecharge_mesh=True,
                                archive_path=None, 
                                merit_f=None):
    """
    Similar to run_astra_with_distgen, but returns a flat dict of outputs as processed by merit_f. 
    
    If no merit_f is given, a default one will be used. See:
        astra.evaluate.default_astra_merit
    
    Will raise an exception if there is an error. 
    
    """
    A = run_astra_with_distgen(settings=settings, 
                         astra_input_file=astra_input_file, 
                         distgen_input_file=distgen_input_file, 
                         workdir=workdir,
                         astra_bin=astra_bin, 
                         timeout=timeout, 
                         auto_set_spacecharge_mesh=auto_set_spacecharge_mesh,
                         verbose=verbose)
        
    if merit_f:
        output = merit_f(A)
    else:
        output = default_astra_merit(A)
    
    if output['error']:
        raise ValueError('run_astra_with_distgen returned error in output')

    #Recreate Generator object for fingerprint, proper archiving
    # TODO: make this cleaner
    G = Generator(A.distgen_input)
    
    fingerprint = fingerprint_astra_with_distgen(A, G)
    output['fingerprint'] = fingerprint
    
    if archive_path:
        path = lumetools.full_path(archive_path)
        assert os.path.exists(path), f'archive path does not exist: {path}'
        archive_file = os.path.join(path, fingerprint+'.h5')
        output['archive'] = archive_file
        
        # Call the composite archive method
        archive_astra_with_distgen(A, G, archive_file=archive_file)   
        
    return output



def fingerprint_astra_with_distgen(astra_object, distgen_object):
    """
    Calls fingerprint() of each of these objects
    """
    f1 = astra_object.fingerprint()
    f2 = distgen_object.fingerprint()
    d = {'f1':f1, 'f2':f2}
    return lumetools.fingerprint(d)



def archive_astra_with_distgen(astra_object,
                               distgen_object,
                               archive_file=None,
                               astra_group ='astra',
                               distgen_group ='distgen'):
    """
    Creates a new archive_file (hdf5) with groups for 
    astra and distgen. 
    
    Calls .archive method of Astra and Distgen objects, into these groups.
    """
    
    h5 = File(archive_file, 'w')
    
    #fingerprint = tools.fingerprint(astra_object.input.update(distgen.input))
    
    g = h5.create_group(distgen_group)
    distgen_object.archive(g)
    
    g = h5.create_group(astra_group)
    astra_object.archive(g)
    
    h5.close()
    

