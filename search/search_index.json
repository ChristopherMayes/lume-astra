{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LUME-Astra","text":"<p>Python wrapper for ASTRA (A Space Charge Tracking Algorithm, DESY) for use in LUME.</p> <p><pre><code>from astra import Astra\n\nA = Astra('Astra.in')\nA.run()\nA.plot(y=['norm_emit_x', 'norm_emit_y'], y2=['sigma_x', 'sigma_y'])\n</code></pre> </p>"},{"location":"#installing-lume-astra","title":"Installing lume-astra","text":"<p>Installing <code>lume-astra</code> from the <code>conda-forge</code> channel can be achieved by adding <code>conda-forge</code> to your channels with:</p> <pre><code>conda config --add channels conda-forge\n</code></pre> <p>Once the <code>conda-forge</code> channel has been enabled, <code>lume-astra</code> can be installed with:</p> <pre><code>conda install lume-astra\n</code></pre> <p>It is possible to list all of the versions of <code>lume-astra</code> available on your platform with:</p> <pre><code>conda search lume-astra --channel conda-forge\n</code></pre>"},{"location":"#installing-astra-executables","title":"Installing Astra Executables","text":"<p>For convenience, you can set <code>$ASTRA_BIN</code> and <code>$GENERATOR_BIN</code> to point to the Astra and generator binaries for your system. See the install_astra.ipynb example for easy installation.</p>"},{"location":"api/astra/","title":"Astra","text":""},{"location":"api/astra/#astra.astra","title":"<code>astra.astra</code>","text":""},{"location":"api/astra/#astra.astra.Astra","title":"<code>Astra</code>","text":"<p>             Bases: <code>CommandWrapper</code></p> <p>Astra simulation object. Essential methods: .init(...) .configure() .run()</p> <p>Input deck is held in .input Output data is parsed into .output .load_particles() will load particle data into .output'particles'</p> <p>The Astra binary file can be set on init. If it doesn't exist, configure will check the     $ASTRA_BIN environmental variable.</p> Source code in <code>astra/astra.py</code> <pre><code>class Astra(CommandWrapper):\n\n\"\"\" \n    Astra simulation object. Essential methods:\n    .__init__(...)\n    .configure()\n    .run()\n\n    Input deck is held in .input\n    Output data is parsed into .output\n    .load_particles() will load particle data into .output['particles'][...]\n\n    The Astra binary file can be set on init. If it doesn't exist, configure will check the\n        $ASTRA_BIN\n    environmental variable.\n\n\n    \"\"\"\n    MPI_SUPPORTED = False\n    COMMAND = \"$ASTRA_BIN\"\n    INPUT_PARSER = parsers.parse_astra_input_file\n\n    def __init__(self, \n                 input_file=None,\n                 *,                 \n                 group=None,\n                 **kwargs\n                 ):\n        super().__init__(input_file=input_file, **kwargs)\n        # Save init\n        self.original_input_file = self._input_file\n\n        # These will be set\n        self.log = []\n        self.output = {'stats': {}, 'particles': {}, 'run_info': {}}\n        self.group = {}  # Control Groups\n        self.fieldmap = {}  # Fieldmaps\n\n        # Call configure\n        if self.input_file:\n            self.load_input(self.input_file)\n            self.configure()\n\n            # Add groups, if any.\n            if group:\n                for k, v in group.items():\n                    self.add_group(k, **v)\n        else:            \n            self.vprint('Using default input: 1 m drift lattice')\n            self.original_input_file = 'astra.in'\n            self.input = deepcopy(DEFAULT_INPUT)\n            self.configure()\n\n    def add_group(self, name, **kwargs):\n\"\"\"\n        Add a control group. See control.py\n\n        Parameters\n        ----------\n        name : str\n            The group name\n        \"\"\"\n        assert name not in self.input, f'{name} not allowed to be overwritten by group.'\n        if name in self.group:\n            self.vprint(f'Warning: group {name} already exists, overwriting.')\n\n        g = ControlGroup(**kwargs)\n        g.link(self.input)\n        self.group[name] = g\n\n        return self.group[name]\n\n    def clean_output(self):\n        run_number = parsers.astra_run_extension(self.input['newrun']['run'])\n        outfiles = parsers.find_astra_output_files(self.input_file, run_number)\n        for f in outfiles:\n            os.remove(f)\n\n    def clean_particles(self):\n        run_number = parsers.astra_run_extension(self.input['newrun']['run'])\n        phase_files = parsers.find_phase_files(self.input_file, run_number)\n        files = [x[0] for x in phase_files]  # This is sorted by approximate z\n        for f in files:\n            os.remove(f)\n\n    # Convenience routines\n    @property\n    def particles(self):\n        return self.output['particles']\n\n    def stat(self, key):\n        return self.output['stats'][key]\n\n    def particle_stat(self, key, alive_only=True):\n\"\"\"\n        Compute a statistic from the particles.\n\n        Alive particles have status == 1. By default, statistics will only be computed on these.\n\n        n_dead will override the alive_only flag,\n        and return the number of particles with status &lt; -6 (Astra convention)\n        \"\"\"\n\n        if key == 'n_dead':\n            return np.array([len(np.where(P.status &lt; -6)[0]) for P in self.particles])\n\n        if key == 'n_alive':\n            return np.array([len(np.where(P.status &gt; -6)[0]) for P in self.particles])\n\n        pstats = []\n        for P in self.particles:\n            if alive_only and P.n_dead &gt; 0:\n                P = P.where(P.status == 1)\n            pstats.append(P[key])\n        return np.array(pstats)\n\n\n    def configure(self):\n        self.setup_workdir(self._workdir)\n        self.command = lumetools.full_path(self.command)\n        self.vprint(\"Configured to run in:\", self.path)\n        self.input_file = os.path.join(self.path, self.original_input_file)\n        self.configured = True    \n\n\n #   def configure(self):\n #       self.configure_astra(workdir=self.path)\n#\n #   def configure_astra(self, input_filepath=None, workdir=None):\n#\n #  #     if input_filepath:\n #  #         self.load_input(input_filepath)\n#\n #       # Check that binary exists\n #       #self.command = lumetools.full_path(self.command)\n#\n #       self.setup_workdir(self._workdir)\n #       #self.input_file = os.path.join(self.path, self.original_input_file)\n #       self.configured = True\n\n    def load_fieldmaps(self, search_paths=[]):\n\"\"\"\n        Loads fieldmaps into Astra.fieldmap as a dict.\n\n        Optionally, a list of paths can be included that will search for these. The default will search self.path.\n        \"\"\"\n\n        # Do not consider files if fieldmaps have been loaded.\n        if self.fieldmap:\n            strip_path = False\n        else:\n            strip_path = True\n\n        if not search_paths:\n            search_paths = [self.path]\n\n        self.fieldmap = load_fieldmaps(self.input, fieldmap_dict=self.fieldmap, search_paths=search_paths,\n                                       verbose=self.verbose, strip_path=strip_path)\n\n    def load_initial_particles(self, h5):\n\"\"\"Loads a openPMD-beamphysics particle h5 handle or file\"\"\"\n        P = ParticleGroup(h5=h5)\n        self.initial_particles = P\n\n    def input_parser(self, path):\n        return parsers.parse_astra_input_file(path)\n\n    def load_input(self, input_filepath, absolute_paths=True, **kwargs):\n        super().load_input(input_filepath, **kwargs)\n        if absolute_paths:\n            parsers.fix_input_paths(self.input, root=self.original_path)\n\n    def load_output(self, include_particles=True):\n\"\"\"\n        Loads Astra output files into .output\n\n        .output is a dict with dicts:\n            .stats\n            .run_info\n            .other\n\n        and if include_particles,\n            .particles = list of ParticleGroup objects\n\n        \"\"\"\n        run_number = parsers.astra_run_extension(self.input['newrun']['run'])\n        outfiles = parsers.find_astra_output_files(self.input_file, run_number)\n\n        # assert len(outfiles)&gt;0, 'No output files found'\n\n        stats = self.output['stats'] = {}\n\n        for f in outfiles:\n            type = parsers.astra_output_type(f)\n            d = parsers.parse_astra_output_file(f)\n            if type in ['Cemit', 'Xemit', 'Yemit', 'Zemit']:\n                stats.update(d)\n            elif type in ['LandF']:\n                self.output['other'] = d\n            else:\n                raise ValueError(f'Unknown output type: {type}')\n\n        # Check that the lengths of all arrays are the same\n        nlist = {len(stats[k]) for k in stats}\n\n        assert len(nlist) == 1, f'Stat keys do not all have the same length: {[len(stats[k]) for k in stats]}'\n\n        if include_particles:\n            self.load_particles()\n\n    def load_particles(self, end_only=False):\n        # Clear existing particles\n        self.output['particles'] = []\n\n        # Sort files by approximate z\n        run_number = parsers.astra_run_extension(self.input['newrun']['run'])\n        phase_files = parsers.find_phase_files(self.input_file, run_number)\n        files = [x[0] for x in phase_files]  # This is sorted by approximate z\n        zapprox = [x[1] for x in phase_files]\n\n        if end_only:\n            files = files[-1:]\n        if self.verbose:\n            print('loading ' + str(len(files)) + ' particle files')\n            print(zapprox)\n        for f in files:\n            pdat = parse_astra_phase_file(f)\n            P = ParticleGroup(data=pdat)\n            self.output['particles'].append(P)\n\n    def run(self):\n        self.run_astra()\n\n    def run_astra(self, verbose=False, parse_output=True, timeout=None):\n\"\"\"\n        Runs Astra\n\n        Changes directory, so does not work with threads.\n        \"\"\"\n        if not self.configured:\n            print('not configured to run')\n            return\n\n        run_info = self.output['run_info'] = {}\n\n        t1 = time()\n        run_info['start_time'] = t1\n\n        # Write all input\n        self.write_input()\n\n        runscript = self.get_run_script()\n        tools.make_executable(os.path.join(self.path, 'run'))\n        run_info['run_script'] = ' '.join(runscript)\n\n        if self.timeout:\n            res = tools.execute2(runscript, timeout=timeout, cwd=self.path)\n            log = res['log']\n            self.error = res['error']\n            run_info['why_error'] = res['why_error']\n            # Log file must have this to have finished properly\n            if log.find('finished simulation') == -1:\n                raise ValueError(\"Couldn't find finished simulation\")\n\n        else:\n            # Interactive output, for Jupyter\n            log = []\n            for path in tools.execute(runscript, cwd=self.path):\n                self.vprint(path, end=\"\")\n                log.append(path)\n\n        self.log = log\n\n        if parse_output:\n            self.load_output()\n\n        run_info['run_time'] = time() - t1\n\n        self.finished = True\n\n        self.vprint(run_info)\n\n    def units(self, key):\n        if key in parsers.OutputUnits:\n            return parsers.OutputUnits[key]\n        else:\n            return 'unknown unit'\n\n    def load_archive(self, h5=None, configure=False):\n\"\"\"\n        Loads input and output from archived h5 file.\n\n        See: Astra.archive\n        \"\"\"\n        if isinstance(h5, str):\n            h5 = os.path.expandvars(h5)\n            g = h5py.File(h5, 'r')\n\n            glist = archive.find_astra_archives(g)\n            n = len(glist)\n            if n == 0:\n                # legacy: try top level\n                message = 'legacy'\n            elif n == 1:\n                gname = glist[0]\n                message = f'group {gname} from'\n                g = g[gname]\n            else:\n                raise ValueError(f'Multiple archives found in file {h5}: {glist}')\n\n            self.vprint(f'Reading {message} archive file {h5}')\n        else:\n            g = h5\n\n        self.input = archive.read_input_h5(g['input'])\n        self.output = archive.read_output_h5(g['output'])\n        if 'initial_particles' in g:\n            self.initial_particles = ParticleGroup(h5=g['initial_particles'])\n\n        if 'fieldmap' in g:\n            self.fieldmap = archive.read_fieldmap_h5(g['fieldmap'])\n\n        if 'control_groups' in g:\n            self.group = archive.read_control_groups_h5(g['control_groups'], verbose=self.verbose)\n\n        self.vprint('Loaded from archive. Note: Must reconfigure to run again.')\n        self.configured = False\n\n        # Re-link groups\n        # TODO: cleaner logic\n        for _, cg in self.group.items():\n            cg.link(self.input)\n\n        if configure:\n            self.configure()\n\n    def archive(self, h5=None):\n\"\"\"\n        Archive all data to an h5 handle or filename.\n\n        If no file is given, a file based on the fingerprint will be created.\n\n        \"\"\"\n        if not h5:\n            h5 = 'astra_' + self.fingerprint() + '.h5'\n\n        if isinstance(h5, str):\n            h5 = os.path.expandvars(h5)\n            g = h5py.File(h5, 'w')\n            self.vprint(f'Archiving to file {h5}')\n        else:\n            # store directly in the given h5 handle\n            g = h5\n\n        # Write basic attributes\n        archive.astra_init(g)\n\n        # Initial particles\n        if self.initial_particles:\n            self.initial_particles.write(g, name='initial_particles')\n\n        # Fieldmaps\n        if self.fieldmap:\n            archive.write_fieldmap_h5(g, self.fieldmap, name='fieldmap')\n\n        # All input\n        archive.write_input_h5(g, self.input)\n\n        # All output\n        archive.write_output_h5(g, self.output)\n\n        # Control groups\n        if self.group:\n            archive.write_control_groups_h5(g, self.group, name='control_groups')\n\n        return h5\n\n    def write_fieldmaps(self, path=None):\n\"\"\"\n        Writes any loaded fieldmaps to path\n        \"\"\"\n        if path is None:\n            path = self.path         \n\n        if self.fieldmap:\n            write_fieldmaps(self.fieldmap, path)\n            self.vprint(f'{len(self.fieldmap)} fieldmaps written to {path}')\n\n    def write_input(self, input_filename=None, path=None, make_symlinks=True):\n\"\"\"\n        Writes all input. If fieldmaps have been loaded, these will also be written.\n        \"\"\"\n\n        if path is None:\n            path = self.path        \n\n        if self.initial_particles:\n            fname = self.write_initial_particles(path=path)\n            self.input['newrun']['distribution'] = fname\n\n        self.write_fieldmaps(path=path)\n\n        self.write_input_file(path=path, make_symlinks=make_symlinks)\n\n    def write_input_file(self, path=None, make_symlinks=True):\n        if path is None:\n            path = self.path\n            input_file = self.input_file\n        else:\n            input_file = os.path.join(path, 'astra.in')\n\n        writers.write_namelists(self.input, input_file, make_symlinks=make_symlinks, verbose=self.verbose)\n\n    def write_initial_particles(self, fname=None, path=None):\n        if path is None:\n            path = self.path  \n\n        fname = fname or os.path.join(path, 'astra.particles')\n        # \n        if len(self.initial_particles) == 1:\n            probe = True\n        else:\n            probe = False\n        self.initial_particles.write_astra(fname, probe=probe)\n        self.vprint(f'Initial particles written to {fname}')\n        return fname\n\n    def plot(self, y=['sigma_x', 'sigma_y'], x='mean_z', xlim=None, ylim=None, ylim2=None, y2=[],\n             nice=True,\n             include_layout=True,\n             include_labels=False,\n             include_particles=True,\n             include_legend=True,\n             return_figure=False,\n             **kwargs):\n\"\"\"\n        Plots stat output multiple keys.\n\n        If a list of ykeys2 is given, these will be put on the right hand axis. This can also be given as a single key.\n\n        Logical switches:\n            nice: a nice SI prefix and scaling will be used to make the numbers reasonably sized. Default: True\n\n            include_legend: The plot will include the legend.  Default: True\n\n            include_particles: Plot the particle statistics as dots. Default: True\n\n            include_layout: the layout plot will be displayed at the bottom.  Default: True\n\n            include_labels: the layout will include element labels.  Default: False\n\n            return_figure: return the figure object for further manipulation. Default: False\n\n        If there is no output to plot, the fieldmaps will be plotted with .plot_fieldmaps\n\n        \"\"\"\n\n        # Just plot fieldmaps if there are no stats\n        if not self.output['stats']:\n            return plot_fieldmaps(self, xlim=xlim, **kwargs)\n\n        return plot_stats_with_layout(self, ykeys=y, ykeys2=y2,\n                                      xkey=x, xlim=xlim, ylim=ylim, ylim2=ylim2,\n                                      nice=nice,\n                                      include_layout=include_layout,\n                                      include_labels=include_labels,\n                                      include_particles=include_particles,\n                                      include_legend=include_legend,\n                                      return_figure=return_figure,\n                                      **kwargs)\n\n    def plot_fieldmaps(self, **kwargs):\n        return plot_fieldmaps(self, **kwargs)\n\n    def __getitem__(self, key):\n\"\"\"\n        Convenience syntax to get a header or element attribute.\n\n        Special syntax:\n\n        end_X\n            will return the final item in a stat array X\n            Example:\n            'end_norm_emit_x'\n\n        particles:N\n            will return a ParticleGroup N from the .particles list\n            Example:\n                'particles:-1'\n                returns the readback of the final particles\n        particles:N:Y\n            ParticleGroup N's property Y\n            Example:\n                'particles:-1:sigma_x'\n            returns sigma_x from the end of the particles list.\n\n\n        See: __setitem__\n        \"\"\"\n\n        # Object attributes\n        if hasattr(self, key):\n            return getattr(self, key)\n\n            # Send back top level input (namelist) or group object.\n        # Do not add these to __setitem__. The user shouldn't be allowed to change them as a whole,\n        #   because it will break all the links.\n        if key in self.group:\n            return self.group[key]\n        if key in self.input:\n            return self.input[key]\n\n        if key.startswith('end_'):\n            key2 = key[len('end_'):]\n            assert key2 in self.output['stats'], f'{key} does not have valid output stat: {key2}'\n            return self.output['stats'][key2][-1]\n\n        if key.startswith('particles:'):\n            key2 = key[len('particles:'):]\n            x = key2.split(':')\n            if len(x) == 1:\n                return self.particles[int(x[0])]\n            else:\n                return self.particles[int(x[0])][x[1]]\n\n        # key isn't an ele or group, should have property s\n\n        x = key.split(':')\n        assert len(x) == 2, f'{x} was not found in group or input dict, so should have : '\n        name, attrib = x[0], x[1]\n\n        # Look in input and group\n        if name in self.input:\n            return self.input[name][attrib]\n        elif name in self.group:\n            return self.group[name][attrib]\n\n    def __setitem__(self, key, item):\n\"\"\"\n        Convenience syntax to set namelist or group attribute.\n        attribute_string should be 'header:key' or 'ele_name:key'\n\n        Examples of attribute_string: 'header:Np', 'SOL1:solenoid_field_scale'\n\n        Settable attributes can also be given:\n\n        ['stop'] = 1.2345 will set Impact.stop = 1.2345\n\n        \"\"\"\n\n        # Set attributes\n        if hasattr(self, key):\n            setattr(self, key, item)\n            return\n\n        # Must be in input or group\n        name, attrib = key.split(':')\n        if name in self.input:\n            self.input[name][attrib] = item\n        elif name in self.group:\n            self.group[name][attrib] = item\n        else:\n            raise ValueError(f'{name} does not exist in eles or groups of the Impact object.')\n\n\n\n    # Tracking\n    #---------\n    def track(self, particles, z=None):\n\"\"\"\n        Track a ParticleGroup. An optional stopping z can be given.\n\n        If successful, returns a ParticleGroup with the final particles.\n\n        Otherwise, returns None\n\n        \"\"\"\n\n        self.initial_particles = particles\n        if z is not None:\n            self['output:zstop'] = z\n\n        # Assure phase space output is turned on\n        nr = self.input['newrun']\n        if 'zphase' not in nr:\n            nr['zphase'] = 1\n        if nr['zphase'] &lt; 1:\n            nr['zphase'] = 1\n        # Turn particle output on.\n        nr['phases'] = True\n\n        self.run()\n\n        if 'particles' in self.output:\n            if len(self.output['particles']) == 0:\n                return None\n\n            final_particles = self.output['particles'][-1]\n\n            # Special case to remove probe particles\n            if len(self.initial_particles) == 1:\n                final_particles = final_particles[-1]        \n            return final_particles\n\n        else:\n            return None       \n\n    def track1(self,\n                  x0=0,\n                  px0=0,\n                  y0=0,\n                  py0=0,\n                  z0=0,\n                  pz0=1e-15,\n                  t0=0,\n                  weight=1,\n                  status=1,\n                  z=None, # final z\n                  species='electron'):\n\"\"\"\n        Tracks a single particle with starting coordinates:\n            x0, y0, z0 in meters\n            px0, py0, pz0 in eV/c\n            t0 in seconds\n\n        to a position 'z' in meters\n\n        If successful, returns a ParticleGroup with the final particle.\n\n        Otherwise, returns None\n\n        \"\"\"\n        p0 = single_particle(x=x0, px=px0, y=y0, py=py0, z=z0, pz=pz0, t=t0, weight=weight, status=status, species=species)\n        return self.track(p0, z=z)\n\n\n\n    @classmethod\n    @functools.wraps(astra_from_tao) \n    def from_tao(cls, tao):\n        return astra_from_tao(tao, cls=cls)    \n</code></pre>"},{"location":"api/astra/#astra.astra.Astra.add_group","title":"<code>add_group(name, **kwargs)</code>","text":"<p>Add a control group. See control.py</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The group name</p> required Source code in <code>astra/astra.py</code> <pre><code>def add_group(self, name, **kwargs):\n\"\"\"\n    Add a control group. See control.py\n\n    Parameters\n    ----------\n    name : str\n        The group name\n    \"\"\"\n    assert name not in self.input, f'{name} not allowed to be overwritten by group.'\n    if name in self.group:\n        self.vprint(f'Warning: group {name} already exists, overwriting.')\n\n    g = ControlGroup(**kwargs)\n    g.link(self.input)\n    self.group[name] = g\n\n    return self.group[name]\n</code></pre>"},{"location":"api/astra/#astra.astra.Astra.archive","title":"<code>archive(h5=None)</code>","text":"<p>Archive all data to an h5 handle or filename.</p> <p>If no file is given, a file based on the fingerprint will be created.</p> Source code in <code>astra/astra.py</code> <pre><code>def archive(self, h5=None):\n\"\"\"\n    Archive all data to an h5 handle or filename.\n\n    If no file is given, a file based on the fingerprint will be created.\n\n    \"\"\"\n    if not h5:\n        h5 = 'astra_' + self.fingerprint() + '.h5'\n\n    if isinstance(h5, str):\n        h5 = os.path.expandvars(h5)\n        g = h5py.File(h5, 'w')\n        self.vprint(f'Archiving to file {h5}')\n    else:\n        # store directly in the given h5 handle\n        g = h5\n\n    # Write basic attributes\n    archive.astra_init(g)\n\n    # Initial particles\n    if self.initial_particles:\n        self.initial_particles.write(g, name='initial_particles')\n\n    # Fieldmaps\n    if self.fieldmap:\n        archive.write_fieldmap_h5(g, self.fieldmap, name='fieldmap')\n\n    # All input\n    archive.write_input_h5(g, self.input)\n\n    # All output\n    archive.write_output_h5(g, self.output)\n\n    # Control groups\n    if self.group:\n        archive.write_control_groups_h5(g, self.group, name='control_groups')\n\n    return h5\n</code></pre>"},{"location":"api/astra/#astra.astra.Astra.load_archive","title":"<code>load_archive(h5=None, configure=False)</code>","text":"<p>Loads input and output from archived h5 file.</p> <p>See: Astra.archive</p> Source code in <code>astra/astra.py</code> <pre><code>def load_archive(self, h5=None, configure=False):\n\"\"\"\n    Loads input and output from archived h5 file.\n\n    See: Astra.archive\n    \"\"\"\n    if isinstance(h5, str):\n        h5 = os.path.expandvars(h5)\n        g = h5py.File(h5, 'r')\n\n        glist = archive.find_astra_archives(g)\n        n = len(glist)\n        if n == 0:\n            # legacy: try top level\n            message = 'legacy'\n        elif n == 1:\n            gname = glist[0]\n            message = f'group {gname} from'\n            g = g[gname]\n        else:\n            raise ValueError(f'Multiple archives found in file {h5}: {glist}')\n\n        self.vprint(f'Reading {message} archive file {h5}')\n    else:\n        g = h5\n\n    self.input = archive.read_input_h5(g['input'])\n    self.output = archive.read_output_h5(g['output'])\n    if 'initial_particles' in g:\n        self.initial_particles = ParticleGroup(h5=g['initial_particles'])\n\n    if 'fieldmap' in g:\n        self.fieldmap = archive.read_fieldmap_h5(g['fieldmap'])\n\n    if 'control_groups' in g:\n        self.group = archive.read_control_groups_h5(g['control_groups'], verbose=self.verbose)\n\n    self.vprint('Loaded from archive. Note: Must reconfigure to run again.')\n    self.configured = False\n\n    # Re-link groups\n    # TODO: cleaner logic\n    for _, cg in self.group.items():\n        cg.link(self.input)\n\n    if configure:\n        self.configure()\n</code></pre>"},{"location":"api/astra/#astra.astra.Astra.load_fieldmaps","title":"<code>load_fieldmaps(search_paths=[])</code>","text":"<p>Loads fieldmaps into Astra.fieldmap as a dict.</p> <p>Optionally, a list of paths can be included that will search for these. The default will search self.path.</p> Source code in <code>astra/astra.py</code> <pre><code>def load_fieldmaps(self, search_paths=[]):\n\"\"\"\n    Loads fieldmaps into Astra.fieldmap as a dict.\n\n    Optionally, a list of paths can be included that will search for these. The default will search self.path.\n    \"\"\"\n\n    # Do not consider files if fieldmaps have been loaded.\n    if self.fieldmap:\n        strip_path = False\n    else:\n        strip_path = True\n\n    if not search_paths:\n        search_paths = [self.path]\n\n    self.fieldmap = load_fieldmaps(self.input, fieldmap_dict=self.fieldmap, search_paths=search_paths,\n                                   verbose=self.verbose, strip_path=strip_path)\n</code></pre>"},{"location":"api/astra/#astra.astra.Astra.load_initial_particles","title":"<code>load_initial_particles(h5)</code>","text":"<p>Loads a openPMD-beamphysics particle h5 handle or file</p> Source code in <code>astra/astra.py</code> <pre><code>def load_initial_particles(self, h5):\n\"\"\"Loads a openPMD-beamphysics particle h5 handle or file\"\"\"\n    P = ParticleGroup(h5=h5)\n    self.initial_particles = P\n</code></pre>"},{"location":"api/astra/#astra.astra.Astra.load_output","title":"<code>load_output(include_particles=True)</code>","text":"<p>Loads Astra output files into .output</p> <p>.output is a dict with dicts:     .stats     .run_info     .other</p> <p>and if include_particles,     .particles = list of ParticleGroup objects</p> Source code in <code>astra/astra.py</code> <pre><code>def load_output(self, include_particles=True):\n\"\"\"\n    Loads Astra output files into .output\n\n    .output is a dict with dicts:\n        .stats\n        .run_info\n        .other\n\n    and if include_particles,\n        .particles = list of ParticleGroup objects\n\n    \"\"\"\n    run_number = parsers.astra_run_extension(self.input['newrun']['run'])\n    outfiles = parsers.find_astra_output_files(self.input_file, run_number)\n\n    # assert len(outfiles)&gt;0, 'No output files found'\n\n    stats = self.output['stats'] = {}\n\n    for f in outfiles:\n        type = parsers.astra_output_type(f)\n        d = parsers.parse_astra_output_file(f)\n        if type in ['Cemit', 'Xemit', 'Yemit', 'Zemit']:\n            stats.update(d)\n        elif type in ['LandF']:\n            self.output['other'] = d\n        else:\n            raise ValueError(f'Unknown output type: {type}')\n\n    # Check that the lengths of all arrays are the same\n    nlist = {len(stats[k]) for k in stats}\n\n    assert len(nlist) == 1, f'Stat keys do not all have the same length: {[len(stats[k]) for k in stats]}'\n\n    if include_particles:\n        self.load_particles()\n</code></pre>"},{"location":"api/astra/#astra.astra.Astra.particle_stat","title":"<code>particle_stat(key, alive_only=True)</code>","text":"<p>Compute a statistic from the particles.</p> <p>Alive particles have status == 1. By default, statistics will only be computed on these.</p> <p>n_dead will override the alive_only flag, and return the number of particles with status &lt; -6 (Astra convention)</p> Source code in <code>astra/astra.py</code> <pre><code>def particle_stat(self, key, alive_only=True):\n\"\"\"\n    Compute a statistic from the particles.\n\n    Alive particles have status == 1. By default, statistics will only be computed on these.\n\n    n_dead will override the alive_only flag,\n    and return the number of particles with status &lt; -6 (Astra convention)\n    \"\"\"\n\n    if key == 'n_dead':\n        return np.array([len(np.where(P.status &lt; -6)[0]) for P in self.particles])\n\n    if key == 'n_alive':\n        return np.array([len(np.where(P.status &gt; -6)[0]) for P in self.particles])\n\n    pstats = []\n    for P in self.particles:\n        if alive_only and P.n_dead &gt; 0:\n            P = P.where(P.status == 1)\n        pstats.append(P[key])\n    return np.array(pstats)\n</code></pre>"},{"location":"api/astra/#astra.astra.Astra.plot","title":"<code>plot(y=['sigma_x', 'sigma_y'], x='mean_z', xlim=None, ylim=None, ylim2=None, y2=[], nice=True, include_layout=True, include_labels=False, include_particles=True, include_legend=True, return_figure=False, **kwargs)</code>","text":"<p>Plots stat output multiple keys.</p> <p>If a list of ykeys2 is given, these will be put on the right hand axis. This can also be given as a single key.</p> <p>Logical switches:     nice: a nice SI prefix and scaling will be used to make the numbers reasonably sized. Default: True</p> <pre><code>include_legend: The plot will include the legend.  Default: True\n\ninclude_particles: Plot the particle statistics as dots. Default: True\n\ninclude_layout: the layout plot will be displayed at the bottom.  Default: True\n\ninclude_labels: the layout will include element labels.  Default: False\n\nreturn_figure: return the figure object for further manipulation. Default: False\n</code></pre> <p>If there is no output to plot, the fieldmaps will be plotted with .plot_fieldmaps</p> Source code in <code>astra/astra.py</code> <pre><code>def plot(self, y=['sigma_x', 'sigma_y'], x='mean_z', xlim=None, ylim=None, ylim2=None, y2=[],\n         nice=True,\n         include_layout=True,\n         include_labels=False,\n         include_particles=True,\n         include_legend=True,\n         return_figure=False,\n         **kwargs):\n\"\"\"\n    Plots stat output multiple keys.\n\n    If a list of ykeys2 is given, these will be put on the right hand axis. This can also be given as a single key.\n\n    Logical switches:\n        nice: a nice SI prefix and scaling will be used to make the numbers reasonably sized. Default: True\n\n        include_legend: The plot will include the legend.  Default: True\n\n        include_particles: Plot the particle statistics as dots. Default: True\n\n        include_layout: the layout plot will be displayed at the bottom.  Default: True\n\n        include_labels: the layout will include element labels.  Default: False\n\n        return_figure: return the figure object for further manipulation. Default: False\n\n    If there is no output to plot, the fieldmaps will be plotted with .plot_fieldmaps\n\n    \"\"\"\n\n    # Just plot fieldmaps if there are no stats\n    if not self.output['stats']:\n        return plot_fieldmaps(self, xlim=xlim, **kwargs)\n\n    return plot_stats_with_layout(self, ykeys=y, ykeys2=y2,\n                                  xkey=x, xlim=xlim, ylim=ylim, ylim2=ylim2,\n                                  nice=nice,\n                                  include_layout=include_layout,\n                                  include_labels=include_labels,\n                                  include_particles=include_particles,\n                                  include_legend=include_legend,\n                                  return_figure=return_figure,\n                                  **kwargs)\n</code></pre>"},{"location":"api/astra/#astra.astra.Astra.run_astra","title":"<code>run_astra(verbose=False, parse_output=True, timeout=None)</code>","text":"<p>Runs Astra</p> <p>Changes directory, so does not work with threads.</p> Source code in <code>astra/astra.py</code> <pre><code>def run_astra(self, verbose=False, parse_output=True, timeout=None):\n\"\"\"\n    Runs Astra\n\n    Changes directory, so does not work with threads.\n    \"\"\"\n    if not self.configured:\n        print('not configured to run')\n        return\n\n    run_info = self.output['run_info'] = {}\n\n    t1 = time()\n    run_info['start_time'] = t1\n\n    # Write all input\n    self.write_input()\n\n    runscript = self.get_run_script()\n    tools.make_executable(os.path.join(self.path, 'run'))\n    run_info['run_script'] = ' '.join(runscript)\n\n    if self.timeout:\n        res = tools.execute2(runscript, timeout=timeout, cwd=self.path)\n        log = res['log']\n        self.error = res['error']\n        run_info['why_error'] = res['why_error']\n        # Log file must have this to have finished properly\n        if log.find('finished simulation') == -1:\n            raise ValueError(\"Couldn't find finished simulation\")\n\n    else:\n        # Interactive output, for Jupyter\n        log = []\n        for path in tools.execute(runscript, cwd=self.path):\n            self.vprint(path, end=\"\")\n            log.append(path)\n\n    self.log = log\n\n    if parse_output:\n        self.load_output()\n\n    run_info['run_time'] = time() - t1\n\n    self.finished = True\n\n    self.vprint(run_info)\n</code></pre>"},{"location":"api/astra/#astra.astra.Astra.track","title":"<code>track(particles, z=None)</code>","text":"<p>Track a ParticleGroup. An optional stopping z can be given.</p> <p>If successful, returns a ParticleGroup with the final particles.</p> <p>Otherwise, returns None</p> Source code in <code>astra/astra.py</code> <pre><code>def track(self, particles, z=None):\n\"\"\"\n    Track a ParticleGroup. An optional stopping z can be given.\n\n    If successful, returns a ParticleGroup with the final particles.\n\n    Otherwise, returns None\n\n    \"\"\"\n\n    self.initial_particles = particles\n    if z is not None:\n        self['output:zstop'] = z\n\n    # Assure phase space output is turned on\n    nr = self.input['newrun']\n    if 'zphase' not in nr:\n        nr['zphase'] = 1\n    if nr['zphase'] &lt; 1:\n        nr['zphase'] = 1\n    # Turn particle output on.\n    nr['phases'] = True\n\n    self.run()\n\n    if 'particles' in self.output:\n        if len(self.output['particles']) == 0:\n            return None\n\n        final_particles = self.output['particles'][-1]\n\n        # Special case to remove probe particles\n        if len(self.initial_particles) == 1:\n            final_particles = final_particles[-1]        \n        return final_particles\n\n    else:\n        return None       \n</code></pre>"},{"location":"api/astra/#astra.astra.Astra.track1","title":"<code>track1(x0=0, px0=0, y0=0, py0=0, z0=0, pz0=1e-15, t0=0, weight=1, status=1, z=None, species='electron')</code>","text":"<p>Tracks a single particle with starting coordinates:     x0, y0, z0 in meters     px0, py0, pz0 in eV/c     t0 in seconds</p> <p>to a position 'z' in meters</p> <p>If successful, returns a ParticleGroup with the final particle.</p> <p>Otherwise, returns None</p> Source code in <code>astra/astra.py</code> <pre><code>def track1(self,\n              x0=0,\n              px0=0,\n              y0=0,\n              py0=0,\n              z0=0,\n              pz0=1e-15,\n              t0=0,\n              weight=1,\n              status=1,\n              z=None, # final z\n              species='electron'):\n\"\"\"\n    Tracks a single particle with starting coordinates:\n        x0, y0, z0 in meters\n        px0, py0, pz0 in eV/c\n        t0 in seconds\n\n    to a position 'z' in meters\n\n    If successful, returns a ParticleGroup with the final particle.\n\n    Otherwise, returns None\n\n    \"\"\"\n    p0 = single_particle(x=x0, px=px0, y=y0, py=py0, z=z0, pz=pz0, t=t0, weight=weight, status=status, species=species)\n    return self.track(p0, z=z)\n</code></pre>"},{"location":"api/astra/#astra.astra.Astra.write_fieldmaps","title":"<code>write_fieldmaps(path=None)</code>","text":"<p>Writes any loaded fieldmaps to path</p> Source code in <code>astra/astra.py</code> <pre><code>def write_fieldmaps(self, path=None):\n\"\"\"\n    Writes any loaded fieldmaps to path\n    \"\"\"\n    if path is None:\n        path = self.path         \n\n    if self.fieldmap:\n        write_fieldmaps(self.fieldmap, path)\n        self.vprint(f'{len(self.fieldmap)} fieldmaps written to {path}')\n</code></pre>"},{"location":"api/astra/#astra.astra.Astra.write_input","title":"<code>write_input(input_filename=None, path=None, make_symlinks=True)</code>","text":"<p>Writes all input. If fieldmaps have been loaded, these will also be written.</p> Source code in <code>astra/astra.py</code> <pre><code>def write_input(self, input_filename=None, path=None, make_symlinks=True):\n\"\"\"\n    Writes all input. If fieldmaps have been loaded, these will also be written.\n    \"\"\"\n\n    if path is None:\n        path = self.path        \n\n    if self.initial_particles:\n        fname = self.write_initial_particles(path=path)\n        self.input['newrun']['distribution'] = fname\n\n    self.write_fieldmaps(path=path)\n\n    self.write_input_file(path=path, make_symlinks=make_symlinks)\n</code></pre>"},{"location":"api/astra/#astra.astra.recommended_spacecharge_mesh","title":"<code>recommended_spacecharge_mesh(n_particles)</code>","text":"<p>! -------------------------------------------------------- ! Suggested Nrad, Nlong_in settings from: !    A. Bartnik and C. Gulliford (Cornell University) ! ! Nrad = 35,    Nlong_in = 75  !28K ! Nrad = 29,    Nlong_in = 63  !20K ! Nrad = 20,    Nlong_in = 43  !10K ! Nrad = 13,    Nlong_in = 28  !4K ! Nrad = 10,    Nlong_in = 20  !2K ! Nrad = 8,     Nlong_in = 16  !1K ! ! Nrad ~ round(3.3(n_particles/1000)^(2/3) + 5) ! Nlong_in ~ round(9.2(n_particles/1000)^(0.603) + 6.5) ! !</p> Source code in <code>astra/astra.py</code> <pre><code>def recommended_spacecharge_mesh(n_particles):\n\"\"\"\n    ! --------------------------------------------------------\n    ! Suggested Nrad, Nlong_in settings from:\n    !    A. Bartnik and C. Gulliford (Cornell University)\n    !\n    ! Nrad = 35,    Nlong_in = 75  !28K\n    ! Nrad = 29,    Nlong_in = 63  !20K\n    ! Nrad = 20,    Nlong_in = 43  !10K\n    ! Nrad = 13,    Nlong_in = 28  !4K\n    ! Nrad = 10,    Nlong_in = 20  !2K\n    ! Nrad = 8,     Nlong_in = 16  !1K\n    !\n    ! Nrad ~ round(3.3*(n_particles/1000)^(2/3) + 5)\n    ! Nlong_in ~ round(9.2*(n_particles/1000)^(0.603) + 6.5)\n    !\n    ! \n    \"\"\"\n    if n_particles &lt; 1000:\n        # Set a minimum\n        nrad = 8\n        nlong_in = 16\n    else:\n        # Prefactors were recalculated from above note. \n        nrad = round(3.3e-2 * n_particles ** (2 / 3) + 5)\n        nlong_in = round(0.143 * n_particles ** (0.603) + 6.5)\n    return {'nrad': nrad, 'nlong_in': nlong_in}\n</code></pre>"},{"location":"api/astra/#astra.astra.run_astra","title":"<code>run_astra(settings=None, astra_input_file=None, workdir=None, command='$ASTRA_BIN', timeout=2500, verbose=False)</code>","text":"<p>Run Astra. </p> <pre><code>settings: dict with keys that can appear in an Astra input file.\n</code></pre> Source code in <code>astra/astra.py</code> <pre><code>def run_astra(settings=None,\n              astra_input_file=None,\n              workdir=None,\n              command='$ASTRA_BIN',\n              timeout=2500,\n              verbose=False):\n\"\"\"\n    Run Astra. \n\n        settings: dict with keys that can appear in an Astra input file. \n    \"\"\"\n    if verbose:\n        print('run_astra')\n\n        # Make astra object\n    A = Astra(command=command, input_file=astra_input_file, workdir=workdir)\n\n    A.timeout = timeout\n    A.verbose = verbose\n\n    A.input['newrun']['l_rm_back'] = True  # Remove backwards particles\n\n    # Set inputs\n    if settings:\n        set_astra(A, {}, settings, verbose=verbose)\n\n    # Run\n    A.run()\n\n    return A\n</code></pre>"},{"location":"api/astra/#astra.astra.run_astra_with_generator","title":"<code>run_astra_with_generator(settings=None, astra_input_file=None, generator_input_file=None, workdir=None, command='$ASTRA_BIN', command_generator='$GENERATOR_BIN', timeout=2500, verbose=False, auto_set_spacecharge_mesh=True)</code>","text":"<p>Run Astra with particles generated by Astra's generator. </p> <pre><code>settings: dict with keys that can appear in an Astra or Generator input file.\n</code></pre> Source code in <code>astra/astra.py</code> <pre><code>def run_astra_with_generator(settings=None,\n                             astra_input_file=None,\n                             generator_input_file=None,\n                             workdir=None,\n                             command='$ASTRA_BIN',\n                             command_generator='$GENERATOR_BIN',\n                             timeout=2500, verbose=False,\n                             auto_set_spacecharge_mesh=True):\n\"\"\"\n    Run Astra with particles generated by Astra's generator. \n\n        settings: dict with keys that can appear in an Astra or Generator input file. \n    \"\"\"\n\n    assert astra_input_file, 'No astra input file'\n\n    # Call simpler evaluation if there is no generator:\n    if not generator_input_file:\n        return run_astra(settings=settings,\n                         astra_input_file=astra_input_file,\n                         workdir=workdir,\n                         command=command,\n                         timeout=timeout,\n                         verbose=verbose)\n\n    if verbose:\n        print('run_astra_with_generator')\n\n        # Make astra and generator objects\n    A = Astra(command=command, input_file=astra_input_file, workdir=workdir)\n    A.timeout = timeout\n    A.verbose = verbose\n    G = AstraGenerator(command=command_generator, input_file=generator_input_file, workdir=workdir)\n    G.verbose = verbose\n\n    A.input['newrun']['l_rm_back'] = True  # Remove backwards particles\n\n    # Set inputs\n    if settings:\n        set_astra(A, G.input, settings, verbose=verbose)\n\n    # Attach generator input. This is non-standard. \n    A.generator_input = G.input        \n\n    if auto_set_spacecharge_mesh:\n        n_particles = G.input['ipart']\n        sc_settings = recommended_spacecharge_mesh(n_particles)\n        A.input['charge'].update(sc_settings)\n        if verbose:\n            print('set spacecharge mesh for n_particles:', n_particles, 'to', sc_settings)\n\n            # Run Generator\n    G.run()\n    A.initial_particles = G.output['particles']\n    A.run()\n    if verbose:\n        print('run_astra_with_generator finished')\n\n    return A\n</code></pre>"},{"location":"api/astra/#astra.astra.set_astra","title":"<code>set_astra(astra_object, generator_input, settings, verbose=False)</code>","text":"<p>Searches astra and generator objects for keys in settings, and sets their values to the appropriate input</p> Source code in <code>astra/astra.py</code> <pre><code>def set_astra(astra_object, generator_input, settings, verbose=False):\n\"\"\"\n    Searches astra and generator objects for keys in settings, and sets their values to the appropriate input\n    \"\"\"\n    astra_input = astra_object.input  # legacy syntax\n\n    for k, v in settings.items():\n        found = False\n\n        # Check for direct settable attribute\n        if ':' in k:\n            astra_object[k] = v\n            continue\n\n        for nl in astra_input:\n            if k in astra_input[nl]:\n                found = True\n                if verbose:\n                    print(k, 'is in astra', nl)\n                astra_input[nl][k] = settings[k]\n        if not found:\n            if k in generator_input:\n                found = True\n                generator_input[k] = settings[k]\n                if verbose:\n                    print(k, 'is in generator')\n\n        if not found and verbose:\n            print(k, 'not found')\n        assert found\n</code></pre>"},{"location":"api/generator/","title":"Generator","text":""},{"location":"api/generator/#astra.generator","title":"<code>astra.generator</code>","text":""},{"location":"api/generator/#astra.generator.AstraGenerator","title":"<code>AstraGenerator</code>","text":"<p>             Bases: <code>CommandWrapper</code></p> <p>Class to run Astra's particle generator</p> <p>The file for Astra is written in: .output_file</p> Source code in <code>astra/generator.py</code> <pre><code>class AstraGenerator(CommandWrapper):\n\"\"\"\n    Class to run Astra's particle generator\n\n\n    The file for Astra is written in:\n    .output_file\n\n    \"\"\"\n    COMMAND = \"$GENERATOR_BIN\"\n\n    def __init__(self, input_file=None, **kwargs):\n        super().__init__(input_file=input_file, **kwargs)\n        # Save init\n\n        if isinstance(input_file, str):\n            self.original_input_file = self.input_file\n        else:\n            self.original_input_file = 'generator.in'\n\n        # These will be filled\n        self.input = {}\n        self.output = {}\n\n        # Call configure\n        if self.input_file:\n            self.load_input(self.input_file)\n            self.configure()\n\n    def load_input(self, input_filepath, absolute_paths=True, **kwargs):\n        # Allow dict\n        if isinstance(input_filepath, dict):\n            self.input = input_filepath\n            return\n\n        super().load_input(input_filepath, **kwargs)\n        if absolute_paths:\n            parsers.fix_input_paths(self.input, root=self.original_path)\n        self.input = self.input['input']\n\n\n    def input_parser(self, path):\n        return parsers.parse_astra_input_file(path)\n\n    def configure(self):\n        # Check that binary exists\n        self.command = lumetools.full_path(self.command)\n        self.setup_workdir(self.path)\n\n        self.input_file = os.path.join(self.path, self.original_input_file)\n\n        # We will change directories to work in the local directory\n        self.input['fname'] = 'generator.part'\n\n        self.configured = True\n\n    def run(self):\n\"\"\"\n        Runs Generator\n\n        Note: do not use os.chdir\n        \"\"\"\n        self.write_input_file()\n\n        runscript = self.get_run_script()\n\n        try:\n            res = tools.execute2(runscript, timeout=None, cwd=self.path)\n            self.log = res['log']\n\n            self.vprint(self.log)\n\n            # This is the file that should be written\n            if os.path.exists(self.output_file):\n                self.finished = True\n            else:\n                print(f'AstraGenerator.output_file {self.output_file} does not exist.')\n                print(f'Here is what the current working dir looks like: {os.listdir(self.path)}')\n            self.load_output()\n\n        except Exception as ex:\n            print('AstraGenerator.run exception:', traceback.format_exc())\n            self.error = True\n        finally:\n            pass\n\n    @property\n    def output_file(self):\n        return os.path.join(self.path, self.input['fname'])\n\n    def load_output(self):\n        pfile = self.output_file\n        data = parse_astra_phase_file(pfile)\n        # Clock time is used when at cathode\n        data['t'] = data['t_clock']\n        P = ParticleGroup(data=data)\n\n        self.output['particles'] = P\n\n    def write_input_file(self):\n        writers.write_namelists({'input': self.input}, self.input_file)\n\n    # Methods from CommandWrapper not implemented here\n    def archive(self, h5=None):\n\"\"\"\n        Archive all data to an h5 handle or filename.\n\n        If no file is given, a file based on the fingerprint will be created.\n\n        \"\"\"\n        if not h5:\n            h5 = 'astra_generator_' + self.fingerprint() + '.h5'\n\n        if isinstance(h5, str):\n            h5 = os.path.expandvars(h5)\n            g = h5py.File(h5, 'w')\n            self.vprint(f'Archiving to file {h5}')\n        else:\n            # store directly in the given h5 handle\n            g = h5\n\n        # Write basic attributes\n        archive.astra_init(g)\n\n        # All input\n        g2 = g.create_group('generator_input')\n        for k, v in self.input.items():\n            g2.attrs[k] = v\n\n        return h5\n\n    def load_archive(self, h5, configure=True):\n\"\"\"\n        Loads input and output from archived h5 file.\n        \"\"\"\n        if isinstance(h5, str):\n            h5 = os.path.expandvars(h5)\n            g = h5py.File(h5, 'r')  \n        else:\n            g = h5\n\n        attrs = dict(g['generator_input'].attrs)\n        self.input = {}\n        for k, v, in attrs.items():\n            self.input[k] = tools.native_type(v)\n\n        if configure:\n            self.configure()        \n\n\n    def plot(self, y=..., x=None, xlim=None, ylim=None, ylim2=None, y2=..., nice=True, include_layout=True, include_labels=False, include_particles=True, include_legend=True, return_figure=False):\n        return super().plot(y=y, x=x, xlim=xlim, ylim=ylim, ylim2=ylim2, y2=y2, nice=nice, include_layout=include_layout, include_labels=include_labels, include_particles=include_particles, include_legend=include_legend, return_figure=return_figure)\n\n    def write_input(self, input_filename):\n        return super().write_input(input_filename)\n</code></pre>"},{"location":"api/generator/#astra.generator.AstraGenerator.archive","title":"<code>archive(h5=None)</code>","text":"<p>Archive all data to an h5 handle or filename.</p> <p>If no file is given, a file based on the fingerprint will be created.</p> Source code in <code>astra/generator.py</code> <pre><code>def archive(self, h5=None):\n\"\"\"\n    Archive all data to an h5 handle or filename.\n\n    If no file is given, a file based on the fingerprint will be created.\n\n    \"\"\"\n    if not h5:\n        h5 = 'astra_generator_' + self.fingerprint() + '.h5'\n\n    if isinstance(h5, str):\n        h5 = os.path.expandvars(h5)\n        g = h5py.File(h5, 'w')\n        self.vprint(f'Archiving to file {h5}')\n    else:\n        # store directly in the given h5 handle\n        g = h5\n\n    # Write basic attributes\n    archive.astra_init(g)\n\n    # All input\n    g2 = g.create_group('generator_input')\n    for k, v in self.input.items():\n        g2.attrs[k] = v\n\n    return h5\n</code></pre>"},{"location":"api/generator/#astra.generator.AstraGenerator.load_archive","title":"<code>load_archive(h5, configure=True)</code>","text":"<p>Loads input and output from archived h5 file.</p> Source code in <code>astra/generator.py</code> <pre><code>def load_archive(self, h5, configure=True):\n\"\"\"\n    Loads input and output from archived h5 file.\n    \"\"\"\n    if isinstance(h5, str):\n        h5 = os.path.expandvars(h5)\n        g = h5py.File(h5, 'r')  \n    else:\n        g = h5\n\n    attrs = dict(g['generator_input'].attrs)\n    self.input = {}\n    for k, v, in attrs.items():\n        self.input[k] = tools.native_type(v)\n\n    if configure:\n        self.configure()        \n</code></pre>"},{"location":"api/generator/#astra.generator.AstraGenerator.run","title":"<code>run()</code>","text":"<p>Runs Generator</p> <p>Note: do not use os.chdir</p> Source code in <code>astra/generator.py</code> <pre><code>def run(self):\n\"\"\"\n    Runs Generator\n\n    Note: do not use os.chdir\n    \"\"\"\n    self.write_input_file()\n\n    runscript = self.get_run_script()\n\n    try:\n        res = tools.execute2(runscript, timeout=None, cwd=self.path)\n        self.log = res['log']\n\n        self.vprint(self.log)\n\n        # This is the file that should be written\n        if os.path.exists(self.output_file):\n            self.finished = True\n        else:\n            print(f'AstraGenerator.output_file {self.output_file} does not exist.')\n            print(f'Here is what the current working dir looks like: {os.listdir(self.path)}')\n        self.load_output()\n\n    except Exception as ex:\n        print('AstraGenerator.run exception:', traceback.format_exc())\n        self.error = True\n    finally:\n        pass\n</code></pre>"},{"location":"api/install/","title":"Install","text":""},{"location":"api/install/#astra.install","title":"<code>astra.install</code>","text":""},{"location":"api/install/#astra.install.install_astra","title":"<code>install_astra(dest_dir=None, name='Astra', verbose=False)</code>","text":"<p>Installs Astra from Klaus Floettmann's DESY website for the detected platform.</p> <p>Sets environmental variable ASTRA_BIN</p> Source code in <code>astra/install.py</code> <pre><code>def install_astra(dest_dir=None, name='Astra', verbose=False):\n\"\"\"\n    Installs Astra from Klaus Floettmann's DESY website for the detected platform.\n\n    Sets environmental variable ASTRA_BIN\n    \"\"\"\n    system = platform.system()\n    url=ASTRA_URL[system]\n    dest = os.path.abspath(os.path.join(dest_dir, name))\n\n    install_executable(url,  dest, verbose=verbose)\n\n    os.environ['ASTRA_BIN'] = dest\n\n    if verbose:\n        print(f'Installed Astra in {dest}, and set $ASTRA_BIN equal to this.')\n\n    return dest\n</code></pre>"},{"location":"api/install/#astra.install.install_examples","title":"<code>install_examples(location)</code>","text":"<p>Install lume-astra examples on the informed location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>The folder in which to install the examples</p> required Source code in <code>astra/install.py</code> <pre><code>def install_examples(location):\n\"\"\"\n    Install lume-astra examples on the informed location.\n\n    Parameters\n    ----------\n    location : str\n        The folder in which to install the examples\n    \"\"\"\n    import requests\n    import zipfile\n    import io\n    import os\n\n    loc = os.path.expanduser(os.path.expandvars(location))\n    os.makedirs(loc, exist_ok=True)\n\n    response = requests.get(EXAMPLES_URL, stream=True)\n    if response.status_code == 200:\n        zip_file = zipfile.ZipFile(io.BytesIO(response.content))\n        zip_file.extractall(loc)\n    else:\n        raise RuntimeError(f\"Could not download examples archive. Status code was: {response.status_code}\")\n</code></pre>"},{"location":"api/install/#astra.install.install_executable","title":"<code>install_executable(url, dest, verbose=False)</code>","text":"<p>Downloads a url into a destination and makes it executable. Will not overwrite.</p> Source code in <code>astra/install.py</code> <pre><code>def install_executable(url, dest, verbose=False):\n\"\"\"\n    Downloads a url into a destination and makes it executable. Will not overwrite.\n    \"\"\"\n\n    if os.path.exists(dest):\n        print(os.path.abspath(dest), 'exists, will not overwrite')\n    else:\n        if verbose:\n            print(f'Downloading {url} to {dest}')\n        urllib.request.urlretrieve(url, dest)   \n        make_executable(dest)\n\n    return dest\n</code></pre>"},{"location":"api/install/#astra.install.install_generator","title":"<code>install_generator(dest_dir=None, name='generator', verbose=False)</code>","text":"<p>Installs Astra's generator from Klaus Floettmann's DESY website for the detected platform.</p> <p>Sets environmental variable GENERATOR_BIN</p> Source code in <code>astra/install.py</code> <pre><code>def install_generator(dest_dir=None, name='generator', verbose=False):\n\"\"\"\n    Installs Astra's generator from Klaus Floettmann's DESY website for the detected platform.\n\n    Sets environmental variable GENERATOR_BIN\n    \"\"\"\n    system = platform.system()\n    url=GENERATOR_URL[system]\n    dest = os.path.abspath(os.path.join(dest_dir, name))\n    install_executable(url,  dest, verbose=verbose)\n\n    os.environ['GENERATOR_BIN'] = dest\n\n    if verbose:\n        print(f'Installed Astra\\'s generator in {dest}, and set $GENERATOR_BIN equal to this.')    \n\n    return dest\n</code></pre>"},{"location":"examples/basic_astra_examples/","title":"LUME-Astra Basic Examples","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n\n# Nicer plotting\nimport matplotlib.pyplot as plt\nimport matplotlib\nmatplotlib.rcParams['figure.figsize'] = (12,8)\n%config InlineBackend.figure_format = 'retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2  # Nicer plotting import matplotlib.pyplot as plt import matplotlib matplotlib.rcParams['figure.figsize'] = (12,8) %config InlineBackend.figure_format = 'retina' <p>Make an Astra object</p> In\u00a0[2]: Copied! <pre>from astra import Astra\n</pre> from astra import Astra In\u00a0[3]: Copied! <pre>A = Astra('templates/dcgun/astra.in')\n</pre> A = Astra('templates/dcgun/astra.in') <p>Change some inputs</p> In\u00a0[4]: Copied! <pre>A.input['newrun']['zemit']  = 1000\nA.input['newrun']['zphase'] = 20\nA.input['newrun']['phases'] = True\nA.input['output']['zstop']  = 1\n\n# Special flags\nA.timeout = None\nA.verbose = True\n</pre> A.input['newrun']['zemit']  = 1000 A.input['newrun']['zphase'] = 20 A.input['newrun']['phases'] = True A.input['output']['zstop']  = 1  # Special flags A.timeout = None A.verbose = True <p>Run</p> In\u00a0[5]: Copied! <pre>A.run()\n</pre> A.run() <pre> --------------------------------------------------------------------------\n\n                Astra- A space charge tracking algorithm \n               Version 4.0 - macOS 64bit - Apple Silicon   \n                        DESY,  Hamburg 2022          \n                        Wed Aug  2 08:47:11 \n\n     Parameter file is:  astra.in                                          \n     astra input file for L0 injector (20070501_1)                                   \n\n Initialize element settings:\n     neglecting space charge forces \n\n --------------------------------------------------------------------------\n Cavity:\n\n     Reading cavity field data from:      dcgun_GHV.dat                                                                   \n     maximum gradient                     -11.60     MV/m\n     at                                   3.9750E-02 m\n     estimated average gradient            2.353     MV/m\n     nominal phase                         0.000     deg\n\n --------------------------------------------------------------------------\n Solenoid:\n\n     Reading solenoid field data from:    solenoid_SLA_L60.dat                                                            \n     maximum |Bz| field                    2.4219E-02 T\n     at                                    0.3030     m\n     integral Bz squared                   4.8804E-05 T^2m\n\n --------------------------------------------------------------------------\n    2000 particles from file generator.part                                    \n\n\n     Cathode located at:               z =      0.000     m\n     Particles taken into account      N =       2000\n     total charge                      Q =    -0.1000     nC\n     horizontal beam position          x =     2.3378E-06 mm\n     vertical beam position            y =     8.9462E-06 mm\n     longitudinal beam position        z =      0.000     m\n     horizontal beam size          sig x =     0.2500     mm\n     vertical beam size            sig y =     0.2500     mm\n     longitudinal beam size        sig z =      0.000     mm\n     total emission time               t =     5.4627E-02 ns\n     rms emission time             sig t =     8.4501E-03 ns\n     average kinetic energy            E =     1.0197E-06 MeV\n     energy spread                    dE =     4.2631E-04 keV\n     average momentum                  P =     1.0208E-03 MeV/c\n     transverse beam emittance     eps x =     0.1747     pi mrad mm\n     correlated divergence         cor x =     6.8371E-03 mrad \n     transverse beam emittance     eps y =     0.1750     pi mrad mm\n     correlated divergence         cor y =    -4.4571E-03 mrad\n     longitudinal beam emittance   eps z =      0.000     pi keV mm\n     correlated energy spread      cor z =      0.000     keV\n     emittance ratio eps y/eps x         =     0.9982    \n --------------------------------------------------------------------------\n     Start auto phasing: \n     Reject phase scan of cavity number  :   1:   DC field\n\n     Cavity phasing completed:\n     Cavity number   Energy gain [MeV]  at  Phase [deg]\n --------------------------------------------------------------------------\n on axis tracking of the reference particle:\n     initial position                  z =    0.000     m\n                                       x =    0.000     mm\n                                       y =    0.000     mm\n     initial momentum                  p =   1.0109E-03 MeV/c\n     global phase shift              phi =    0.000     deg\n     time step for integration        dt =    2.000     ps\n --------------------------------------------------------------------------\n Online element settings:\n\n --------------------------------------------------------------------------\n\n     particle reaches position         z =    1.000     m\n     time of flight is                 t =    4.015     ns\n     final momentum                    p =   0.8721     MeV/c\n     final phase (cavity 1)      phi_end =    0.000     deg\n --------------------------------------------------------------------------\n off axis tracking of the reference particle: \n     initial position                  z =    0.000     m\n                                       x =   0.2500     mm\n                                       y =   0.2500     mm\n\n     final position                    x =  -6.9899E-02 mm\n                                       y =  -0.2846     mm\n     divergence                    px/pz =  -0.1366     mrad\n                                   py/pz =  -0.5564     mrad\n --------------------------------------------------------------------------\n tracking of     2000 particles:\n     tracking will stop at             z =    1.000     m\n\n\n     final checkpoint at               z =    1.000     m\n     total number of iteration steps:          2099\n\n     **********************************************************************\n\n     Particles taken into account      N =       2000\n     total charge                      Q =    -0.1000     nC\n     horizontal beam position          x =    -7.3444E-07 mm\n     vertical beam position            y =     2.6497E-05 mm\n     longitudinal beam position        z =      1.000     m\n     horizontal beam size          sig x =     0.4608     mm\n     vertical beam size            sig y =     0.4617     mm\n     longitudinal beam size        sig z =      2.186     mm\n     average kinetic energy            E =     0.4998     MeV\n     energy spread                    dE =     2.3442E-03 keV\n     average momentum                  P =     0.8721     MeV/c\n     transverse beam emittance     eps x =     0.1745     pi mrad mm\n     correlated divergence         cor x =     0.4603     mrad \n     transverse beam emittance     eps y =     0.1752     pi mrad mm\n     correlated divergence         cor y =     0.4600     mrad\n     longitudinal beam emittance   eps z =     5.1249E-03 pi keV mm\n     correlated energy spread      cor z =    -9.6124E-06 keV\n     emittance ratio eps y/eps x         =     0.9959    \n\n     Particle Statistics: \n\n\n     Total number of particles on stack     =       2000\n     Electrons (total)                      =       2000\n     particles at the cathode               =          0\n     active particles                       =       2000\n     passive particles (lost out of bunch)  =          0\n     probe particles                        =          6\n     backward traveling particles           =          0\n     particles lost with z&lt;Zmin             =          0\n     particles lost due to cathode field    =          0\n     particles lost on aperture             =          0\n\n     **********************************************************************\n\n     Emittance information saved to file    : astra.Xemit.001               \n     Emittance information saved to file    : astra.Yemit.001               \n     Emittance information saved to file    : astra.Zemit.001               \n     Lost &amp; found saved to file             : astra.LandF.001               \n     Phase-space distributions logged in    : astra.Log.001                 \n\n     **********************************************************************\n\n\n\n     finished simulation  Wed Aug  2 08:47:12 2023\n     elapsed time   :                 0.9 seconds \n     execution time :                 0.9 seconds \n     system time    :                 0.0 seconds\n     Goodbye.\n --------------------------------------------------------------------------\nloading 20 particle files\n[5.0, 10.0, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0, 45.0, 50.0, 55.0, 60.0, 65.0, 70.0, 75.0, 80.0, 85.0, 90.0, 95.0, 100.0]\n{'start_time': 1690991231.730855, 'run_script': '/Users/chrisonian/Code/Astra/bin/Astra astra.in', 'run_time': 0.9639010429382324}\n</pre> <p>Output is automatically parsed into a .output dict</p> In\u00a0[6]: Copied! <pre>A.output.keys()\n</pre> A.output.keys() Out[6]: <pre>dict_keys(['stats', 'particles', 'run_info', 'other'])</pre> <p>These are the statistics from Astra's Xemit style files</p> In\u00a0[7]: Copied! <pre>A.output['stats'].keys()\n</pre> A.output['stats'].keys() Out[7]: <pre>dict_keys(['mean_z', 'mean_t', 'mean_x', 'sigma_x', 'sigma_xp', 'norm_emit_x', 'cov_x__xp', 'mean_y', 'sigma_y', 'sigma_yp', 'norm_emit_y', 'cov_y__yp', 'mean_kinetic_energy', 'sigma_z', 'sigma_energy', 'norm_emit_z', 'cov_z__energy'])</pre> <p>Some simple run info:</p> In\u00a0[8]: Copied! <pre>A.output['run_info']\n</pre> A.output['run_info'] Out[8]: <pre>{'start_time': 1690991231.730855,\n 'run_script': '/Users/chrisonian/Code/Astra/bin/Astra astra.in',\n 'run_time': 0.9639010429382324}</pre> <p>Other data, such as from the LandF file, are stored in <code>other</code>:</p> In\u00a0[9]: Copied! <pre>A.output['other']\n</pre> A.output['other'] Out[9]: <pre>{'landf_z': array([0.      , 0.049975, 0.1     , 0.15    , 0.2     , 0.25    ,\n        0.3     , 0.35    , 0.4     , 0.45    , 0.5     , 0.55    ,\n        0.6     , 0.65    , 0.7     , 0.75    , 0.8     , 0.85    ,\n        0.9     , 0.95    , 1.      ]),\n 'landf_n_particles': array([2000., 2000., 2000., 2000., 2000., 2000., 2000., 2000., 2000.,\n        2000., 2000., 2000., 2000., 2000., 2000., 2000., 2000., 2000.,\n        2000., 2000., 2000.]),\n 'landf_total_charge': array([-0.e+00,  1.e-10,  1.e-10,  1.e-10,  1.e-10,  1.e-10,  1.e-10,\n         1.e-10,  1.e-10,  1.e-10,  1.e-10,  1.e-10,  1.e-10,  1.e-10,\n         1.e-10,  1.e-10,  1.e-10,  1.e-10,  1.e-10,  1.e-10,  1.e-10]),\n 'landf_n_lost': array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0.]),\n 'landf_energy_deposited': array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0.]),\n 'landf_energy_exchange': array([ 0.0000e+00,  4.4737e-05,  5.2282e-06,  1.3403e-08,  2.6912e-12,\n        -2.5530e-22, -1.4751e-21,  1.9459e-21,  1.3616e-22, -9.6446e-22,\n         4.4252e-22,  3.2905e-22,  7.6589e-22,  1.5533e-20,  0.0000e+00,\n         0.0000e+00,  0.0000e+00,  0.0000e+00,  0.0000e+00,  0.0000e+00,\n         0.0000e+00])}</pre> <p>This is the path that work was done. By default, this will be automatically cleaned up.</p> In\u00a0[10]: Copied! <pre>A.path\n</pre> A.path Out[10]: <pre>'/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpomok8c_z'</pre> In\u00a0[11]: Copied! <pre>A.plot()\n</pre> A.plot() <pre>Loading fieldmap file /Users/chrisonian/Code/GitHub/lume-astra/docs/examples/templates/dcgun/dcgun_GHV.dat\nLoading fieldmap file /Users/chrisonian/Code/GitHub/lume-astra/docs/examples/templates/dcgun/solenoid_SLA_L60.dat\n</pre> <p>This has some fancier options:</p> In\u00a0[12]: Copied! <pre>A.plot(['norm_emit_x', 'norm_emit_y'], y2='mean_kinetic_energy', xlim = (0, 1.4), figsize=(15,8) )\n</pre> A.plot(['norm_emit_x', 'norm_emit_y'], y2='mean_kinetic_energy', xlim = (0, 1.4), figsize=(15,8) ) <pre>Loading fieldmap file /Users/chrisonian/Code/GitHub/lume-astra/docs/examples/templates/dcgun/dcgun_GHV.dat\nLoading fieldmap file /Users/chrisonian/Code/GitHub/lume-astra/docs/examples/templates/dcgun/solenoid_SLA_L60.dat\n</pre> In\u00a0[13]: Copied! <pre>A.output['particles']\n</pre> A.output['particles'] Out[13]: <pre>[&lt;ParticleGroup with 1999 particles at 0x123d2fca0&gt;,\n &lt;ParticleGroup with 1999 particles at 0x123d2f490&gt;,\n &lt;ParticleGroup with 1999 particles at 0x123d2fb80&gt;,\n &lt;ParticleGroup with 1999 particles at 0x123d2fc70&gt;,\n &lt;ParticleGroup with 1999 particles at 0x123d2fc40&gt;,\n &lt;ParticleGroup with 1999 particles at 0x123d2faf0&gt;,\n &lt;ParticleGroup with 1999 particles at 0x123d2f880&gt;,\n &lt;ParticleGroup with 1999 particles at 0x123d2fe50&gt;,\n &lt;ParticleGroup with 1999 particles at 0x123d2f580&gt;,\n &lt;ParticleGroup with 1999 particles at 0x123d2f820&gt;,\n &lt;ParticleGroup with 1999 particles at 0x123d2f520&gt;,\n &lt;ParticleGroup with 1999 particles at 0x123d2ffa0&gt;,\n &lt;ParticleGroup with 1999 particles at 0x123d2fac0&gt;,\n &lt;ParticleGroup with 1999 particles at 0x123d2fa60&gt;,\n &lt;ParticleGroup with 1999 particles at 0x123d2f610&gt;,\n &lt;ParticleGroup with 1999 particles at 0x123d2f8e0&gt;,\n &lt;ParticleGroup with 1999 particles at 0x1058948e0&gt;,\n &lt;ParticleGroup with 1999 particles at 0x11e42ffd0&gt;,\n &lt;ParticleGroup with 1999 particles at 0x11e42fd30&gt;,\n &lt;ParticleGroup with 1999 particles at 0x105894880&gt;]</pre> <p>Get the last item, and request some statistic. <code>A.particles</code> points to <code>A.output['particles']</code> for convenience:</p> In\u00a0[14]: Copied! <pre>P = A.particles[-1]\nP['mean_energy']\n</pre> P = A.particles[-1] P['mean_energy'] Out[14]: <pre>1010791.4018127845</pre> <p>Show the units:</p> In\u00a0[15]: Copied! <pre>P.units('mean_energy')\n</pre> P.units('mean_energy') Out[15]: <pre>pmd_unit('eV', 1.602176634e-19, (2, 1, -2, 0, 0, 0, 0))</pre> <p>This provides easy ploting:</p> In\u00a0[16]: Copied! <pre>P.plot('z', 'x')\n</pre> P.plot('z', 'x') <p>Traces can be made by gathering the coordinate arrays:</p> In\u00a0[17]: Copied! <pre>plt.plot(\n    [P.z for P in  A.particles],\n    [P.x for P in  A.particles]\n)\nplt.plot()\n</pre> plt.plot(     [P.z for P in  A.particles],     [P.x for P in  A.particles] ) plt.plot() Out[17]: <pre>[]</pre> <p>Change something, run, and plot again:</p> In\u00a0[18]: Copied! <pre>A.input['solenoid']['maxb(1)'] = 0.04\nA.input['charge']['lspch'] =False\nA.verbose=False\nA.run()\n</pre> A.input['solenoid']['maxb(1)'] = 0.04 A.input['charge']['lspch'] =False A.verbose=False A.run() <p>Traces can be made by gathering the coordinate arrays</p> In\u00a0[19]: Copied! <pre>plt.plot(\n    [P.z for P in  A.particles],\n    [P.x for P in  A.particles]\n)\nplt.plot()\n</pre>  plt.plot(     [P.z for P in  A.particles],     [P.x for P in  A.particles] ) plt.plot() Out[19]: <pre>[]</pre> <p>Similarly a 3D plot is made:</p> In\u00a0[20]: Copied! <pre>import numpy as np\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\ncmap = matplotlib.colormaps.get_cmap('inferno')\n\nskip=1\nX = np.array([P.x for P in  A.particles]).T[::skip]\nY = np.array([P.y for P in  A.particles]).T[::skip]\nZ = np.array([P.z for P in  A.particles]).T[::skip]\n\nscale = np.hypot(X[:, 0], Y[:,0]).max()\n\n# color by  initial radius\nfor i in range(len(X)):\n    color = cmap(1-np.hypot(X[i,0], Y[i,0])/scale)\n    ax.plot(X[i]*1e6, Y[i]*1e6, Z[i], zdir='x', color=color)\n\nax.set_box_aspect((2,1,1))    \n    \nax.set_xlabel('Z (m)')\nax.set_ylabel('X (\u00b5m)')\nax.set_zlabel('Y (\u00b5m)')\n\n# plt.savefig('test.png', dpi=150)\n</pre> import numpy as np from mpl_toolkits.mplot3d import Axes3D  fig = plt.figure() ax = fig.add_subplot(111, projection='3d') cmap = matplotlib.colormaps.get_cmap('inferno')  skip=1 X = np.array([P.x for P in  A.particles]).T[::skip] Y = np.array([P.y for P in  A.particles]).T[::skip] Z = np.array([P.z for P in  A.particles]).T[::skip]  scale = np.hypot(X[:, 0], Y[:,0]).max()  # color by  initial radius for i in range(len(X)):     color = cmap(1-np.hypot(X[i,0], Y[i,0])/scale)     ax.plot(X[i]*1e6, Y[i]*1e6, Z[i], zdir='x', color=color)  ax.set_box_aspect((2,1,1))          ax.set_xlabel('Z (m)') ax.set_ylabel('X (\u00b5m)') ax.set_zlabel('Y (\u00b5m)')  # plt.savefig('test.png', dpi=150) Out[20]: <pre>Text(0.5, 0, 'Y (\u00b5m)')</pre> In\u00a0[21]: Copied! <pre>len(A.stat('norm_emit_x')), A.stat('norm_emit_x')[-1]\n</pre> len(A.stat('norm_emit_x')), A.stat('norm_emit_x')[-1] Out[21]: <pre>(999, 1.7458e-07)</pre> <p>Statistics can also be calculated directly from the particles:</p> In\u00a0[22]: Copied! <pre>A.particle_stat('norm_emit_x')\n</pre> A.particle_stat('norm_emit_x') Out[22]: <pre>array([1.81468749e-07, 1.75285393e-07, 1.75882138e-07, 1.83314665e-07,\n       2.74161838e-07, 4.91320089e-07, 3.13178319e-07, 1.89493985e-07,\n       1.76465214e-07, 1.75297891e-07, 1.75144984e-07, 1.75126206e-07,\n       1.75127277e-07, 1.75127277e-07, 1.75127277e-07, 1.75127277e-07,\n       1.75127277e-07, 1.75127277e-07, 1.75127277e-07, 1.75127277e-07])</pre> <p>Compare these:</p> In\u00a0[23]: Copied! <pre>key1 = 'mean_z'\nkey2 = 'cov_x__xp'\nunits1 = str(A.units(key1))\nunits2 = str(A.units(key2))\nplt.xlabel(key1+f' ({units1})')\nplt.ylabel(key2+f' ({units2})')\nplt.plot(A.stat(key1), A.stat(key2))\nplt.scatter(A.particle_stat(key1), A.particle_stat(key2), color='red')\n#plt.scatter(A.particle_stat(key1, alive_only=False), A.particle_stat(key2, alive_only=False), color='green')\n</pre> key1 = 'mean_z' key2 = 'cov_x__xp' units1 = str(A.units(key1)) units2 = str(A.units(key2)) plt.xlabel(key1+f' ({units1})') plt.ylabel(key2+f' ({units2})') plt.plot(A.stat(key1), A.stat(key2)) plt.scatter(A.particle_stat(key1), A.particle_stat(key2), color='red') #plt.scatter(A.particle_stat(key1, alive_only=False), A.particle_stat(key2, alive_only=False), color='green') Out[23]: <pre>&lt;matplotlib.collections.PathCollection at 0x135b5a4f0&gt;</pre> In\u00a0[24]: Copied! <pre>A.fieldmap\n</pre> A.fieldmap  Out[24]: <pre>{}</pre> In\u00a0[25]: Copied! <pre>A.verbose=True\nA.load_fieldmaps()\n</pre> A.verbose=True A.load_fieldmaps() <pre>Loading fieldmap file /Users/chrisonian/Code/GitHub/lume-astra/docs/examples/templates/dcgun/dcgun_GHV.dat\nLoading fieldmap file /Users/chrisonian/Code/GitHub/lume-astra/docs/examples/templates/dcgun/solenoid_SLA_L60.dat\n</pre> <p>A second load just referes to the internal dict.</p> In\u00a0[26]: Copied! <pre>A.load_fieldmaps()\n</pre> A.load_fieldmaps() <pre>Fieldmap inside dict: dcgun_GHV.dat\nFieldmap inside dict: solenoid_SLA_L60.dat\n</pre> <p>This will write them to <code>A.path</code>:</p> In\u00a0[27]: Copied! <pre>A.write_fieldmaps()\n</pre> A.write_fieldmaps() <pre>2 fieldmaps written to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpomok8c_z\n</pre> In\u00a0[28]: Copied! <pre>A2 = Astra(input_file=A.input_file, use_temp_dir = False )\nA2.load_output()\nA2.output.keys()\n</pre> A2 = Astra(input_file=A.input_file, use_temp_dir = False ) A2.load_output() A2.output.keys() Out[28]: <pre>dict_keys(['stats', 'particles', 'run_info', 'other'])</pre> In\u00a0[29]: Copied! <pre>H5FILE='astra.h5'\n</pre> H5FILE='astra.h5' In\u00a0[30]: Copied! <pre>A.archive(H5FILE)\n</pre> A.archive(H5FILE) <pre>Archiving to file astra.h5\n</pre> Out[30]: <pre>'astra.h5'</pre> <p>If no file is given, a filename will be invented based on the fingerprint:</p> In\u00a0[31]: Copied! <pre>H5FILE2 = A.archive()\nH5FILE2\n</pre> H5FILE2 = A.archive() H5FILE2 <pre>Archiving to file astra_748a9ef8ab7b82b51f32a520c4c1bed5.h5\n</pre> Out[31]: <pre>'astra_748a9ef8ab7b82b51f32a520c4c1bed5.h5'</pre> <p>These can be loaded into completely empty objects:</p> In\u00a0[32]: Copied! <pre>A3 = Astra.from_archive(H5FILE2)\n</pre> A3 = Astra.from_archive(H5FILE2) <p>Check that the fingerprints are the same</p> In\u00a0[33]: Copied! <pre>A3.fingerprint() == A.fingerprint()\n</pre> A3.fingerprint() == A.fingerprint() Out[33]: <pre>True</pre> <p>Spot check that the loaded data is the same as the original:</p> In\u00a0[34]: Copied! <pre>A3.stat('sigma_z')[-1] == A.stat('sigma_z')[-1]\n</pre> A3.stat('sigma_z')[-1] == A.stat('sigma_z')[-1] Out[34]: <pre>True</pre> <p>Re-configure to set up working dir and run again:</p> In\u00a0[35]: Copied! <pre>A3.configure()\nA3.run()\n</pre> A3.configure() A3.run()  <p>Check stats again:</p> In\u00a0[36]: Copied! <pre>A3.stat('sigma_z')[-1] == A.stat('sigma_z')[-1]\n</pre> A3.stat('sigma_z')[-1] == A.stat('sigma_z')[-1] Out[36]: <pre>True</pre> <p>Fieldmaps are in here, because they were loaded</p> In\u00a0[37]: Copied! <pre>A3.fieldmap.keys()\n</pre> A3.fieldmap.keys() Out[37]: <pre>dict_keys(['dcgun_GHV.dat', 'solenoid_SLA_L60.dat'])</pre> In\u00a0[38]: Copied! <pre>from h5py import File\n</pre> from h5py import File In\u00a0[39]: Copied! <pre>h5 = File(H5FILE, 'r')\n</pre> h5 = File(H5FILE, 'r') <p>Basic input and output groups are at the top level</p> In\u00a0[40]: Copied! <pre>list(h5)\n</pre> list(h5) Out[40]: <pre>['fieldmap', 'input', 'output']</pre> <p>Input corresponds to the Asta namelist inputs</p> In\u00a0[41]: Copied! <pre>list(h5['input'])\n</pre> list(h5['input']) Out[41]: <pre>['aperture',\n 'cavity',\n 'charge',\n 'fem',\n 'newrun',\n 'output',\n 'quadrupole',\n 'scan',\n 'solenoid']</pre> <p>The actual values are in attrs. Retrieve them by casting to a dict:</p> In\u00a0[42]: Copied! <pre>dict(h5['input']['newrun'].attrs)\n</pre> dict(h5['input']['newrun'].attrs) Out[42]: <pre>{'auto_phase': True,\n 'cathodes': False,\n 'distribution': '/Users/chrisonian/Code/GitHub/lume-astra/docs/examples/templates/dcgun/generator.part',\n 'emits': True,\n 'h_max': 0.002,\n 'h_min': 0.0002,\n 'head': \"'astra input file for L0 injector (20070501_1)'\",\n 'landfs': True,\n 'larmors': False,\n 'lmagnetized': True,\n 'loop': False,\n 'lproject_emit': False,\n 'phase_scan': False,\n 'phases': True,\n 'refs': False,\n 'run': 1,\n 'screen': array([1.1, 2.2]),\n 't_phases': False,\n 'tchecks': False,\n 'track_all': True,\n 'tracks': False,\n 'zemit': 1000,\n 'zphase': 20,\n 'zstart': 0,\n 'zstop': 1}</pre> <p>Output contains these datasets:</p> In\u00a0[43]: Copied! <pre>list(h5['output'])\n</pre> list(h5['output']) Out[43]: <pre>['other', 'particles', 'stats']</pre> <p>Example dataset:</p> In\u00a0[44]: Copied! <pre>h5['output']['stats']['norm_emit_x'][-1]\n</pre> h5['output']['stats']['norm_emit_x'][-1] Out[44]: <pre>1.7458e-07</pre> <p>Unit information is stored in the attributes:</p> In\u00a0[45]: Copied! <pre>dict(h5['output']['stats']['norm_emit_x'].attrs)\n</pre> dict(h5['output']['stats']['norm_emit_x'].attrs) Out[45]: <pre>{'unitDimension': array([1, 0, 0, 0, 0, 0, 0]), 'unitSI': 1, 'unitSymbol': 'm'}</pre> <p>These can be read in with the units using a helper function:</p> In\u00a0[46]: Copied! <pre>from pmd_beamphysics.units import read_dataset_and_unit_h5\n\ndat, unit = read_dataset_and_unit_h5(h5['output']['stats']['norm_emit_x'])\nunit\n</pre> from pmd_beamphysics.units import read_dataset_and_unit_h5  dat, unit = read_dataset_and_unit_h5(h5['output']['stats']['norm_emit_x']) unit Out[46]: <pre>pmd_unit('m', 1, (1, 0, 0, 0, 0, 0, 0))</pre> <p>Particles are stored in the openPMD-beamphysics standard:</p> In\u00a0[47]: Copied! <pre>list(h5['output']['particles']['0'])\n</pre> list(h5['output']['particles']['0']) Out[47]: <pre>['momentum', 'particleStatus', 'position', 'time', 'weight']</pre> <p>These can be read in as a ParticleGroup object. This is the same type of object that A.particles is kept as.</p> In\u00a0[48]: Copied! <pre>from pmd_beamphysics import ParticleGroup\nP = ParticleGroup(h5['output']['particles']['0'])\nP['norm_emit_x']\n</pre> from pmd_beamphysics import ParticleGroup P = ParticleGroup(h5['output']['particles']['0']) P['norm_emit_x'] Out[48]: <pre>1.8106484483117692e-07</pre> <p>Cleanup</p> In\u00a0[49]: Copied! <pre>import os\n\nos.remove(H5FILE)\nos.remove(H5FILE2)\n</pre>  import os  os.remove(H5FILE) os.remove(H5FILE2) In\u00a0[50]: Copied! <pre>A.input['solenoid']\n</pre> A.input['solenoid'] Out[50]: <pre>{'lbfield': True,\n 'file_bfield(1)': 'solenoid_SLA_L60.dat',\n 's_pos(1)': 0.303,\n 'maxb(1)': 0.04,\n 's_xoff(1)': 0,\n 's_yoff(1)': 0,\n 's_smooth(1)': 0,\n 's_higher_order(1)': True}</pre> In\u00a0[51]: Copied! <pre>A9 = A.copy()\nA9.add_group('CAV1', ele_names=['cavity'], attributes=['maxe(1)'], var_name='voltage', factors=[1e-6], absolute=True)\n</pre> A9 = A.copy() A9.add_group('CAV1', ele_names=['cavity'], attributes=['maxe(1)'], var_name='voltage', factors=[1e-6], absolute=True) Out[51]: <pre>ControlGroup(**{\"ele_names\": [\"cavity\"], \"var_name\": \"voltage\", \"attributes\": [\"maxe(1)\"], \"factors\": [1e-06], \"reference_values\": [-11.6], \"absolute\": true, \"value\": 0.0})</pre> In\u00a0[52]: Copied! <pre>A9.add_group('SOL1', ele_names=['solenoid'], attributes=['s_pos(1)'], var_name='offset', absolute=False)\n</pre> A9.add_group('SOL1', ele_names=['solenoid'], attributes=['s_pos(1)'], var_name='offset', absolute=False) Out[52]: <pre>ControlGroup(**{\"ele_names\": [\"solenoid\"], \"var_name\": \"offset\", \"attributes\": [\"s_pos(1)\"], \"factors\": [1.0], \"reference_values\": [0.303], \"absolute\": false, \"value\": 0.0})</pre> In\u00a0[53]: Copied! <pre>A9.group['SOL1']['offset'] =0.5\nA9.plot()\n</pre> A9.group['SOL1']['offset'] =0.5 A9.plot() In\u00a0[54]: Copied! <pre>A['solenoid']\n</pre> A['solenoid'] Out[54]: <pre>{'lbfield': True,\n 'file_bfield(1)': 'solenoid_SLA_L60.dat',\n 's_pos(1)': 0.303,\n 'maxb(1)': 0.04,\n 's_xoff(1)': 0,\n 's_yoff(1)': 0,\n 's_smooth(1)': 0,\n 's_higher_order(1)': True}</pre> <p>Get an attribute:</p> In\u00a0[55]: Copied! <pre>A['solenoid:maxb(1)']\n</pre> A['solenoid:maxb(1)'] Out[55]: <pre>0.04</pre> <p>Set an attribute, and read it back:</p> In\u00a0[56]: Copied! <pre>A['solenoid:maxb(1)'] = 1.2345\nA['solenoid:maxb(1)']\n</pre> A['solenoid:maxb(1)'] = 1.2345 A['solenoid:maxb(1)'] Out[56]: <pre>1.2345</pre> <p>Return the last item in the particles list:</p> In\u00a0[57]: Copied! <pre>A['particles:-1']\n</pre> A['particles:-1'] Out[57]: <pre>&lt;ParticleGroup with 1999 particles at 0x135a0da90&gt;</pre> <p>Calculate a statistic:</p> In\u00a0[58]: Copied! <pre>A['particles:-1']['sigma_x']\n</pre> A['particles:-1']['sigma_x'] Out[58]: <pre>0.000342383293735044</pre> <p>This does the same:</p> In\u00a0[59]: Copied! <pre>A['particles:-1:sigma_x']\n</pre> A['particles:-1:sigma_x'] Out[59]: <pre>0.000342383293735044</pre> In\u00a0[60]: Copied! <pre>?Astra\n</pre> ?Astra In\u00a0[61]: Copied! <pre>YAML=\"\"\"\n\n# Any argument above. One exception is initial_particles: this should be a filename that is parsed into a ParticleGroup\n\ninput_file: templates/dcgun/astra.in\n\nverbose: False\n\ngroup:\n  CAV1:\n    ele_names: cavity\n    var_name: voltage\n    attributes: maxe(1)\n    factors: [ 1.0e-6 ]  # V -&gt; MV for Astra\n    value: 1.234e+6\n    absolute: T\n\n  SOL1:\n    ele_names: solenoid\n    var_name: offset\n    attributes: s_pos(1)\n    value: 0.54321\n    absolute: F\n\n\n\"\"\"\n\nA8 = Astra.from_yaml(YAML)\n#A8.verbose\n</pre> YAML=\"\"\"  # Any argument above. One exception is initial_particles: this should be a filename that is parsed into a ParticleGroup  input_file: templates/dcgun/astra.in  verbose: False  group:   CAV1:     ele_names: cavity     var_name: voltage     attributes: maxe(1)     factors: [ 1.0e-6 ]  # V -&gt; MV for Astra     value: 1.234e+6     absolute: T    SOL1:     ele_names: solenoid     var_name: offset     attributes: s_pos(1)     value: 0.54321     absolute: F   \"\"\"  A8 = Astra.from_yaml(YAML) #A8.verbose <p>Check that this still works:</p> In\u00a0[62]: Copied! <pre>A8['CAV1']['voltage'] = 20e6\nA8['cavity']['maxe(1)']\n</pre> A8['CAV1']['voltage'] = 20e6 A8['cavity']['maxe(1)'] Out[62]: <pre>20.0</pre> <p>Move the solenoid around:</p> In\u00a0[63]: Copied! <pre>A8['SOL1:offset'] = 1\nA8.plot_fieldmaps()\n</pre> A8['SOL1:offset'] = 1 A8.plot_fieldmaps() In\u00a0[64]: Copied! <pre>A = Astra()\nA.track1(x0=1e-3, px0=-1e3, pz0=1e6)\n</pre> A = Astra() A.track1(x0=1e-3, px0=-1e3, pz0=1e6) <pre>Note: The following floating-point exceptions are signalling: IEEE_DIVIDE_BY_ZERO\n</pre> Out[64]: <pre>&lt;ParticleGroup with 1 particles at 0x1241bdf10&gt;</pre> In\u00a0[65]: Copied! <pre>A.plot('mean_x')\n</pre> A.plot('mean_x')"},{"location":"examples/basic_astra_examples/#lume-astra-basic-examples","title":"LUME-Astra Basic Examples\u00b6","text":""},{"location":"examples/basic_astra_examples/#plotting","title":"Plotting\u00b6","text":"<p>The Astra object has built in plotting. The defaults will plot the beam sizes as lines, data calculated from particles as dots, and the fieldmaps.</p>"},{"location":"examples/basic_astra_examples/#particles","title":"Particles\u00b6","text":"<p>Particles are automatically parsed in to openpmd-beamphysics <code>ParticleGroup</code> objects</p>"},{"location":"examples/basic_astra_examples/#stats","title":"Stats\u00b6","text":"<p>Astra computes statistics in several output tables.</p> <p>Astra's own calculated statistics can be retieved:</p>"},{"location":"examples/basic_astra_examples/#fieldmaps","title":"Fieldmaps\u00b6","text":"<p>Normally fieldmaps are not loaded into the Astra object. However, for analysis and archiving they can be loaded.</p> <p>Initially this is empty:</p>"},{"location":"examples/basic_astra_examples/#load-previously-computed-run","title":"Load previously computed run\u00b6","text":"<p>If Astra was executed manually, and the output files exist along side the input, the Astra object can load them</p>"},{"location":"examples/basic_astra_examples/#archive-all-output","title":"Archive all output\u00b6","text":"<p>All of .input and .output can be archived and loaded from standard h5 files.</p> <p>Particles are stored in the openPMD-beamphysics format.</p>"},{"location":"examples/basic_astra_examples/#reading-archived-files-manually","title":"Reading archived files manually\u00b6","text":"<p>Let's open one of these files manually using <code>h5py</code>:</p>"},{"location":"examples/basic_astra_examples/#controlgroup-objects","title":"ControlGroup objects\u00b6","text":"<p>Some elements need to be changed together, either relatively or absolutely.</p> <p>Note: this was borroed from lume-impact almost verbatim. Some of the terminology should be reworked.</p>"},{"location":"examples/basic_astra_examples/#attribute-syntax","title":"Attribute [] syntax\u00b6","text":"<p>Values of the input namelists, as well as group attributes, can be set with the bracket syntax.</p> <p>Get an entire namelist:</p>"},{"location":"examples/basic_astra_examples/#instantiate-from-yaml","title":"Instantiate from YAML\u00b6","text":"<p>All of the Astra object init arguments can be passed in a YAML file. Any of:</p>"},{"location":"examples/basic_astra_examples/#single-particle-tracking","title":"Single particle tracking\u00b6","text":"<p><code>.track1</code> is a convenience to track a sincle particle through the system.</p>"},{"location":"examples/functional_astra_run/","title":"Functional LUME-Astra","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from astra import run_astra, run_astra_with_generator\n\nimport matplotlib.pyplot as plt\nimport os\n</pre> from astra import run_astra, run_astra_with_generator  import matplotlib.pyplot as plt import os <p>Input template file and some settings</p> In\u00a0[3]: Copied! <pre>ASTRA_IN =  'templates/dcgun/astra.in'\n</pre> ASTRA_IN =  'templates/dcgun/astra.in' In\u00a0[4]: Copied! <pre>settings0 = {'zstop':1, 'zemit':200, 'zphase':1, 'phases':True}\n</pre> settings0 = {'zstop':1, 'zemit':200, 'zphase':1, 'phases':True} In\u00a0[5]: Copied! <pre>A1 = run_astra(settings0, astra_input_file=ASTRA_IN, verbose=True, timeout=100)\n</pre> A1 = run_astra(settings0, astra_input_file=ASTRA_IN, verbose=True, timeout=100) <pre>run_astra\nzstop is in astra newrun\nzstop is in astra output\nzemit is in astra newrun\nzphase is in astra newrun\nphases is in astra newrun\nloading 1 particle files\n[100.0]\n{'start_time': 1690854350.025616, 'run_script': '/Users/chrisonian/Code/Astra/bin/Astra astra.in', 'why_error': '', 'run_time': 0.7370400428771973, 'run_error': False}\n</pre> In\u00a0[6]: Copied! <pre>GENERATOR_IN = 'templates/dcgun/generator.in'\n\n\nsettings0['ipart']= 2000\n\nA2 = run_astra_with_generator(settings0, astra_input_file=ASTRA_IN,\n                              generator_input_file=GENERATOR_IN, verbose=True)\n</pre> GENERATOR_IN = 'templates/dcgun/generator.in'   settings0['ipart']= 2000  A2 = run_astra_with_generator(settings0, astra_input_file=ASTRA_IN,                               generator_input_file=GENERATOR_IN, verbose=True) <pre>run_astra_with_generator\nzstop is in astra newrun\nzstop is in astra output\nzemit is in astra newrun\nzphase is in astra newrun\nphases is in astra newrun\nipart is in generator\nset spacecharge mesh for n_particles: 2000 to {'nrad': 10, 'nlong_in': 20}\n --------------------------------------------------------------------------\n\n                              generator              \n                 Version 1.0 - macOS 64bit - Intel   \n                        DESY,  Hamburg 2002          \n                        Mon Jul 31 18:45:50 \n\n     Working File is:    generator.in                                      \n     Initializing       2000      electrons\n     including 6 probe particles at standard positions\n     Particles start from a cathode\n     Particles are quasi randomly distributed\n\n          WARNING: Values could not be reached:\n          Energy spread too high.\n                  46 times standard correction procedure\n\n\n\n     Final check:\n     Particles taken into account      N =       2000\n     total charge                      Q =    -0.1000     nC\n     horizontal beam position          x =     2.3378E-06 mm\n     vertical beam position            y =     8.9462E-06 mm\n     longitudinal beam position        z =      0.000     m\n     horizontal beam size          sig x =     0.2500     mm\n     vertical beam size            sig y =     0.2500     mm\n     longitudinal beam size        sig z =      0.000     mm\n     total emission time               t =     5.0872E-02 ns\n     rms emission time             sig t =     8.3856E-03 ns\n     average kinetic energy            E =     1.0197E-06 MeV\n     energy spread                    dE =     4.2631E-04 keV\n     average momentum                  P =     1.0208E-03 MeV/c\n     transverse beam emittance     eps x =     0.1747     pi mrad mm\n     correlated divergence         cor x =     6.8371E-03 mrad \n     transverse beam emittance     eps y =     0.1750     pi mrad mm\n     correlated divergence         cor y =    -4.4571E-03 mrad\n     longitudinal beam emittance   eps z =      0.000     pi keV mm\n     correlated energy spread      cor z =      0.000     keV\n     emittance ratio eps y/eps x         =     0.9982    \n\n     phase-space distribution saved to file: generator.part                \n\n\n     Generator ended with     1 warning(s)\n\n\nInitial particles written to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp5xjn8oto/astra.particles\nloading 1 particle files\n[100.0]\n{'start_time': 1690854350.8262599, 'run_script': '/Users/chrisonian/Code/Astra/bin/Astra astra.in', 'why_error': '', 'run_time': 0.7480919361114502, 'run_error': False}\nrun_astra_with_generator finished\n</pre> In\u00a0[7]: Copied! <pre>from astra.astra_distgen import run_astra_with_distgen\nDISTGEN_IN =  'templates/dcgun/distgen.yaml'\n\nsettings0 = {'zstop':1, 'zemit':200, 'zphase':1, 'phases':True}\nsettings0['distgen:n_particle'] = 2000\n\nA3 = run_astra_with_distgen(settings0, astra_input_file=ASTRA_IN,\n                              distgen_input_file=DISTGEN_IN, verbose=True)\n</pre> from astra.astra_distgen import run_astra_with_distgen DISTGEN_IN =  'templates/dcgun/distgen.yaml'  settings0 = {'zstop':1, 'zemit':200, 'zphase':1, 'phases':True} settings0['distgen:n_particle'] = 2000  A3 = run_astra_with_distgen(settings0, astra_input_file=ASTRA_IN,                               distgen_input_file=DISTGEN_IN, verbose=True) <pre>run_astra_with_generator\nzstop is in astra newrun\nzstop is in astra output\nzemit is in astra newrun\nzphase is in astra newrun\nphases is in astra newrun\nSetting distgen n_particle = 2000\nDistribution format: None\n   Warning: no output file specified, defaulting to \"None\".\nOutput file: None\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 100 pC.\n   Number of macroparticles: 2000.\n   Assuming cylindrical symmetry...\n   r distribution: radial uniform\n      min_r = 0 mm, max_r = 0.5 mm\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: Gaussian\n      avg_t = 0 ps, sigma_t = 8.500 ps\n      Left n_sigma_cutoff = 3, Right n_sigma_cutoff = -3\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 357.421 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 357.421 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 357.421 eV/c\n   Shifting avg_x = -0.000182722 mm -&gt; 0 mm\n   Scaling sigma_x = 0.249836 mm -&gt; 0.25 mm\n   Shifting avg_y = -5.96585E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 0.249997 mm -&gt; 0.25 mm\n   Shifting avg_px = -1.43404 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 356.94 eV/c -&gt; 357.421 eV/c\n   Shifting avg_py = -0.99808 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 356.407 eV/c -&gt; 357.421 eV/c\n   Shifting avg_pz = -2.93972 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 356.195 eV/c -&gt; 357.421 eV/c\n   Shifting avg_t = -0.0272122 ps -&gt; 0 ps\n   Scaling sigma_t = 8.36979 ps -&gt; 8.38592 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 285.455 eV/c, sigma_pz -&gt; 215.094 eV/c\n...done. Time Elapsed: 20.7162 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 2000 particles with total charge 9.999999999999999e-11 Cset spacecharge mesh for n_particles: 2000 to {'nrad': 10, 'nlong_in': 20}\nInitial particles written to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmppi727x6e/astra.particles\nloading 1 particle files\n[100.0]\n{'start_time': 1690854351.635436, 'run_script': '/Users/chrisonian/Code/Astra/bin/Astra astra.in', 'why_error': '', 'run_time': 0.7446029186248779, 'run_error': False}\n</pre> <p>These Generator and Distgen inputs are set up to produce nearly the same initial beams</p> In\u00a0[8]: Copied! <pre>plt.plot(A2.stat('sigma_x'))\nplt.plot(A3.stat('sigma_x'))\n</pre>   plt.plot(A2.stat('sigma_x')) plt.plot(A3.stat('sigma_x')) Out[8]: <pre>[&lt;matplotlib.lines.Line2D at 0x151a1e880&gt;]</pre> In\u00a0[9]: Copied! <pre>from astra.evaluate import default_astra_merit\n\ndefault_astra_merit(A2)\n</pre> from astra.evaluate import default_astra_merit  default_astra_merit(A2) Out[9]: <pre>{'error': False,\n 'end_mean_z': 1.0,\n 'end_mean_t': 4.0153e-09,\n 'end_mean_x': 6.1453e-09,\n 'end_sigma_x': 0.00046093,\n 'end_sigma_xp': 0.00051108,\n 'end_norm_emit_x': 1.7455e-07,\n 'end_cov_x__xp': 2.1221217199999998e-07,\n 'end_mean_y': 3.9381999999999995e-08,\n 'end_sigma_y': 0.00046181,\n 'end_sigma_yp': 0.0005110700000000001,\n 'end_norm_emit_y': 1.7527e-07,\n 'end_cov_y__yp': 2.125018715e-07,\n 'end_mean_kinetic_energy': 499790.0,\n 'end_sigma_z': 0.0021705,\n 'end_sigma_energy': 1.5773,\n 'end_norm_emit_z': 0.0034225,\n 'end_cov_z__energy': 7.868713650000001e-05,\n 'end_n_particle_loss': 0,\n 'end_total_charge': 9.964999999999999e-11,\n 'end_higher_order_energy_spread': 1.5777476779634658}</pre> In\u00a0[10]: Copied! <pre>from astra import evaluate_astra_with_generator\n\nMY_GENERATOR_TEMPLATE = 'templates/dcgun/generator.in'\n\nsettings0 = {'zstop':1, 'zemit':200, 'zphase':1, 'phases':True}\nsettings0['ipart'] = 2000\n\noutputs1 = evaluate_astra_with_generator(settings0, \n                                        astra_input_file=ASTRA_IN,\n                                        generator_input_file=GENERATOR_IN,\n                                        archive_path = '.')\noutputs1\n</pre>  from astra import evaluate_astra_with_generator  MY_GENERATOR_TEMPLATE = 'templates/dcgun/generator.in'  settings0 = {'zstop':1, 'zemit':200, 'zphase':1, 'phases':True} settings0['ipart'] = 2000  outputs1 = evaluate_astra_with_generator(settings0,                                          astra_input_file=ASTRA_IN,                                         generator_input_file=GENERATOR_IN,                                         archive_path = '.') outputs1 Out[10]: <pre>{'error': False,\n 'end_mean_z': 1.0,\n 'end_mean_t': 4.0153e-09,\n 'end_mean_x': 6.1453e-09,\n 'end_sigma_x': 0.00046093,\n 'end_sigma_xp': 0.00051108,\n 'end_norm_emit_x': 1.7455e-07,\n 'end_cov_x__xp': 2.1221217199999998e-07,\n 'end_mean_y': 3.9381999999999995e-08,\n 'end_sigma_y': 0.00046181,\n 'end_sigma_yp': 0.0005110700000000001,\n 'end_norm_emit_y': 1.7527e-07,\n 'end_cov_y__yp': 2.125018715e-07,\n 'end_mean_kinetic_energy': 499790.0,\n 'end_sigma_z': 0.0021705,\n 'end_sigma_energy': 1.5773,\n 'end_norm_emit_z': 0.0034225,\n 'end_cov_z__energy': 7.868713650000001e-05,\n 'end_n_particle_loss': 0,\n 'end_total_charge': 9.964999999999999e-11,\n 'end_higher_order_energy_spread': 1.5777476779634658,\n 'fingerprint': '342ec49887deb72ecbf7505f4bda8e25',\n 'archive': '/Users/chrisonian/Code/GitHub/lume-astra/docs/examples/342ec49887deb72ecbf7505f4bda8e25.h5'}</pre> <p>The archive can be loaded back:</p> In\u00a0[11]: Copied! <pre>from astra import Astra\nAX = Astra.from_archive(outputs1['archive'])\n</pre> from astra import Astra AX = Astra.from_archive(outputs1['archive'])   <p>Check the merit:</p> In\u00a0[12]: Copied! <pre>default_astra_merit(AX)\n</pre> default_astra_merit(AX) Out[12]: <pre>{'error': False,\n 'end_cov_x__xp': 2.1221217199999998e-07,\n 'end_cov_y__yp': 2.125018715e-07,\n 'end_cov_z__energy': 7.868713650000001e-05,\n 'end_mean_kinetic_energy': 499790.0,\n 'end_mean_t': 4.0153e-09,\n 'end_mean_x': 6.1453e-09,\n 'end_mean_y': 3.9381999999999995e-08,\n 'end_mean_z': 1.0,\n 'end_norm_emit_x': 1.7455e-07,\n 'end_norm_emit_y': 1.7527e-07,\n 'end_norm_emit_z': 0.0034225,\n 'end_sigma_energy': 1.5773,\n 'end_sigma_x': 0.00046093,\n 'end_sigma_xp': 0.00051108,\n 'end_sigma_y': 0.00046181,\n 'end_sigma_yp': 0.0005110700000000001,\n 'end_sigma_z': 0.0021705,\n 'end_n_particle_loss': 0,\n 'end_total_charge': 9.964999999999999e-11,\n 'end_higher_order_energy_spread': 1.5777476779634658}</pre> <p>The Generator can also be loaded from the same archive:</p> In\u00a0[13]: Copied! <pre>from astra import AstraGenerator\nG = AstraGenerator.from_archive(outputs1['archive'])\nG.input\n</pre> from astra import AstraGenerator G = AstraGenerator.from_archive(outputs1['archive']) G.input Out[13]: <pre>{'add': False,\n 'c_sig_clock': 3,\n 'c_sig_ekin': 5,\n 'c_sig_px': 5,\n 'c_sig_x': 5,\n 'c_sig_y': 5,\n 'cathode': True,\n 'cor_px': 0,\n 'cor_py': 0,\n 'dist_px': 'g',\n 'dist_py': 'g',\n 'dist_pz': 'g',\n 'dist_x': 'r',\n 'dist_y': 'r',\n 'dist_z': 'g',\n 'fname': 'generator.part',\n 'high_res': True,\n 'ipart': 2000,\n 'n_add': 0,\n 'noise_reduc': True,\n 'probe': True,\n 'q_total': 0.1,\n 'ref_clock': 0,\n 'ref_ekin': 1e-06,\n 'ref_zpos': 0,\n 'sig_clock': 0.00849257,\n 'sig_ekin': 0.0005,\n 'sig_px': 357.7,\n 'sig_py': 357.7,\n 'sig_x': 0.25,\n 'sig_y': 0.25,\n 'species': 'electrons'}</pre> In\u00a0[14]: Copied! <pre># Cleanup\nos.remove(outputs1['archive'])\n</pre> # Cleanup os.remove(outputs1['archive']) In\u00a0[15]: Copied! <pre>from astra import evaluate_astra_with_distgen\n\n?evaluate_astra_with_distgen\n</pre> from astra import evaluate_astra_with_distgen  ?evaluate_astra_with_distgen <pre>Signature:\nevaluate_astra_with_distgen(\n    settings,\n    astra_input_file=None,\n    distgen_input_file=None,\n    workdir=None,\n    astra_bin='$ASTRA_BIN',\n    timeout=2500,\n    verbose=False,\n    auto_set_spacecharge_mesh=True,\n    archive_path=None,\n    merit_f=None,\n)\nDocstring:\nSimilar to run_astra_with_distgen, but returns a flat dict of outputs as processed by merit_f. \n\nIf no merit_f is given, a default one will be used. See:\n    astra.evaluate.default_astra_merit\n\nWill raise an exception if there is an error. \nFile:      ~/Code/GitHub/lume-astra/astra/astra_distgen.py\nType:      function\n</pre> In\u00a0[16]: Copied! <pre>settings5 = {'zstop':1, 'zemit':200, 'zphase':1, 'phases':True}\nsettings5['distgen:n_particle'] = 2000\n\noutputs2 = evaluate_astra_with_distgen(settings5, astra_input_file=ASTRA_IN,\n                              distgen_input_file=DISTGEN_IN, archive_path='.')\noutputs2\n</pre>  settings5 = {'zstop':1, 'zemit':200, 'zphase':1, 'phases':True} settings5['distgen:n_particle'] = 2000  outputs2 = evaluate_astra_with_distgen(settings5, astra_input_file=ASTRA_IN,                               distgen_input_file=DISTGEN_IN, archive_path='.') outputs2 Out[16]: <pre>{'error': False,\n 'end_mean_z': 1.0,\n 'end_mean_t': 4.0156e-09,\n 'end_mean_x': 7.553300000000001e-11,\n 'end_sigma_x': 0.0004619,\n 'end_sigma_xp': 0.00051138,\n 'end_norm_emit_x': 1.7514e-07,\n 'end_cov_x__xp': 2.1275114000000003e-07,\n 'end_mean_y': -3.6688e-09,\n 'end_sigma_y': 0.00046157,\n 'end_sigma_yp': 0.00051168,\n 'end_norm_emit_y': 1.7457e-07,\n 'end_cov_y__yp': 2.12876084e-07,\n 'end_mean_kinetic_energy': 499790.0,\n 'end_sigma_z': 0.0021695000000000004,\n 'end_sigma_energy': 1.5373999999999999,\n 'end_norm_emit_z': 0.0033353,\n 'end_cov_z__energy': -2.1510375550000005e-05,\n 'end_n_particle_loss': 0,\n 'end_total_charge': 9.999999999999999e-11,\n 'end_higher_order_energy_spread': 1.5373494617932955,\n 'fingerprint': '87298760ea8c8ab1a8d95865f84b07bd',\n 'archive': '/Users/chrisonian/Code/GitHub/lume-astra/docs/examples/87298760ea8c8ab1a8d95865f84b07bd.h5'}</pre> In\u00a0[17]: Copied! <pre>from distgen import Generator\n</pre> from distgen import Generator In\u00a0[18]: Copied! <pre>G = Generator()\nG.load_archive(outputs2['archive'])\n#\n</pre> G = Generator() G.load_archive(outputs2['archive']) # In\u00a0[19]: Copied! <pre># Note that there are no particles, this is just the input. \n# Particles are \nG.particles == None\n</pre> # Note that there are no particles, this is just the input.  # Particles are  G.particles == None Out[19]: <pre>True</pre> In\u00a0[20]: Copied! <pre># This will essentially recreate evaluate_astra_with_distgen\nA = Astra(verbose=False)\n\nA.load_archive(outputs2['archive'])\n\n# Make particles\nG.run()\n\nA.initial_particles = G.particles\nA.configure()\nA.run()\ndefault_astra_merit(A)\n</pre> # This will essentially recreate evaluate_astra_with_distgen A = Astra(verbose=False)  A.load_archive(outputs2['archive'])  # Make particles G.run()  A.initial_particles = G.particles A.configure() A.run() default_astra_merit(A) <pre>No input data specified.\nRun Aborted Traceback (most recent call last):\n  File \"/Users/chrisonian/Code/GitHub/lume-astra/astra/astra.py\", line 313, in run_astra\n    self.load_output()\n  File \"/Users/chrisonian/Code/GitHub/lume-astra/astra/astra.py\", line 243, in load_output\n    assert len(nlist) == 1, f'Stat keys do not all have the same length: {[len(stats[k]) for k in stats]}'\nAssertionError: Stat keys do not all have the same length: []\n\n</pre> Out[20]: <pre>{'error': True}</pre> In\u00a0[21]: Copied! <pre># Cleanup\nos.remove(outputs2['archive'])\n</pre> # Cleanup os.remove(outputs2['archive']) In\u00a0[22]: Copied! <pre># Compare Generator, Distgen. Thee should be similar, but not exactly the same. \nfor k in outputs1:\n    print(k, outputs1[k], outputs2[k])\n</pre> # Compare Generator, Distgen. Thee should be similar, but not exactly the same.  for k in outputs1:     print(k, outputs1[k], outputs2[k]) <pre>error False False\nend_mean_z 1.0 1.0\nend_mean_t 4.0153e-09 4.0156e-09\nend_mean_x 6.1453e-09 7.553300000000001e-11\nend_sigma_x 0.00046093 0.0004619\nend_sigma_xp 0.00051108 0.00051138\nend_norm_emit_x 1.7455e-07 1.7514e-07\nend_cov_x__xp 2.1221217199999998e-07 2.1275114000000003e-07\nend_mean_y 3.9381999999999995e-08 -3.6688e-09\nend_sigma_y 0.00046181 0.00046157\nend_sigma_yp 0.0005110700000000001 0.00051168\nend_norm_emit_y 1.7527e-07 1.7457e-07\nend_cov_y__yp 2.125018715e-07 2.12876084e-07\nend_mean_kinetic_energy 499790.0 499790.0\nend_sigma_z 0.0021705 0.0021695000000000004\nend_sigma_energy 1.5773 1.5373999999999999\nend_norm_emit_z 0.0034225 0.0033353\nend_cov_z__energy 7.868713650000001e-05 -2.1510375550000005e-05\nend_n_particle_loss 0 0\nend_total_charge 9.964999999999999e-11 9.999999999999999e-11\nend_higher_order_energy_spread 1.5777476779634658 1.5373494617932955\nfingerprint 342ec49887deb72ecbf7505f4bda8e25 87298760ea8c8ab1a8d95865f84b07bd\narchive /Users/chrisonian/Code/GitHub/lume-astra/docs/examples/342ec49887deb72ecbf7505f4bda8e25.h5 /Users/chrisonian/Code/GitHub/lume-astra/docs/examples/87298760ea8c8ab1a8d95865f84b07bd.h5\n</pre>"},{"location":"examples/functional_astra_run/#functional-lume-astra","title":"Functional LUME-Astra\u00b6","text":"<p>This is the functional way to run astra and return the evaluate Astra object, or simple dict of outputs</p> <p>Settings is a list of settings that can appear in the input file.</p>"},{"location":"examples/functional_astra_run/#run-astra","title":"Run Astra\u00b6","text":""},{"location":"examples/functional_astra_run/#run-astra-with-generator","title":"Run Astra with Generator\u00b6","text":""},{"location":"examples/functional_astra_run/#run-astra-with-distgen","title":"Run Astra with Distgen\u00b6","text":""},{"location":"examples/functional_astra_run/#evaluate-functions","title":"Evaluate functions\u00b6","text":"<p>For scans an optimizations, a user often wants to run a simulation many times and examine some particular output. The package provides several <code>evaluate_</code> functions that are similar to the <code>run_</code> functions above, but apply some merit function to the output and returns that. Additionally, if an <code>archive_path</code> is provided, the <code>.archive</code> method will be called to save the complete object output</p> <p>This is the default merit function that is applied. The user can supply a different function if needed.</p>"},{"location":"examples/functional_astra_run/#evaluate_astra_with_generator","title":"evaluate_astra_with_generator\u00b6","text":"<p>An even simpler run, returns a simple dict of outputs. For use in optimization</p>"},{"location":"examples/functional_astra_run/#evaluate_astra_with_distgen","title":"evaluate_astra_with_distgen\u00b6","text":""},{"location":"examples/install_astra/","title":"Install Astra","text":"<p>Simple download functions for Astra, generator</p> In\u00a0[1]: Copied! <pre>from astra.install import install_astra, install_generator\n</pre> from astra.install import install_astra, install_generator In\u00a0[2]: Copied! <pre>astra_bin = install_astra('.', verbose=True)\n</pre> astra_bin = install_astra('.', verbose=True) <pre>Downloading http://www.desy.de/~mpyflo/Astra_for_Mac_OSX/Astra to /Users/chrisonian/Code/GitHub/lume-astra/docs/examples/Astra\nInstalled Astra in /Users/chrisonian/Code/GitHub/lume-astra/docs/examples/Astra, and set $ASTRA_BIN equal to this.\n</pre> In\u00a0[3]: Copied! <pre>generator_bin = install_generator('.', verbose=True)\n</pre> generator_bin = install_generator('.', verbose=True) <pre>Downloading http://www.desy.de/~mpyflo/Astra_for_Mac_OSX/generator to /Users/chrisonian/Code/GitHub/lume-astra/docs/examples/generator\nInstalled Astra's generator in /Users/chrisonian/Code/GitHub/lume-astra/docs/examples/generator, and set $GENERATOR_BIN equal to this.\n</pre> In\u00a0[4]: Copied! <pre># Cleanup\nimport os\nos.remove(astra_bin)\nos.remove(generator_bin)\n</pre> # Cleanup import os os.remove(astra_bin) os.remove(generator_bin) In\u00a0[5]: Copied! <pre>from astra.install import install_examples\n</pre> from astra.install import install_examples In\u00a0[6]: Copied! <pre>install_examples(\"~/astra_examples/\")\n</pre> install_examples(\"~/astra_examples/\")"},{"location":"examples/install_astra/#install-astra","title":"Install Astra\u00b6","text":""},{"location":"examples/install_astra/#install-astra-examples","title":"Install Astra Examples\u00b6","text":""},{"location":"examples/plot_examples/","title":"Plot examples","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from astra import Astra, run_astra_with_distgen\nfrom astra.plot import plot_fieldmaps, plot_stats, plot_stats_with_layout\n\nimport matplotlib\nimport matplotlib.pyplot as plt\nmatplotlib.rcParams['figure.figsize'] = (16,4)\n%config InlineBackend.figure_format = 'retina'\n%matplotlib inline\n\nimport os\n</pre> from astra import Astra, run_astra_with_distgen from astra.plot import plot_fieldmaps, plot_stats, plot_stats_with_layout  import matplotlib import matplotlib.pyplot as plt matplotlib.rcParams['figure.figsize'] = (16,4) %config InlineBackend.figure_format = 'retina' %matplotlib inline  import os In\u00a0[3]: Copied! <pre># Input template file \nASTRA_IN = 'templates/dcgun/astra.in'\n\n# Make an Astra object\nA = Astra(input_file=ASTRA_IN)\n</pre> # Input template file  ASTRA_IN = 'templates/dcgun/astra.in'  # Make an Astra object A = Astra(input_file=ASTRA_IN) In\u00a0[4]: Copied! <pre>A.plot_fieldmaps()\n</pre> A.plot_fieldmaps() In\u00a0[5]: Copied! <pre># Run Astra with Distgen\nDISTGEN_IN = 'templates/dcgun/distgen.yaml'\n\n\nsettings = {'zstop':1, 'zemit':200, 'zphase':1, 'phases':True}\nsettings['distgen:n_particle'] = 2000\n\nA2 = run_astra_with_distgen(settings=settings, astra_input_file=ASTRA_IN,\n                              distgen_input_file=DISTGEN_IN)\n</pre> # Run Astra with Distgen DISTGEN_IN = 'templates/dcgun/distgen.yaml'   settings = {'zstop':1, 'zemit':200, 'zphase':1, 'phases':True} settings['distgen:n_particle'] = 2000  A2 = run_astra_with_distgen(settings=settings, astra_input_file=ASTRA_IN,                               distgen_input_file=DISTGEN_IN) In\u00a0[6]: Copied! <pre>matplotlib.rcParams['figure.figsize'] = (16,10)\n# Modify limits\nplot_stats(A2)\n</pre> matplotlib.rcParams['figure.figsize'] = (16,10) # Modify limits plot_stats(A2) In\u00a0[7]: Copied! <pre>?plot_stats_with_layout\n</pre> ?plot_stats_with_layout In\u00a0[8]: Copied! <pre>kwargs = {'figsize':(10,5)}\n\nplot_stats_with_layout(A2, ykeys=['sigma_x', 'sigma_y'], ykeys2=['sigma_z'], \n                           xkey='mean_z', xlim=(0, 1.3), \n                           nice=True, \n                           include_layout=False,\n                           include_labels=True, \n                           include_particles=True, \n                           include_legend=True, **kwargs)\n</pre> kwargs = {'figsize':(10,5)}  plot_stats_with_layout(A2, ykeys=['sigma_x', 'sigma_y'], ykeys2=['sigma_z'],                             xkey='mean_z', xlim=(0, 1.3),                             nice=True,                             include_layout=False,                            include_labels=True,                             include_particles=True,                             include_legend=True, **kwargs) In\u00a0[9]: Copied! <pre># The convenience plottings slightly changes the keys\nA2.plot( y=['sigma_x', 'sigma_y'], y2=['sigma_z'], x='mean_z', xlim=(0,1.3), figsize=(10,5))\n</pre> # The convenience plottings slightly changes the keys A2.plot( y=['sigma_x', 'sigma_y'], y2=['sigma_z'], x='mean_z', xlim=(0,1.3), figsize=(10,5))"},{"location":"examples/plot_examples/#plot-examples","title":"Plot examples\u00b6","text":""},{"location":"examples/plot_examples/#fieldmap-plot-from-ainput","title":"Fieldmap plot from A.input\u00b6","text":""},{"location":"examples/plot_examples/#stat-plots-from-completed-run","title":"Stat plots from completed run\u00b6","text":""},{"location":"examples/plot_examples/#compact-summary-plot","title":"Compact summary plot\u00b6","text":""},{"location":"examples/scan_example/","title":"Scanning Astra evaluations","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from astra import evaluate_astra_with_distgen\n\nimport matplotlib.pyplot as plt\n\nimport numpy as np\nimport os\n</pre> from astra import evaluate_astra_with_distgen  import matplotlib.pyplot as plt  import numpy as np import os In\u00a0[3]: Copied! <pre># Input files\nASTRA_IN = 'templates/dcgun/astra.in'\nDISTGEN_IN = 'templates/dcgun/distgen.yaml'\n</pre> # Input files ASTRA_IN = 'templates/dcgun/astra.in' DISTGEN_IN = 'templates/dcgun/distgen.yaml' In\u00a0[4]: Copied! <pre># Run Astra with Distgen\n\n# Basic settings\nsettings0 = {'zstop':1, 'zemit':10, 'zphase':10, 'phases':True}\nsettings0['distgen:n_particle'] = 2000\n\n# Solenoid field\nsettings0['maxb(1)'] = 0.04\n</pre> # Run Astra with Distgen  # Basic settings settings0 = {'zstop':1, 'zemit':10, 'zphase':10, 'phases':True} settings0['distgen:n_particle'] = 2000  # Solenoid field settings0['maxb(1)'] = 0.04 In\u00a0[5]: Copied! <pre># This is the basic function we will use\noutputs = evaluate_astra_with_distgen(settings0, astra_input_file=ASTRA_IN,\n                              distgen_input_file=DISTGEN_IN)\noutputs\n</pre> # This is the basic function we will use outputs = evaluate_astra_with_distgen(settings0, astra_input_file=ASTRA_IN,                               distgen_input_file=DISTGEN_IN) outputs Out[5]: <pre>{'error': False,\n 'end_mean_z': 1.0,\n 'end_mean_t': 4.0156e-09,\n 'end_mean_x': -8.1128e-11,\n 'end_sigma_x': 0.00034241,\n 'end_sigma_xp': 0.00058502,\n 'end_norm_emit_x': 1.7516000000000001e-07,\n 'end_cov_x__xp': 1.72026784e-07,\n 'end_mean_y': 5.7747e-09,\n 'end_sigma_y': 0.00034245,\n 'end_sigma_yp': 0.0005843,\n 'end_norm_emit_y': 1.7455e-07,\n 'end_cov_y__yp': 1.7197839e-07,\n 'end_mean_kinetic_energy': 499790.0,\n 'end_sigma_z': 0.0021695000000000004,\n 'end_sigma_energy': 1.7883,\n 'end_norm_emit_z': 0.0038791,\n 'end_cov_z__energy': 7.779827000000001e-05,\n 'end_n_particle_loss': 0,\n 'end_total_charge': 9.999999999999999e-11,\n 'end_higher_order_energy_spread': 1.7879755920478746,\n 'fingerprint': 'c71d39dfb11bd6db0f35e04ba612b590'}</pre> In\u00a0[6]: Copied! <pre># Make a bare minimum function to evaluate\ndef f(b):\n    s = settings0.copy()\n    s['maxb(1)'] = b\n    return evaluate_astra_with_distgen(s, astra_input_file=ASTRA_IN,\n                          distgen_input_file=DISTGEN_IN)\n# Make a list to scan\nblist = np.linspace(0, 0.1, 20)\nf(0)\n</pre> # Make a bare minimum function to evaluate def f(b):     s = settings0.copy()     s['maxb(1)'] = b     return evaluate_astra_with_distgen(s, astra_input_file=ASTRA_IN,                           distgen_input_file=DISTGEN_IN) # Make a list to scan blist = np.linspace(0, 0.1, 20) f(0) Out[6]: <pre>{'error': False,\n 'end_mean_z': 1.0,\n 'end_mean_t': 4.0156e-09,\n 'end_mean_x': -3.6051e-09,\n 'end_sigma_x': 0.0006159000000000001,\n 'end_sigma_xp': 0.00065659,\n 'end_norm_emit_x': 1.7486999999999998e-07,\n 'end_cov_x__xp': 3.9120120300000003e-07,\n 'end_mean_y': -5.7092e-09,\n 'end_sigma_y': 0.00061615,\n 'end_sigma_yp': 0.00065711,\n 'end_norm_emit_y': 1.7486e-07,\n 'end_cov_y__yp': 3.917050395e-07,\n 'end_mean_kinetic_energy': 499790.0,\n 'end_sigma_z': 0.0021695000000000004,\n 'end_sigma_energy': 1.7883,\n 'end_norm_emit_z': 0.0038791,\n 'end_cov_z__energy': 7.776355800000001e-05,\n 'end_n_particle_loss': 0,\n 'end_total_charge': 9.999999999999999e-11,\n 'end_higher_order_energy_spread': 1.7879772256019293,\n 'fingerprint': 'f2d8e898c2ee41ce7a659b5a28b3ffb2'}</pre> In\u00a0[7]: Copied! <pre># Get a parallel executor\n\n# Processes. These lines are needed to get this to work on macOS\nimport multiprocessing as mp                                                                                     \nmp.set_start_method(\"fork\")    \nfrom concurrent.futures import ProcessPoolExecutor as Executor\n\n#from concurrent.futures import ThreadPoolExecutor as Executor # DO NOT USE\n#from dask.distributed import Client as Executor\n\nexecutor=Executor()\n</pre> # Get a parallel executor  # Processes. These lines are needed to get this to work on macOS import multiprocessing as mp                                                                                      mp.set_start_method(\"fork\")     from concurrent.futures import ProcessPoolExecutor as Executor  #from concurrent.futures import ThreadPoolExecutor as Executor # DO NOT USE #from dask.distributed import Client as Executor  executor=Executor() In\u00a0[8]: Copied! <pre># Make a map object. Note that this does not execute immediately.\nresults = executor.map(f, blist)\n</pre> # Make a map object. Note that this does not execute immediately. results = executor.map(f, blist) In\u00a0[9]: Copied! <pre># Actually evalute the funciton and gather the results\noutputs = []\nfor r in results:\n    outputs.append(r)\n#    outputs.append(r.result())\n</pre> # Actually evalute the funciton and gather the results outputs = [] for r in results:     outputs.append(r) #    outputs.append(r.result()) In\u00a0[10]: Copied! <pre># Simple plot\nplt.plot(blist, [o['end_sigma_x'] for o in outputs])\n</pre> # Simple plot plt.plot(blist, [o['end_sigma_x'] for o in outputs]) Out[10]: <pre>[&lt;matplotlib.lines.Line2D at 0x1471dc790&gt;]</pre> In\u00a0[11]: Copied! <pre>from tempfile import TemporaryDirectory\nSCRATCH=TemporaryDirectory()\n</pre> from tempfile import TemporaryDirectory SCRATCH=TemporaryDirectory() In\u00a0[12]: Copied! <pre># Make a robust evaluate\ndef evaluate(b):\n    try:\n        s = settings0.copy()\n        s['maxb(1)'] = b\n        output = evaluate_astra_with_distgen(s, astra_input_file=ASTRA_IN,\n                              distgen_input_file=DISTGEN_IN, archive_path=SCRATCH.name)\n        # Add the input\n        output['maxb(1)'] = b\n        output['Exception'] = False\n    except:\n        output = {}\n        output['maxb(1)'] = b\n        output['Exception'] = True\n        \n    return output\n</pre> # Make a robust evaluate def evaluate(b):     try:         s = settings0.copy()         s['maxb(1)'] = b         output = evaluate_astra_with_distgen(s, astra_input_file=ASTRA_IN,                               distgen_input_file=DISTGEN_IN, archive_path=SCRATCH.name)         # Add the input         output['maxb(1)'] = b         output['Exception'] = False     except:         output = {}         output['maxb(1)'] = b         output['Exception'] = True              return output In\u00a0[13]: Copied! <pre>SCRATCH.name\n</pre> SCRATCH.name Out[13]: <pre>'/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp8jg8ann9'</pre> In\u00a0[14]: Copied! <pre># This will cause a crash in Astra\nevaluate(1e9)\n</pre> # This will cause a crash in Astra evaluate(1e9) Out[14]: <pre>{'maxb(1)': 1000000000.0, 'Exception': True}</pre> In\u00a0[15]: Copied! <pre># Get a new executor\nexecutor =  Executor()\n\n# Make a map object. Note that this does not execute immediately.\n\nblist[-1] = 1e9 # Add something that will crash\nresults = executor.map(evaluate, blist)\n# Actually evalute the funciton and gather the results\noutputs = []\nfor r in results:\n    outputs.append(r)\n</pre> # Get a new executor executor =  Executor()  # Make a map object. Note that this does not execute immediately.  blist[-1] = 1e9 # Add something that will crash results = executor.map(evaluate, blist) # Actually evalute the funciton and gather the results outputs = [] for r in results:     outputs.append(r) In\u00a0[16]: Copied! <pre># Archive files are here\nos.listdir(SCRATCH.name)\n</pre> # Archive files are here os.listdir(SCRATCH.name) Out[16]: <pre>['d70364f093fe5d4a9d3acd0d0193fa91.h5',\n '284fa843911e69ab6122d23d79ad4806.h5',\n '926798389bda3d66c00620a39ddd3b8b.h5',\n 'c191147e9f05abf7a8ba60eb73fbddbd.h5',\n 'da89d10555a9b4c7b864fbb542ac497b.h5',\n '7b87b3f42160e0dc6a00aa7fa134604c.h5',\n '961dc67f12dc8c627e0a53ad04219881.h5',\n '1d54b0678b9ef6bfc42b0c2ff2120ae5.h5',\n '0a331d558139ac3a05c4cf676a8455b6.h5',\n '9a8e21bd4149448d46774270247b7c2b.h5',\n 'd6fd70f4af4f613844fd65600267f9fb.h5',\n '7c0baedf140c3dbeef2fc3a73c15ea7b.h5',\n 'dae144c959cdf177ec97e3b59f159015.h5',\n 'efffe3c12cb38f91092589b38d338d29.h5',\n 'aa14936ee8e37ca095d6d052bb7b2c04.h5',\n '47ce10b464da11518826a3c6d6654f42.h5',\n 'e6bd6c13a2d22ad150081863f1c6fb59.h5',\n '1c33e9ed18d9ff88f91eda547cfe96cd.h5',\n '3124ef1903c236f1962db3ec8dacd2fe.h5']</pre> In\u00a0[17]: Copied! <pre>import pandas as pd\n</pre> import pandas as pd In\u00a0[18]: Copied! <pre># Make a DataFrame\ndf = pd.DataFrame(outputs)\ndf\n</pre> # Make a DataFrame df = pd.DataFrame(outputs) df Out[18]: error end_mean_z end_mean_t end_mean_x end_sigma_x end_sigma_xp end_norm_emit_x end_cov_x__xp end_mean_y end_sigma_y ... end_sigma_energy end_norm_emit_z end_cov_z__energy end_n_particle_loss end_total_charge end_higher_order_energy_spread fingerprint archive maxb(1) Exception 0 False 1.0 4.015600e-09 -3.605100e-09 0.000616 0.000657 1.748700e-07 3.912012e-07 -5.709200e-09 0.000616 ... 1.7883 0.003879 0.000078 0.0 1.000000e-10 1.787977 d70364f093fe5d4a9d3acd0d0193fa91 /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 0.000000e+00 False 1 False 1.0 4.015600e-09 -2.727100e-09 0.000608 0.000647 1.749400e-07 3.799807e-07 -5.900700e-09 0.000608 ... 1.7883 0.003879 0.000078 0.0 1.000000e-10 1.787977 47ce10b464da11518826a3c6d6654f42 /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 5.263158e-03 False 2 False 1.0 4.015600e-09 -1.654600e-09 0.000584 0.000621 1.750100e-07 3.477970e-07 -5.564700e-09 0.000584 ... 1.7883 0.003879 0.000078 0.0 1.000000e-10 1.787977 284fa843911e69ab6122d23d79ad4806 /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 1.052632e-02 False 3 False 1.0 4.015600e-09 -5.596500e-10 0.000546 0.000581 1.750700e-07 2.999282e-07 -4.652900e-09 0.000545 ... 1.7883 0.003879 0.000078 0.0 1.000000e-10 1.787977 d6fd70f4af4f613844fd65600267f9fb /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 1.578947e-02 False 4 False 1.0 4.015600e-09 3.749800e-10 0.000496 0.000535 1.751200e-07 2.448360e-07 -3.170800e-09 0.000495 ... 1.7883 0.003879 0.000078 0.0 1.000000e-10 1.787976 da89d10555a9b4c7b864fbb542ac497b /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 2.105263e-02 False 5 False 1.0 4.015600e-09 9.793000e-10 0.000439 0.000499 1.751500e-07 1.935768e-07 -1.156600e-09 0.000439 ... 1.7883 0.003879 0.000078 0.0 1.000000e-10 1.787976 7c0baedf140c3dbeef2fc3a73c15ea7b /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 2.631579e-02 False 6 False 1.0 4.015600e-09 1.098900e-09 0.000384 0.000492 1.751700e-07 1.589409e-07 1.296300e-09 0.000384 ... 1.7883 0.003879 0.000078 0.0 1.000000e-10 1.787976 7b87b3f42160e0dc6a00aa7fa134604c /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 3.157895e-02 False 7 False 1.0 4.015600e-09 5.689600e-10 0.000347 0.000534 1.751700e-07 1.545434e-07 4.052900e-09 0.000347 ... 1.7883 0.003879 0.000078 0.0 1.000000e-10 1.787976 dae144c959cdf177ec97e3b59f159015 /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 3.684211e-02 False 8 False 1.0 4.015600e-09 -6.653800e-10 0.000349 0.000629 1.751500e-07 1.937603e-07 6.928300e-09 0.000349 ... 1.7883 0.003879 0.000078 0.0 1.000000e-10 1.787976 aa14936ee8e37ca095d6d052bb7b2c04 /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 4.210526e-02 False 9 False 1.0 4.015600e-09 -2.662300e-09 0.000399 0.000768 1.751300e-07 2.886720e-07 9.753800e-09 0.000399 ... 1.7883 0.003879 0.000078 0.0 1.000000e-10 1.787976 efffe3c12cb38f91092589b38d338d29 /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 4.736842e-02 False 10 False 1.0 4.015600e-09 -5.442600e-09 0.000491 0.000938 1.751000e-07 4.490753e-07 1.230300e-08 0.000490 ... 1.7883 0.003879 0.000078 0.0 1.000000e-10 1.787976 926798389bda3d66c00620a39ddd3b8b /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 5.263158e-02 False 11 False 1.0 4.015600e-09 -8.943500e-09 0.000610 0.001129 1.750800e-07 6.815942e-07 1.438200e-08 0.000610 ... 1.7883 0.003879 0.000078 0.0 1.000000e-10 1.787976 1d54b0678b9ef6bfc42b0c2ff2120ae5 /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 5.789474e-02 False 12 False 1.0 4.015600e-09 -1.305700e-08 0.000746 0.001333 1.750700e-07 9.890153e-07 1.580400e-08 0.000746 ... 1.7883 0.003879 0.000078 0.0 1.000000e-10 1.787976 0a331d558139ac3a05c4cf676a8455b6 /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 6.315789e-02 False 13 False 1.0 4.015600e-09 -1.761700e-08 0.000890 0.001543 1.751000e-07 1.369874e-06 1.640300e-08 0.000891 ... 1.7883 0.003879 0.000078 0.0 1.000000e-10 1.787976 e6bd6c13a2d22ad150081863f1c6fb59 /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 6.842105e-02 False 14 False 1.0 4.015600e-09 -2.254200e-08 0.001038 0.001754 1.751800e-07 1.818200e-06 1.601500e-08 0.001040 ... 1.7883 0.003879 0.000078 0.0 1.000000e-10 1.787977 3124ef1903c236f1962db3ec8dacd2fe /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 7.368421e-02 False 15 False 1.0 4.015600e-09 -2.742500e-08 0.001186 0.001962 1.753100e-07 2.323812e-06 1.459800e-08 0.001189 ... 1.7883 0.003879 0.000077 0.0 1.000000e-10 1.787978 961dc67f12dc8c627e0a53ad04219881 /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 7.894737e-02 False 16 False 1.0 4.015600e-09 -3.215500e-08 0.001330 0.002161 1.755100e-07 2.871803e-06 1.223600e-08 0.001334 ... 1.7883 0.003879 0.000077 0.0 1.000000e-10 1.787978 9a8e21bd4149448d46774270247b7c2b /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 8.421053e-02 False 17 False 1.0 4.015600e-09 -3.645000e-08 0.001467 0.002349 1.757800e-07 3.444868e-06 8.855100e-09 0.001472 ... 1.7883 0.003879 0.000077 0.0 1.000000e-10 1.787979 c191147e9f05abf7a8ba60eb73fbddbd /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 8.947368e-02 False 18 False 1.0 4.015600e-09 -4.010700e-08 0.001595 0.002522 1.761000e-07 4.022045e-06 4.511600e-09 0.001601 ... 1.7883 0.003879 0.000077 0.0 1.000000e-10 1.787980 1c33e9ed18d9ff88f91eda547cfe96cd /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn... 9.473684e-02 False 19 NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN 1.000000e+09 True <p>20 rows \u00d7 25 columns</p> In\u00a0[19]: Copied! <pre># Get all runs without an exeption\nfiltered_df=df[~df['Exception']]\n</pre> # Get all runs without an exeption filtered_df=df[~df['Exception']] In\u00a0[20]: Copied! <pre>from bokeh.plotting import figure, output_notebook, show\n\nfrom bokeh.models import ColumnDataSource\n\n# Allows plots to show up in the notebook\noutput_notebook()\n</pre> from bokeh.plotting import figure, output_notebook, show  from bokeh.models import ColumnDataSource  # Allows plots to show up in the notebook output_notebook() Loading BokehJS ... In\u00a0[21]: Copied! <pre># Form a Bokeh style data source\nsource = ColumnDataSource(filtered_df)\nsource.column_names\n</pre> # Form a Bokeh style data source source = ColumnDataSource(filtered_df) source.column_names Out[21]: <pre>['index',\n 'error',\n 'end_mean_z',\n 'end_mean_t',\n 'end_mean_x',\n 'end_sigma_x',\n 'end_sigma_xp',\n 'end_norm_emit_x',\n 'end_cov_x__xp',\n 'end_mean_y',\n 'end_sigma_y',\n 'end_sigma_yp',\n 'end_norm_emit_y',\n 'end_cov_y__yp',\n 'end_mean_kinetic_energy',\n 'end_sigma_z',\n 'end_sigma_energy',\n 'end_norm_emit_z',\n 'end_cov_z__energy',\n 'end_n_particle_loss',\n 'end_total_charge',\n 'end_higher_order_energy_spread',\n 'fingerprint',\n 'archive',\n 'maxb(1)',\n 'Exception']</pre> In\u00a0[22]: Copied! <pre># A simple plot\np = figure()\np.circle(x='maxb(1)', y='end_sigma_x', source=source)\nshow(p)\n</pre> # A simple plot p = figure() p.circle(x='maxb(1)', y='end_sigma_x', source=source) show(p) In\u00a0[23]: Copied! <pre># Fancier plot\n\nfrom bokeh.models.tools import HoverTool\n\nhover = HoverTool()\n\n\nhover.tooltips=[\n    ('sigma_x', '@end_sigma_x'),\n    ('norm_emit_x', '@end_norm_emit_x'),\n    ('archive', '@archive')\n]\np = figure(tools='tap')\np.circle(x='maxb(1)', y='end_sigma_x', source=source, size=10, color='green')\n\np.add_tools(hover)\n\nshow(p)\n</pre> # Fancier plot  from bokeh.models.tools import HoverTool  hover = HoverTool()   hover.tooltips=[     ('sigma_x', '@end_sigma_x'),     ('norm_emit_x', '@end_norm_emit_x'),     ('archive', '@archive') ] p = figure(tools='tap') p.circle(x='maxb(1)', y='end_sigma_x', source=source, size=10, color='green')  p.add_tools(hover)  show(p) In\u00a0[24]: Copied! <pre># Load all archives\nfrom astra import Astra\nAlist = []\nfor a in filtered_df['archive']:\n    A = Astra()\n    A.load_archive(a)\n    Alist.append(A)\n</pre> # Load all archives from astra import Astra Alist = [] for a in filtered_df['archive']:     A = Astra()     A.load_archive(a)     Alist.append(A) In\u00a0[25]: Copied! <pre>plt.plot(\n    Alist[0].output['stats']['mean_z'],\n    Alist[0].output['stats']['sigma_x']\n)\n</pre> plt.plot(     Alist[0].output['stats']['mean_z'],     Alist[0].output['stats']['sigma_x'] ) Out[25]: <pre>[&lt;matplotlib.lines.Line2D at 0x15774f4f0&gt;]</pre>"},{"location":"examples/scan_example/#scanning-astra-evaluations","title":"Scanning Astra evaluations\u00b6","text":""},{"location":"examples/scan_example/#better-robust-evaluation-form-dataset","title":"Better: robust evaluation, form dataset\u00b6","text":""},{"location":"examples/scan_example/#pandas","title":"Pandas\u00b6","text":""},{"location":"examples/scan_example/#visualize-with-bokeh","title":"Visualize with Bokeh\u00b6","text":""},{"location":"examples/simple_distgen_example/","title":"Distgen Generator","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from distgen import Generator\nfrom astra import Astra\nfrom pmd_beamphysics import ParticleGroup\nfrom pmd_beamphysics.plot import marginal_plot\nimport os\n</pre> from distgen import Generator from astra import Astra from pmd_beamphysics import ParticleGroup from pmd_beamphysics.plot import marginal_plot import os In\u00a0[3]: Copied! <pre># Get an input file\ndistgen_in = 'templates/dcgun/distgen.yaml'\n</pre> # Get an input file distgen_in = 'templates/dcgun/distgen.yaml' In\u00a0[4]: Copied! <pre># Make object, and show its input (calls __repr__)\nD = Generator(distgen_in, verbose=True)\n\n# Change something\nD.input['n_particle'] = 10000\n\nD\n</pre> # Make object, and show its input (calls __repr__) D = Generator(distgen_in, verbose=True)  # Change something D.input['n_particle'] = 10000  D Out[4]: <pre>&lt;disgten.Generator with input: \nn_particle: 100000\noutput:\n  type: null\nr_dist:\n  max_r:\n    units: millimeter\n    value: 0.5\n  type: radial_uniform\nrandom_type: hammersley\nstart:\n  MTE:\n    units: millielectron_volt\n    value: 250.0\n  type: cathode\nt_dist:\n  avg_t:\n    units: picosecond\n    value: 0.0\n  n_sigma_cutoff: 3\n  sigma_t:\n    units: picosecond\n    value: 8.5\n  type: gaussian\ntotal_charge:\n  units: picocoulomb\n  value: 100.0\ntransforms: null\n\n&gt;</pre> In\u00a0[5]: Copied! <pre># Run, and get particles\nD.run()\nP = D.particles\nP.status\n</pre> # Run, and get particles D.run() P = D.particles P.status <pre>Distribution format: None\n   Warning: no output file specified, defaulting to \"None\".\nOutput file: None\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 100 pC.\n   Number of macroparticles: 100000.\n   Assuming cylindrical symmetry...\n   r distribution: radial uniform\n      min_r = 0 mm, max_r = 0.5 mm\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: Gaussian\n      avg_t = 0 ps, sigma_t = 8.500 ps\n      Left n_sigma_cutoff = 3, Right n_sigma_cutoff = -3\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 357.421 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 357.421 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 357.421 eV/c\n   Shifting avg_x = -9.79286E-06 mm -&gt; 0 mm\n   Scaling sigma_x = 0.249992 mm -&gt; 0.25 mm\n   Shifting avg_y = -9.80995E-07 mm -&gt; 0 mm\n   Scaling sigma_y = 0.249999 mm -&gt; 0.25 mm\n   Shifting avg_px = -0.0489346 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 357.414 eV/c -&gt; 357.421 eV/c\n   Shifting avg_py = -0.0564188 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 357.379 eV/c -&gt; 357.421 eV/c\n   Shifting avg_pz = -0.0878522 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 357.382 eV/c -&gt; 357.421 eV/c\n   Shifting avg_t = -0.00102613 ps -&gt; 0 ps\n   Scaling sigma_t = 8.38575 ps -&gt; 8.38592 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 285.197 eV/c, sigma_pz -&gt; 215.435 eV/c\n...done. Time Elapsed: 373.021 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 100000 particles with total charge 1.0000000000000003e-10 C</pre> Out[5]: <pre>array([0, 0, 0, ..., 0, 0, 0])</pre> In\u00a0[6]: Copied! <pre># Check stats from ParticleGroup's calculation\nfor x in ['x', 'y', 't', 'px', 'py', 'pz']:\n    k = 'sigma_'+x\n    print(k, ':', P[k], P.units(k))\n</pre> # Check stats from ParticleGroup's calculation for x in ['x', 'y', 't', 'px', 'py', 'pz']:     k = 'sigma_'+x     print(k, ':', P[k], P.units(k)) <pre>sigma_x : 0.00025 m\nsigma_y : 0.00025000000000000006 m\nsigma_t : 8.385916336743921e-12 s\nsigma_px : 357.42095279935677 eV/c\nsigma_py : 357.4209527993567 eV/c\nsigma_pz : 215.43483657497615 eV/c\n</pre> In\u00a0[7]: Copied! <pre>for x in ['x', 'y', 't', 'px', 'py', 'pz']:\n    k1 = 'min_'+x\n    k2 = 'max_'+x\n    print(k1, ':', P[k1], P.units(k1))\n    print(k2, ':', P[k2], P.units(k2))\n</pre> for x in ['x', 'y', 't', 'px', 'py', 'pz']:     k1 = 'min_'+x     k2 = 'max_'+x     print(k1, ':', P[k1], P.units(k1))     print(k2, ':', P[k2], P.units(k2)) <pre>min_x : -0.0004997475302364819 m\nmax_x : 0.0004996360981421189 m\nmin_y : -0.0004997069647996915 m\nmax_y : 0.0004997923268076736 m\nmin_t : -2.548869924080168e-11 s\nmax_t : 2.5469319141097204e-11 s\nmin_px : -1629.753693583419 eV/c\nmax_px : 1504.621099189629 eV/c\nmin_py : -1537.404841982019 eV/c\nmax_py : 1448.1372913221817 eV/c\nmin_pz : 0.0016263845082297446 eV/c\nmax_pz : 1562.0505583752838 eV/c\n</pre> In\u00a0[8]: Copied! <pre># Input template file \nASTRA_IN = 'templates/dcgun/astra.in'\n</pre> # Input template file  ASTRA_IN = 'templates/dcgun/astra.in' In\u00a0[9]: Copied! <pre># Make an Astra object\nA = Astra(input_file=ASTRA_IN, initial_particles=P)\n\n# Change some inputs\nA.input['newrun']['zemit']  = 1000\nA.input['newrun']['zphase'] = 20\nA.input['newrun']['phases'] = True\nA.input['newrun']['zstop']  = 1\n\n# Special flag\nA.verbose = False\n</pre> # Make an Astra object A = Astra(input_file=ASTRA_IN, initial_particles=P)  # Change some inputs A.input['newrun']['zemit']  = 1000 A.input['newrun']['zphase'] = 20 A.input['newrun']['phases'] = True A.input['newrun']['zstop']  = 1  # Special flag A.verbose = False In\u00a0[10]: Copied! <pre>A.run()\n</pre> A.run() In\u00a0[11]: Copied! <pre>import matplotlib\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\nmatplotlib.rcParams['figure.figsize'] = (8,5)\n</pre> import matplotlib import matplotlib.pyplot as plt  %matplotlib inline %config InlineBackend.figure_format = 'retina' matplotlib.rcParams['figure.figsize'] = (8,5) In\u00a0[12]: Copied! <pre>plt.plot(A.stat('mean_z'), A.stat('sigma_x'))\nplt.scatter(A.particle_stat('mean_z'), A.particle_stat('sigma_x'))\n</pre> plt.plot(A.stat('mean_z'), A.stat('sigma_x')) plt.scatter(A.particle_stat('mean_z'), A.particle_stat('sigma_x')) Out[12]: <pre>&lt;matplotlib.collections.PathCollection at 0x1520c4fa0&gt;</pre> In\u00a0[13]: Copied! <pre>from astra import AstraGenerator\n</pre> from astra import AstraGenerator In\u00a0[14]: Copied! <pre>GENERATOR_IN = 'templates/dcgun/generator.in'\n# Make generator object\nG = AstraGenerator(input_file=GENERATOR_IN)\nG.input['ipart'] = 10000\nG.run()\nP2 = G.output['particles']\n</pre> GENERATOR_IN = 'templates/dcgun/generator.in' # Make generator object G = AstraGenerator(input_file=GENERATOR_IN) G.input['ipart'] = 10000 G.run() P2 = G.output['particles'] In\u00a0[15]: Copied! <pre>A2 = Astra(input_file=ASTRA_IN, initial_particles=P2)\n\n# Change some inputs\nA2.input['newrun']['zemit']  = 1000\nA2.input['newrun']['zphase'] = 20\nA2.input['newrun']['phases'] = True\nA2.input['newrun']['zstop']  = 1\nA2.run()\n</pre> A2 = Astra(input_file=ASTRA_IN, initial_particles=P2)  # Change some inputs A2.input['newrun']['zemit']  = 1000 A2.input['newrun']['zphase'] = 20 A2.input['newrun']['phases'] = True A2.input['newrun']['zstop']  = 1 A2.run() In\u00a0[16]: Copied! <pre>k1 = 'mean_z'\nk2 = 'norm_emit_x'\n\nu1 = A.units(k1)\nu2 = A.units(k2)\nplt.xlabel(k1+f' ({u1})')\nplt.ylabel(k2+f' ({u2})')\nplt.yscale('log')\nplt.plot(A.stat(k1), A.stat(k2), color='red', label='distgen')\nplt.plot(A2.stat(k1), A2.stat(k2), color='green', label='generator')\nplt.scatter(A.particle_stat(k1), A.particle_stat(k2), color='red', label='distgen'),\nplt.scatter(A2.particle_stat(k1), A2.particle_stat(k2), color='green', marker='x', label='generator')\nplt.legend()\n</pre> k1 = 'mean_z' k2 = 'norm_emit_x'  u1 = A.units(k1) u2 = A.units(k2) plt.xlabel(k1+f' ({u1})') plt.ylabel(k2+f' ({u2})') plt.yscale('log') plt.plot(A.stat(k1), A.stat(k2), color='red', label='distgen') plt.plot(A2.stat(k1), A2.stat(k2), color='green', label='generator') plt.scatter(A.particle_stat(k1), A.particle_stat(k2), color='red', label='distgen'), plt.scatter(A2.particle_stat(k1), A2.particle_stat(k2), color='green', marker='x', label='generator') plt.legend() Out[16]: <pre>&lt;matplotlib.legend.Legend at 0x152203fd0&gt;</pre> In\u00a0[17]: Copied! <pre># distgen\nA.initial_particles.plot('x', 'y', bins=80)\n</pre> # distgen A.initial_particles.plot('x', 'y', bins=80) In\u00a0[18]: Copied! <pre># Generator\nA2.initial_particles.plot('x', 'y', bins=80)\n</pre> # Generator A2.initial_particles.plot('x', 'y', bins=80) In\u00a0[19]: Copied! <pre># Distgen initial particles in time, z-momentum\nA.initial_particles.plot( 't', 'pz', bins=200)\n</pre> # Distgen initial particles in time, z-momentum A.initial_particles.plot( 't', 'pz', bins=200) In\u00a0[20]: Copied! <pre># Generator initial particles in time, z-momentum\n# The spike at pz=0 is a known limitation\nA2.initial_particles.plot('t', 'pz', bins=200)\n</pre> # Generator initial particles in time, z-momentum # The spike at pz=0 is a known limitation A2.initial_particles.plot('t', 'pz', bins=200)"},{"location":"examples/simple_distgen_example/#distgen-generator","title":"Distgen Generator\u00b6","text":"<p>Particle generation</p>"},{"location":"examples/simple_distgen_example/#run-astra-with-distgen","title":"Run Astra with Distgen\u00b6","text":""},{"location":"examples/simple_distgen_example/#plot","title":"Plot\u00b6","text":""},{"location":"examples/simple_distgen_example/#compare-with-astragenerator","title":"Compare with AstraGenerator\u00b6","text":""},{"location":"examples/simple_generator_example/","title":"Astra Generator","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from astra import AstraGenerator\nimport os\n</pre> from astra import AstraGenerator import os <p>Point to template input file:</p> In\u00a0[3]: Copied! <pre>GENERATOR_IN = 'templates/dcgun/generator.in'\n</pre> GENERATOR_IN = 'templates/dcgun/generator.in' <p>Make generator object:</p> In\u00a0[4]: Copied! <pre>G = AstraGenerator(input_file=GENERATOR_IN)\nG.input\n</pre> G = AstraGenerator(input_file=GENERATOR_IN) G.input Out[4]: <pre>{'fname': 'generator.part',\n 'add': False,\n 'n_add': 0,\n 'ipart': 2000,\n 'species': 'electrons',\n 'probe': True,\n 'noise_reduc': True,\n 'cathode': True,\n 'q_total': 0.1,\n 'ref_zpos': 0,\n 'ref_clock': 0,\n 'ref_ekin': 1e-06,\n 'high_res': True,\n 'dist_x': 'r',\n 'sig_x': 0.25,\n 'c_sig_x': 5,\n 'dist_px': 'g',\n 'sig_px': 357.7,\n 'c_sig_px': 5,\n 'cor_px': 0,\n 'dist_y': 'r',\n 'sig_y': 0.25,\n 'c_sig_y': 5,\n 'dist_py': 'g',\n 'sig_py': 357.7,\n 'cor_py': 0,\n 'dist_z': 'g',\n 'sig_clock': 0.00849257,\n 'c_sig_clock': 3,\n 'dist_pz': 'g',\n 'sig_ekin': 0.0005,\n 'c_sig_ekin': 5}</pre> <p>Look at its input:</p> In\u00a0[5]: Copied! <pre>G.input\n</pre> G.input Out[5]: <pre>{'fname': 'generator.part',\n 'add': False,\n 'n_add': 0,\n 'ipart': 2000,\n 'species': 'electrons',\n 'probe': True,\n 'noise_reduc': True,\n 'cathode': True,\n 'q_total': 0.1,\n 'ref_zpos': 0,\n 'ref_clock': 0,\n 'ref_ekin': 1e-06,\n 'high_res': True,\n 'dist_x': 'r',\n 'sig_x': 0.25,\n 'c_sig_x': 5,\n 'dist_px': 'g',\n 'sig_px': 357.7,\n 'c_sig_px': 5,\n 'cor_px': 0,\n 'dist_y': 'r',\n 'sig_y': 0.25,\n 'c_sig_y': 5,\n 'dist_py': 'g',\n 'sig_py': 357.7,\n 'cor_py': 0,\n 'dist_z': 'g',\n 'sig_clock': 0.00849257,\n 'c_sig_clock': 3,\n 'dist_pz': 'g',\n 'sig_ekin': 0.0005,\n 'c_sig_ekin': 5}</pre> <p>Change some input:</p> In\u00a0[6]: Copied! <pre>G.input['ipart']= 999\n</pre> G.input['ipart']= 999 <p>Run:</p> In\u00a0[7]: Copied! <pre>G.verbose=True\nG.run()\n</pre> G.verbose=True G.run() <pre> --------------------------------------------------------------------------\n\n                              generator              \n                 Version 1.0 - macOS 64bit - Intel   \n                        DESY,  Hamburg 2002          \n                        Wed Aug  2 08:48:37 \n\n     Working File is:    generator.in                                      \n     Initializing        999      electrons\n     including 6 probe particles at standard positions\n     Particles start from a cathode\n     Particles are quasi randomly distributed\n\n          WARNING: Values could not be reached:\n          Energy spread too high.\n                  23 times standard correction procedure\n\n\n\n     Final check:\n     Particles taken into account      N =        999\n     total charge                      Q =    -0.1000     nC\n     horizontal beam position          x =    -7.8510E-07 mm\n     vertical beam position            y =     6.2144E-06 mm\n     longitudinal beam position        z =      0.000     m\n     horizontal beam size          sig x =     0.2500     mm\n     vertical beam size            sig y =     0.2500     mm\n     longitudinal beam size        sig z =      0.000     mm\n     total emission time               t =     5.0872E-02 ns\n     rms emission time             sig t =     8.4198E-03 ns\n     average kinetic energy            E =     1.0189E-06 MeV\n     energy spread                    dE =     4.2521E-04 keV\n     average momentum                  P =     1.0205E-03 MeV/c\n     transverse beam emittance     eps x =     0.1736     pi mrad mm\n     correlated divergence         cor x =     4.4093E-02 mrad \n     transverse beam emittance     eps y =     0.1750     pi mrad mm\n     correlated divergence         cor y =     1.9513E-03 mrad\n     longitudinal beam emittance   eps z =      0.000     pi keV mm\n     correlated energy spread      cor z =      0.000     keV\n     emittance ratio eps y/eps x         =     0.9922    \n\n     phase-space distribution saved to file: generator.part                \n\n\n     Generator ended with     1 warning(s)\n\n\n</pre> <p>Output is parsed as a <code>ParticleGroup</code>:</p> In\u00a0[8]: Copied! <pre>P = G.output['particles']\n</pre> P = G.output['particles'] In\u00a0[9]: Copied! <pre>P.plot('x', 'y', figsize=(6,6))\n</pre> P.plot('x', 'y', figsize=(6,6)) In\u00a0[10]: Copied! <pre>P.plot('t', 'pz', figsize=(6,6))\n</pre> P.plot('t', 'pz', figsize=(6,6)) <p>The input can be archived:</p> In\u00a0[11]: Copied! <pre>afile = G.archive()\n</pre> afile = G.archive() <pre>Archiving to file astra_generator_3edf607ef3e76f2846cd471aed6be637.h5\n</pre> In\u00a0[12]: Copied! <pre>G2 = AstraGenerator.from_archive(afile)\n</pre> G2 = AstraGenerator.from_archive(afile) <p>Check that the fingerprint is the same:</p> In\u00a0[13]: Copied! <pre>G2.fingerprint() == G.fingerprint()\n</pre> G2.fingerprint() == G.fingerprint() Out[13]: <pre>True</pre>"},{"location":"examples/simple_generator_example/#astra-generator","title":"Astra Generator\u00b6","text":"<p>Particle generation</p>"},{"location":"examples/elements/apex_gun/","title":"APEX Gun","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\nimport matplotlib\nmatplotlib.rcParams['figure.figsize'] = (13,8)\n%config InlineBackend.figure_format = 'retina'\n</pre> import matplotlib.pyplot as plt import matplotlib matplotlib.rcParams['figure.figsize'] = (13,8) %config InlineBackend.figure_format = 'retina' In\u00a0[3]: Copied! <pre>from astra import Astra\nfrom astra import recommended_spacecharge_mesh\nfrom distgen import Generator\n\nimport matplotlib.pyplot as plt\nimport os\n</pre> from astra import Astra from astra import recommended_spacecharge_mesh from distgen import Generator  import matplotlib.pyplot as plt import os In\u00a0[4]: Copied! <pre># Input template file \nASTRA_IN = '../templates/apex_gun/astra.in'\nDISTGEN_IN = '../templates/apex_gun/distgen.yaml'\n</pre> # Input template file  ASTRA_IN = '../templates/apex_gun/astra.in' DISTGEN_IN = '../templates/apex_gun/distgen.yaml' In\u00a0[5]: Copied! <pre>recommended_spacecharge_mesh(10000)\n</pre> recommended_spacecharge_mesh(10000) Out[5]: <pre>{'nrad': 20, 'nlong_in': 43}</pre> In\u00a0[6]: Copied! <pre>G = Generator(DISTGEN_IN)\nG['n_particle'] = 10000\n\nG.run()\nP0 = G.particles\nP0.status[:] = -1 # Cathode start\n#factor = 2\n#P0.x *= factor  \n#P0.y *= 1/factor \nP0.plot('x', 'y')\n</pre> G = Generator(DISTGEN_IN) G['n_particle'] = 10000  G.run() P0 = G.particles P0.status[:] = -1 # Cathode start #factor = 2 #P0.x *= factor   #P0.y *= 1/factor  P0.plot('x', 'y') In\u00a0[7]: Copied! <pre># Make an Astra object\nA = Astra(input_file=ASTRA_IN, initial_particles=P0, verbose=True)\nsc_settings = recommended_spacecharge_mesh(P0['n_particle'])\nA.input['charge'].update()\n\nA.input['output']['zstop'] = 0.15\n\nA.input['charge']['lspch'] = True\n\nA.input['charge']['lspch3d'] = False\n</pre> # Make an Astra object A = Astra(input_file=ASTRA_IN, initial_particles=P0, verbose=True) sc_settings = recommended_spacecharge_mesh(P0['n_particle']) A.input['charge'].update()  A.input['output']['zstop'] = 0.15  A.input['charge']['lspch'] = True  A.input['charge']['lspch3d'] = False <pre>Configured to run in: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpkvgt3vpc\n</pre> In\u00a0[8]: Copied! <pre>%%time\n# Run\nA.run()\n</pre> %%time # Run A.run() <pre>Initial particles written to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpkvgt3vpc/astra.particles\n --------------------------------------------------------------------------\n\n                Astra- A space charge tracking algorithm \n               Version 4.0 - macOS 64bit - Apple Silicon   \n                        DESY,  Hamburg 2022          \n                        Wed Aug  2 08:49:09 \n\n     Parameter file is:  astra.in                                          \n     APEX Gun                                                                        \n\n Initialize element settings:\n --------------------------------------------------------------------------\n Cavity:\n\n     Reading cavity field data from:      187MHz_HighDef_March2010.dat                                                    \n     field smoothing is applied\n     Cavity Frequency               f =   0.1870     GHz\n     maximum gradient                      20.00     MV/m\n     at                                    0.000     m\n     estimated average gradient            2.667     MV/m\n     nominal phase                         0.000     deg\n\n --------------------------------------------------------------------------\n Solenoid:\n\n     Reading solenoid field data from:    realbucking.dat                                                                 \n     field smoothing is applied\n     maximum |Bz| field                     0.000     T\n     at                                   -6.2050E-02 m\n     integral Bz squared                    0.000     T^2m\n\n     Reading solenoid field data from:    newSOL.dat                                                                      \n     field smoothing is applied\n     maximum |Bz| field                    5.7000E-02 T\n     at                                    0.2465     m\n     integral Bz squared                   2.8019E-04 T^2m\n\n     solenoids number:   1 and   2 overlap\n --------------------------------------------------------------------------\n   10001 particles from file astra.particles                                   \n\n\n     Cathode located at:               z =      0.000     m\n     Particles taken into account      N =      10001\n     total charge                      Q =    -0.1000     nC\n     horizontal beam position          x =    -1.3665E-16 mm\n     vertical beam position            y =    -1.6267E-16 mm\n     longitudinal beam position        z =      0.000     m\n     horizontal beam size          sig x =     0.2500     mm\n     vertical beam size            sig y =     0.2500     mm\n     longitudinal beam size        sig z =      0.000     mm\n     total emission time               t =     5.0643E-02 ns\n     rms emission time             sig t =     8.3859E-03 ns\n     average kinetic energy            E =     3.7500E-07 MeV\n     energy spread                    dE =     3.0451E-04 keV\n     average momentum                  P =     6.1907E-04 MeV/c\n     transverse beam emittance     eps x =     0.1749     pi mrad mm\n     correlated divergence         cor x =    -0.5362     mrad \n     transverse beam emittance     eps y =     0.1749     pi mrad mm\n     correlated divergence         cor y =    -0.6932     mrad\n     longitudinal beam emittance   eps z =      0.000     pi keV mm\n     correlated energy spread      cor z =      0.000     keV\n     emittance ratio eps y/eps x         =      1.000    \n --------------------------------------------------------------------------\n     Start auto phasing: \n     Scan cavity number  :   1\n        6 unstable trajectories out of   50\n --------------------------------------------------------------------------\n     Start phase scan: \n     Cavity number  :   1 from :   0.000     m  to:  0.1990     m\n      197 unstable trajectories out of  360\n\n     Cavity phasing completed:\n     Cavity number   Energy gain [MeV]  at  Phase [deg]\n           1            0.7586               261.45    \n --------------------------------------------------------------------------\n on axis tracking of the reference particle:\n     initial position                  z =    0.000     m\n                                       x =  -7.8886E-18 mm\n                                       y =  -3.9443E-18 mm\n     initial momentum                  p =   2.8534E-04 MeV/c\n     global phase shift              phi =    0.000     deg\n     time step for integration        dt =    7.500     ps\n --------------------------------------------------------------------------\n Online element settings:\n\n --------------------------------------------------------------------------\n\n     particle reaches position         z =   0.1500     m\n     time of flight is                 t =   0.6043     ns\n     final momentum                    p =    1.162     MeV/c\n     final phase (cavity 1)      phi_end =    268.4     deg\n --------------------------------------------------------------------------\n off axis tracking of the reference particle: \n     initial position                  z =    0.000     m\n                                       x =   0.2500     mm\n                                       y =   0.2500     mm\n\n     final position                    x =   0.5436     mm\n                                       y =   0.5978     mm\n     divergence                    px/pz =    1.865     mrad\n                                   py/pz =    3.587     mrad\n --------------------------------------------------------------------------\n tracking of    10001 particles:\n     tracking will stop at             z =   0.1500     m\n\n     space charge forces are INCLUDED\n     cylindrical symmetric algorithm\n     mirror charges at the cathode are taken into account\n     mirror charge switched off at:          0.1138     m\n\n     final checkpoint at               z =   0.1500     m\n     total number of iteration steps:          1651\n\n     **********************************************************************\n\n     Particles taken into account      N =      10001\n     total charge                      Q =    -0.1000     nC\n     horizontal beam position          x =     2.3682E-04 mm\n     vertical beam position            y =    -7.5225E-06 mm\n     longitudinal beam position        z =     0.1500     m\n     horizontal beam size          sig x =      2.413     mm\n     vertical beam size            sig y =      2.413     mm\n     longitudinal beam size        sig z =      2.654     mm\n     average kinetic energy            E =     0.7585     MeV\n     energy spread                    dE =      3.257     keV\n     average momentum                  P =      1.162     MeV/c\n     transverse beam emittance     eps x =      16.97     pi mrad mm\n     correlated divergence         cor x =      15.16     mrad \n     transverse beam emittance     eps y =      16.97     pi mrad mm\n     correlated divergence         cor y =      15.16     mrad\n     longitudinal beam emittance   eps z =      2.417     pi keV mm\n     correlated energy spread      cor z =      3.127     keV\n     emittance ratio eps y/eps x         =      1.000    \n\n     Particle Statistics: \n\n\n     Total number of particles on stack     =      10001\n     Electrons (total)                      =      10001\n     particles at the cathode               =          0\n     active particles                       =      10001\n     passive particles (lost out of bunch)  =          0\n     probe particles                        =          0\n     backward traveling particles           =          0\n     particles lost with z&lt;Zmin             =          0\n     particles lost due to cathode field    =          0\n     particles lost on aperture             =          0\n\n     **********************************************************************\n\n     Emittance information saved to file    : astra.Xemit.001               \n     Emittance information saved to file    : astra.Yemit.001               \n     Emittance information saved to file    : astra.Zemit.001               \n     Lost &amp; found saved to file             : astra.LandF.001               \n     Ref. part. information saved to file   : astra.ref.001                 \n     Phase-space distributions logged in    : astra.Log.001                 \n     Phase scan saved to file               : astra.PScan.001               \n     Cathode sp. charge field saved to file : astra.Cathode.001             \n     Core emittance data saved to file      : astra.Cemit.001               \n\n     **********************************************************************\n\n\n\n     finished simulation  Wed Aug  2 08:49:31 2023\n     elapsed time   :                22.0 seconds \n     execution time :                21.9 seconds \n     system time    :                 0.1 seconds\n     Goodbye.\n --------------------------------------------------------------------------\nloading 1 particle files\n[15.0]\n{'start_time': 1690991349.348098, 'run_script': '/Users/chrisonian/Code/Astra/bin/Astra astra.in', 'run_time': 22.16491198539734}\nCPU times: user 59.4 ms, sys: 10.1 ms, total: 69.5 ms\nWall time: 22.2 s\n</pre> In\u00a0[9]: Copied! <pre>P1 = A.particles[-1]\nP1.plot('z', 'pz')\n</pre> P1 = A.particles[-1] P1.plot('z', 'pz') In\u00a0[10]: Copied! <pre>A2 = A.copy()\nA2.input['charge']['lspch'] = True\nA2.input['charge']['lspch3d'] = True\nA2.input['charge']['l2d_3d'] = False\nA2.input['charge']['nxf'] = 32\nA2.input['charge']['nyf'] = 32\nA2.input['charge']['nzf'] = 32\nA2.input['charge']['nx0'] = 4\nA2.input['charge']['ny0'] = 4\nA2.input['charge']['nz0'] = 4\nA2.configure()\nA2.run()\n</pre> A2 = A.copy() A2.input['charge']['lspch'] = True A2.input['charge']['lspch3d'] = True A2.input['charge']['l2d_3d'] = False A2.input['charge']['nxf'] = 32 A2.input['charge']['nyf'] = 32 A2.input['charge']['nzf'] = 32 A2.input['charge']['nx0'] = 4 A2.input['charge']['ny0'] = 4 A2.input['charge']['nz0'] = 4 A2.configure() A2.run() <pre>Configured to run in: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpd93dk5wn\nInitial particles written to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpd93dk5wn/astra.particles\n --------------------------------------------------------------------------\n\n                Astra- A space charge tracking algorithm \n               Version 4.0 - macOS 64bit - Apple Silicon   \n                        DESY,  Hamburg 2022          \n                        Wed Aug  2 08:49:32 \n\n     Parameter file is:  astra.in                                          \n     APEX Gun                                                                        \n\n Initialize element settings:\n --------------------------------------------------------------------------\n Cavity:\n\n     Reading cavity field data from:      187MHz_HighDef_March2010.dat                                                    \n     field smoothing is applied\n     Cavity Frequency               f =   0.1870     GHz\n     maximum gradient                      20.00     MV/m\n     at                                    0.000     m\n     estimated average gradient            2.667     MV/m\n     nominal phase                         0.000     deg\n\n --------------------------------------------------------------------------\n Solenoid:\n\n     Reading solenoid field data from:    realbucking.dat                                                                 \n     field smoothing is applied\n     maximum |Bz| field                     0.000     T\n     at                                   -6.2050E-02 m\n     integral Bz squared                    0.000     T^2m\n\n     Reading solenoid field data from:    newSOL.dat                                                                      \n     field smoothing is applied\n     maximum |Bz| field                    5.7000E-02 T\n     at                                    0.2465     m\n     integral Bz squared                   2.8019E-04 T^2m\n\n     solenoids number:   1 and   2 overlap\n --------------------------------------------------------------------------\n   10001 particles from file astra.particles                                   \n\n     Particles taken into account      N =      10001\n     total charge                      Q =    -0.1000     nC\n     horizontal beam position          x =    -1.3665E-16 mm\n     vertical beam position            y =    -1.6267E-16 mm\n     longitudinal beam position        z =      0.000     m\n     horizontal beam size          sig x =     0.2500     mm\n     vertical beam size            sig y =     0.2500     mm\n     longitudinal beam size        sig z =      0.000     mm\n     total emission time               t =     5.0643E-02 ns\n     rms emission time             sig t =     8.3859E-03 ns\n     average kinetic energy            E =     3.7500E-07 MeV\n     energy spread                    dE =     3.0451E-04 keV\n     average momentum                  P =     6.1907E-04 MeV/c\n     transverse beam emittance     eps x =     0.1749     pi mrad mm\n     correlated divergence         cor x =    -0.5362     mrad \n     transverse beam emittance     eps y =     0.1749     pi mrad mm\n     correlated divergence         cor y =    -0.6932     mrad\n     longitudinal beam emittance   eps z =      0.000     pi keV mm\n     correlated energy spread      cor z =      0.000     keV\n     emittance ratio eps y/eps x         =      1.000    \n --------------------------------------------------------------------------\n     Start auto phasing: \n     Scan cavity number  :   1\n        6 unstable trajectories out of   50\n --------------------------------------------------------------------------\n     Start phase scan: \n     Cavity number  :   1 from :   0.000     m  to:  0.1990     m\n      197 unstable trajectories out of  360\n\n     Cavity phasing completed:\n     Cavity number   Energy gain [MeV]  at  Phase [deg]\n           1            0.7586               261.45    \n --------------------------------------------------------------------------\n on axis tracking of the reference particle:\n     initial position                  z =    0.000     m\n                                       x =  -7.8886E-18 mm\n                                       y =  -3.9443E-18 mm\n     initial momentum                  p =   2.8534E-04 MeV/c\n     global phase shift              phi =    0.000     deg\n     time step for integration        dt =    7.500     ps\n --------------------------------------------------------------------------\n Online element settings:\n\n --------------------------------------------------------------------------\n\n     particle reaches position         z =   0.1500     m\n     time of flight is                 t =   0.6043     ns\n     final momentum                    p =    1.162     MeV/c\n     final phase (cavity 1)      phi_end =    268.4     deg\n --------------------------------------------------------------------------\n off axis tracking of the reference particle: \n     initial position                  z =    0.000     m\n                                       x =   0.2500     mm\n                                       y =   0.2500     mm\n\n     final position                    x =   0.5436     mm\n                                       y =   0.5978     mm\n     divergence                    px/pz =    1.865     mrad\n                                   py/pz =    3.587     mrad\n --------------------------------------------------------------------------\n tracking of    10001 particles:\n     tracking will stop at             z =   0.1500     m\n\n     space charge forces are INCLUDED\n     3D FFT algorithm\n WARNING: particle outside grid\n WARNING: particle outside grid\n WARNING: particle outside grid\n WARNING: particle outside grid\n\n     final checkpoint at               z =   0.1500     m\n     total number of iteration steps:          1651\n\n     **********************************************************************\n\n     Particles taken into account      N =      10001\n     total charge                      Q =    -0.1000     nC\n     horizontal beam position          x =    -1.8560E-04 mm\n     vertical beam position            y =    -1.5354E-04 mm\n     longitudinal beam position        z =     0.1500     m\n     horizontal beam size          sig x =      2.972     mm\n     vertical beam size            sig y =      2.973     mm\n     longitudinal beam size        sig z =      2.571     mm\n     average kinetic energy            E =     0.7596     MeV\n     energy spread                    dE =      3.174     keV\n     average momentum                  P =      1.163     MeV/c\n     transverse beam emittance     eps x =      25.77     pi mrad mm\n     correlated divergence         cor x =      18.53     mrad \n     transverse beam emittance     eps y =      25.77     pi mrad mm\n     correlated divergence         cor y =      18.54     mrad\n     longitudinal beam emittance   eps z =      2.345     pi keV mm\n     correlated energy spread      cor z =      3.040     keV\n     emittance ratio eps y/eps x         =     0.9999    \n\n     Particle Statistics: \n\n\n     Total number of particles on stack     =      10001\n     Electrons (total)                      =      10001\n     particles at the cathode               =          0\n     active particles                       =      10001\n     passive particles (lost out of bunch)  =          0\n     probe particles                        =          0\n     backward traveling particles           =          0\n     particles lost with z&lt;Zmin             =          0\n     particles lost due to cathode field    =          0\n     particles lost on aperture             =          0\n\n     **********************************************************************\n\n     Emittance information saved to file    : astra.Xemit.001               \n     Emittance information saved to file    : astra.Yemit.001               \n     Emittance information saved to file    : astra.Zemit.001               \n     Lost &amp; found saved to file             : astra.LandF.001               \n     Ref. part. information saved to file   : astra.ref.001                 \n     Phase-space distributions logged in    : astra.Log.001                 \n     Phase scan saved to file               : astra.PScan.001               \n     Cathode sp. charge field saved to file : astra.Cathode.001             \n     Core emittance data saved to file      : astra.Cemit.001               \n\n     **********************************************************************\n\n\n\n     finished simulation  Wed Aug  2 08:50:07 2023\n     elapsed time   :                35.6 seconds \n     execution time :                35.4 seconds \n     system time    :                 0.2 seconds\n     Goodbye.\n --------------------------------------------------------------------------\nloading 1 particle files\n[15.0]\n{'start_time': 1690991372.058728, 'run_script': '/Users/chrisonian/Code/Astra/bin/Astra astra.in', 'run_time': 35.72111988067627}\n</pre> In\u00a0[11]: Copied! <pre>P2 = A2.particles[-1]\nP2.plot('x', 'px')\n</pre> P2 = A2.particles[-1] P2.plot('x', 'px') In\u00a0[12]: Copied! <pre>k1 = 'z'\nk2 = 'x'\nplt.scatter(P2[k1], P2[k2], label='3d', marker='.')\nplt.scatter(P1[k1], P1[k2], label='2d', marker='x')\n\nplt.legend()\n</pre> k1 = 'z' k2 = 'x' plt.scatter(P2[k1], P2[k2], label='3d', marker='.') plt.scatter(P1[k1], P1[k2], label='2d', marker='x')  plt.legend() Out[12]: <pre>&lt;matplotlib.legend.Legend at 0x15c80cf70&gt;</pre> In\u00a0[13]: Copied! <pre>k1 = 'x'\nk2 = 'y'\n\nunits1 = str(A.units(k1))\nunits2 = str(A.units(k2))\nplt.xlabel(k1+f' ({units1})')\nplt.ylabel(k2+f' ({units2})')\nplt.scatter(P2[k1], P2[k2], label='Astra 3d', marker='.')\nplt.scatter(P1[k1], P1[k2], label='Astra 2d', marker='.')\n#plt.scatter(P3[k1], P3[k2], label='Impact-T 3d', marker='.')\n#plt.scatter(P4[k1], P4[k2], label='GPT 3D', marker='.')\nplt.legend()\n</pre> k1 = 'x' k2 = 'y'  units1 = str(A.units(k1)) units2 = str(A.units(k2)) plt.xlabel(k1+f' ({units1})') plt.ylabel(k2+f' ({units2})') plt.scatter(P2[k1], P2[k2], label='Astra 3d', marker='.') plt.scatter(P1[k1], P1[k2], label='Astra 2d', marker='.') #plt.scatter(P3[k1], P3[k2], label='Impact-T 3d', marker='.') #plt.scatter(P4[k1], P4[k2], label='GPT 3D', marker='.') plt.legend() Out[13]: <pre>&lt;matplotlib.legend.Legend at 0x15d596580&gt;</pre> In\u00a0[14]: Copied! <pre>k1 = 'z'\nk2 = 'pz'\n\nunits1 = str(A.units(k1))\nunits2 = str(A.units(k2))\nplt.xlabel(k1+f' ({units1})')\nplt.ylabel(k2+f' ({units2})')\nplt.scatter(P2[k1], P2[k2], label='Astra 3d', marker='.')\nplt.scatter(P1[k1], P1[k2], label='Astra 2d', marker='.')\n#plt.scatter(P3[k1], P3[k2], label='Impact-T 3d', marker='.')\n#plt.scatter(P4[k1], P4[k2], label='GPT 3D', marker='.')\nplt.legend()\n</pre> k1 = 'z' k2 = 'pz'  units1 = str(A.units(k1)) units2 = str(A.units(k2)) plt.xlabel(k1+f' ({units1})') plt.ylabel(k2+f' ({units2})') plt.scatter(P2[k1], P2[k2], label='Astra 3d', marker='.') plt.scatter(P1[k1], P1[k2], label='Astra 2d', marker='.') #plt.scatter(P3[k1], P3[k2], label='Impact-T 3d', marker='.') #plt.scatter(P4[k1], P4[k2], label='GPT 3D', marker='.') plt.legend() Out[14]: <pre>&lt;matplotlib.legend.Legend at 0x15f0fa7f0&gt;</pre> In\u00a0[15]: Copied! <pre>P1.plot('z', 'pz')\n</pre> P1.plot('z', 'pz') In\u00a0[16]: Copied! <pre>P2.plot('z', 'pz')\n</pre> P2.plot('z', 'pz') In\u00a0[17]: Copied! <pre>A.input['output']\n</pre> A.input['output'] Out[17]: <pre>{'zstart': 0,\n 'zstop': 0.15,\n 'zemit': 1000,\n 'zphase': 1,\n 'screen(1)': 1.490314,\n 'lmagnetized': True,\n 'lsub_rot': False,\n 'lproject_emit': False,\n 'larmors': False,\n 'emits': True,\n 'c_emits': True,\n 'landfs': True,\n 'phases': True,\n 'tracks': True,\n 'refs': True,\n 'tchecks': False,\n 'cathodes': True,\n 'high_res': True}</pre>"},{"location":"examples/elements/apex_gun/#apex-gun","title":"APEX Gun\u00b6","text":""},{"location":"examples/elements/apex_gun/#3d-space-charge-method","title":"3D Space Charge method\u00b6","text":"<p>This does not properly take the image charge force at the cathode.</p>"},{"location":"examples/elements/drift/","title":"Drift","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from astra import Astra\nfrom distgen import Generator\n\nimport matplotlib.pyplot as plt\nimport matplotlib\nmatplotlib.rcParams['figure.figsize'] = (13,8)\n%config InlineBackend.figure_format = 'retina'\nimport os\n</pre> from astra import Astra from distgen import Generator  import matplotlib.pyplot as plt import matplotlib matplotlib.rcParams['figure.figsize'] = (13,8) %config InlineBackend.figure_format = 'retina' import os In\u00a0[3]: Copied! <pre># Input template file \nASTRA_IN = '../templates/drift/astra.in'\nDISTGEN_IN = '../templates/drift/distgen.yaml'\n</pre> # Input template file  ASTRA_IN = '../templates/drift/astra.in' DISTGEN_IN = '../templates/drift/distgen.yaml' In\u00a0[4]: Copied! <pre>G = Generator(DISTGEN_IN)\nG[\"n_particle\"] = 10_000\nG.run()\nP0 = G.particles\n\nP0\n</pre> G = Generator(DISTGEN_IN) G[\"n_particle\"] = 10_000 G.run() P0 = G.particles  P0 Out[4]: <pre>&lt;ParticleGroup with 10000 particles at 0x10418ddc0&gt;</pre> In\u00a0[5]: Copied! <pre># Make an Astra object\nA = Astra(input_file=ASTRA_IN, initial_particles=P0, verbose=True)\n</pre> # Make an Astra object A = Astra(input_file=ASTRA_IN, initial_particles=P0, verbose=True) <pre>Configured to run in: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp4tffa6s5\n</pre> In\u00a0[6]: Copied! <pre># Run\nA.run()\n</pre> # Run A.run() <pre>Initial particles written to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp4tffa6s5/astra.particles\n --------------------------------------------------------------------------\n\n                Astra- A space charge tracking algorithm \n               Version 4.0 - macOS 64bit - Apple Silicon   \n                        DESY,  Hamburg 2022          \n                        Wed Aug  2 08:50:14 \n\n     Parameter file is:  astra.in                                          \n     Drift example                                                                   \n\n Initialize element settings:\n --------------------------------------------------------------------------\n   10001 particles from file astra.particles                                   \n\n     Particles taken into account      N =      10001\n     total charge                      Q =     -1.000     nC\n     horizontal beam position          x =     9.1954E-16 mm\n     vertical beam position            y =    -6.4483E-16 mm\n     longitudinal beam position        z =     1.3014E-19 m\n     horizontal beam size          sig x =      1.000     mm\n     vertical beam size            sig y =      1.000     mm\n     longitudinal beam size        sig z =     0.1000     mm\n     average kinetic energy            E =      9.502     MeV\n     energy spread                    dE =     1.7224E-09 keV\n     average momentum                  P =      10.00     MeV/c\n     transverse beam emittance     eps x =      0.000     pi mrad mm\n     correlated divergence         cor x =      0.000     mrad \n     transverse beam emittance     eps y =      0.000     pi mrad mm\n     correlated divergence         cor y =      0.000     mrad\n     longitudinal beam emittance   eps z =     1.7247E-10 pi keV mm\n     correlated energy spread      cor z =     3.9171E-26 keV\n     emittance ratio eps y/eps x         =      0.000    \n --------------------------------------------------------------------------\n     Start auto phasing: \n --------------------------------------------------------------------------\n     Start phase scan: \n\n     Cavity phasing completed:\n     Cavity number   Energy gain [MeV]  at  Phase [deg]\n --------------------------------------------------------------------------\n on axis tracking of the reference particle:\n     initial position                  z =   1.8735E-21 m\n                                       x =    0.000     mm\n                                       y =    0.000     mm\n     initial momentum                  p =    10.00     MeV/c\n     global phase shift              phi =    0.000     deg\n     time step for integration        dt =    7.500     ps\n --------------------------------------------------------------------------\n Online element settings:\n\n --------------------------------------------------------------------------\n\n     particle reaches position         z =    1.000     m\n     time of flight is                 t =    3.340     ns\n     final momentum                    p =    10.00     MeV/c\n     final phase (cavity 1)      phi_end =    0.000     deg\n --------------------------------------------------------------------------\n off axis tracking of the reference particle: \n     initial position                  z =   1.8735E-21 m\n                                       x =    1.000     mm\n                                       y =    1.000     mm\n\n     final position                    x =    1.000     mm\n                                       y =    1.000     mm\n     divergence                    px/pz =    0.000     mrad\n                                   py/pz =    0.000     mrad\n --------------------------------------------------------------------------\n tracking of    10001 particles:\n     tracking will stop at             z =    1.000     m\n\n     space charge forces are INCLUDED\n     3D FFT algorithm\n\n     final checkpoint at               z =    1.000     m\n     total number of iteration steps:           544\n\n     **********************************************************************\n\n     Particles taken into account      N =      10001\n     total charge                      Q =     -1.000     nC\n     horizontal beam position          x =    -1.4417E-04 mm\n     vertical beam position            y =     7.4455E-05 mm\n     longitudinal beam position        z =      1.000     m\n     horizontal beam size          sig x =      2.076     mm\n     vertical beam size            sig y =      2.075     mm\n     longitudinal beam size        sig z =     0.1466     mm\n     average kinetic energy            E =      9.515     MeV\n     energy spread                    dE =      311.4     keV\n     average momentum                  P =      10.01     MeV/c\n     transverse beam emittance     eps x =      12.38     pi mrad mm\n     correlated divergence         cor x =      1.797     mrad \n     transverse beam emittance     eps y =      12.43     pi mrad mm\n     correlated divergence         cor y =      1.797     mrad\n     longitudinal beam emittance   eps z =      10.93     pi keV mm\n     correlated energy spread      cor z =      302.3     keV\n     emittance ratio eps y/eps x         =     0.9957    \n\n     Particle Statistics: \n\n\n     Total number of particles on stack     =      10001\n     Electrons (total)                      =      10001\n     particles at the cathode               =          0\n     active particles                       =      10001\n     passive particles (lost out of bunch)  =          0\n     probe particles                        =          0\n     backward traveling particles           =          0\n     particles lost with z&lt;Zmin             =          0\n     particles lost due to cathode field    =          0\n     particles lost on aperture             =          0\n\n     **********************************************************************\n\n     Emittance information saved to file    : astra.Xemit.001               \n     Emittance information saved to file    : astra.Yemit.001               \n     Emittance information saved to file    : astra.Zemit.001               \n     Lost &amp; found saved to file             : astra.LandF.001               \n     Ref. part. information saved to file   : astra.ref.001                 \n     Phase-space distributions logged in    : astra.Log.001                 \n     Phase scan saved to file               : astra.PScan.001               \n     Core emittance data saved to file      : astra.Cemit.001               \n\n     **********************************************************************\n\n\n\n     finished simulation  Wed Aug  2 08:50:19 2023\n     elapsed time   :                 5.6 seconds \n     execution time :                 5.5 seconds \n     system time    :                 0.0 seconds\n     Goodbye.\n --------------------------------------------------------------------------\nloading 1 particle files\n[100.0]\n{'start_time': 1690991414.116042, 'run_script': '/Users/chrisonian/Code/Astra/bin/Astra astra.in', 'run_time': 5.663373231887817}\n</pre> <pre>Note: The following floating-point exceptions are signalling: IEEE_DIVIDE_BY_ZERO\n</pre> In\u00a0[7]: Copied! <pre>P = A.particles[-1]\nP.plot('x', 'px')\nP.plot('z', 'pz')\n</pre> P = A.particles[-1] P.plot('x', 'px') P.plot('z', 'pz') In\u00a0[8]: Copied! <pre>A2 = A.copy()\nA2.input['charge']['lspch'] = True\nA2.input['charge']['lspch3d'] = True\nA2.input['charge']['l2d_3d'] = False\nA2.input['charge']['nxf'] = 32\nA2.input['charge']['nyf'] = 32\nA2.input['charge']['nzf'] = 32\nA2.input['charge']['nx0'] = 4\nA2.input['charge']['ny0'] = 4\nA2.input['charge']['nz0'] = 4\nA2.configure()\nA2.run()\n</pre> A2 = A.copy() A2.input['charge']['lspch'] = True A2.input['charge']['lspch3d'] = True A2.input['charge']['l2d_3d'] = False A2.input['charge']['nxf'] = 32 A2.input['charge']['nyf'] = 32 A2.input['charge']['nzf'] = 32 A2.input['charge']['nx0'] = 4 A2.input['charge']['ny0'] = 4 A2.input['charge']['nz0'] = 4 A2.configure() A2.run() <pre>Configured to run in: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp65kgsf88\nInitial particles written to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp65kgsf88/astra.particles\n --------------------------------------------------------------------------\n\n                Astra- A space charge tracking algorithm \n               Version 4.0 - macOS 64bit - Apple Silicon   \n                        DESY,  Hamburg 2022          \n                        Wed Aug  2 08:50:20 \n\n     Parameter file is:  astra.in                                          \n     Drift example                                                                   \n\n Initialize element settings:\n --------------------------------------------------------------------------\n   10001 particles from file astra.particles                                   \n\n     Particles taken into account      N =      10001\n     total charge                      Q =     -1.000     nC\n     horizontal beam position          x =     9.1954E-16 mm\n     vertical beam position            y =    -6.4483E-16 mm\n     longitudinal beam position        z =     1.3014E-19 m\n     horizontal beam size          sig x =      1.000     mm\n     vertical beam size            sig y =      1.000     mm\n     longitudinal beam size        sig z =     0.1000     mm\n     average kinetic energy            E =      9.502     MeV\n     energy spread                    dE =     1.7224E-09 keV\n     average momentum                  P =      10.00     MeV/c\n     transverse beam emittance     eps x =      0.000     pi mrad mm\n     correlated divergence         cor x =      0.000     mrad \n     transverse beam emittance     eps y =      0.000     pi mrad mm\n     correlated divergence         cor y =      0.000     mrad\n     longitudinal beam emittance   eps z =     1.7247E-10 pi keV mm\n     correlated energy spread      cor z =     3.9171E-26 keV\n     emittance ratio eps y/eps x         =      0.000    \n --------------------------------------------------------------------------\n     Start auto phasing: \n --------------------------------------------------------------------------\n     Start phase scan: \n\n     Cavity phasing completed:\n     Cavity number   Energy gain [MeV]  at  Phase [deg]\n --------------------------------------------------------------------------\n on axis tracking of the reference particle:\n     initial position                  z =   1.8735E-21 m\n                                       x =    0.000     mm\n                                       y =    0.000     mm\n     initial momentum                  p =    10.00     MeV/c\n     global phase shift              phi =    0.000     deg\n     time step for integration        dt =    7.500     ps\n --------------------------------------------------------------------------\n Online element settings:\n\n --------------------------------------------------------------------------\n\n     particle reaches position         z =    1.000     m\n     time of flight is                 t =    3.340     ns\n     final momentum                    p =    10.00     MeV/c\n     final phase (cavity 1)      phi_end =    0.000     deg\n --------------------------------------------------------------------------\n off axis tracking of the reference particle: \n     initial position                  z =   1.8735E-21 m\n                                       x =    1.000     mm\n                                       y =    1.000     mm\n\n     final position                    x =    1.000     mm\n                                       y =    1.000     mm\n     divergence                    px/pz =    0.000     mrad\n                                   py/pz =    0.000     mrad\n --------------------------------------------------------------------------\n tracking of    10001 particles:\n     tracking will stop at             z =    1.000     m\n\n     space charge forces are INCLUDED\n     3D FFT algorithm\n\n     final checkpoint at               z =    1.000     m\n     total number of iteration steps:           549\n\n     **********************************************************************\n\n     Particles taken into account      N =      10001\n     total charge                      Q =     -1.000     nC\n     horizontal beam position          x =     6.0368E-05 mm\n     vertical beam position            y =     7.4282E-05 mm\n     longitudinal beam position        z =      1.000     m\n     horizontal beam size          sig x =      2.068     mm\n     vertical beam size            sig y =      2.067     mm\n     longitudinal beam size        sig z =     0.1463     mm\n     average kinetic energy            E =      9.515     MeV\n     energy spread                    dE =      309.8     keV\n     average momentum                  P =      10.01     MeV/c\n     transverse beam emittance     eps x =      12.36     pi mrad mm\n     correlated divergence         cor x =      1.788     mrad \n     transverse beam emittance     eps y =      12.41     pi mrad mm\n     correlated divergence         cor y =      1.787     mrad\n     longitudinal beam emittance   eps z =      10.90     pi keV mm\n     correlated energy spread      cor z =      300.7     keV\n     emittance ratio eps y/eps x         =     0.9959    \n\n     Particle Statistics: \n\n\n     Total number of particles on stack     =      10001\n     Electrons (total)                      =      10001\n     particles at the cathode               =          0\n     active particles                       =      10001\n     passive particles (lost out of bunch)  =          0\n     probe particles                        =          0\n     backward traveling particles           =          0\n     particles lost with z&lt;Zmin             =          0\n     particles lost due to cathode field    =          0\n     particles lost on aperture             =          0\n\n     **********************************************************************\n\n     Emittance information saved to file    : astra.Xemit.001               \n     Emittance information saved to file    : astra.Yemit.001               \n     Emittance information saved to file    : astra.Zemit.001               \n     Lost &amp; found saved to file             : astra.LandF.001               \n     Ref. part. information saved to file   : astra.ref.001                 \n     Phase-space distributions logged in    : astra.Log.001                 \n     Phase scan saved to file               : astra.PScan.001               \n     Core emittance data saved to file      : astra.Cemit.001               \n\n     **********************************************************************\n\n\n\n     finished simulation  Wed Aug  2 08:50:26 2023\n     elapsed time   :                 5.5 seconds \n     execution time :                 5.5 seconds \n     system time    :                 0.0 seconds\n     Goodbye.\n --------------------------------------------------------------------------\nloading 1 particle files\n[100.0]\n{'start_time': 1690991420.61433, 'run_script': '/Users/chrisonian/Code/Astra/bin/Astra astra.in', 'run_time': 5.618848085403442}\n</pre> <pre>Note: The following floating-point exceptions are signalling: IEEE_DIVIDE_BY_ZERO\n</pre> In\u00a0[9]: Copied! <pre>P2 = A2.particles[-1]\nP2.plot('x', 'px')\n</pre> P2 = A2.particles[-1] P2.plot('x', 'px') In\u00a0[10]: Copied! <pre>k1 = 'z'\nk2 = 'x'\nskip = 10\nplt.scatter(P[k1][::skip], P[k2][::skip], label='2d', marker='x', alpha=0.5)\nplt.scatter(P2[k1][::skip], P2[k2][::skip], label='3d', marker='.', alpha=0.5)\nplt.legend()\n</pre> k1 = 'z' k2 = 'x' skip = 10 plt.scatter(P[k1][::skip], P[k2][::skip], label='2d', marker='x', alpha=0.5) plt.scatter(P2[k1][::skip], P2[k2][::skip], label='3d', marker='.', alpha=0.5) plt.legend() Out[10]: <pre>&lt;matplotlib.legend.Legend at 0x156cadb50&gt;</pre> In\u00a0[11]: Copied! <pre>k1 = 'x'\nk2 = 'px'\nskip = 1\nplt.scatter(P[k1][::skip], P[k2][::skip], label='2d', marker='x', alpha=0.5)\nplt.scatter(P2[k1][::skip], P2[k2][::skip], label='3d', marker='.', alpha=0.5)\nplt.legend()\n</pre> k1 = 'x' k2 = 'px' skip = 1 plt.scatter(P[k1][::skip], P[k2][::skip], label='2d', marker='x', alpha=0.5) plt.scatter(P2[k1][::skip], P2[k2][::skip], label='3d', marker='.', alpha=0.5) plt.legend() Out[11]: <pre>&lt;matplotlib.legend.Legend at 0x156c7dd60&gt;</pre>"},{"location":"examples/elements/drift/#drift","title":"Drift\u00b6","text":""},{"location":"examples/elements/drift/#3d","title":"3D\u00b6","text":""},{"location":"examples/elements/tesla_9cell_cavity/","title":"TESLA 9-cell Cavity","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from astra import Astra\nfrom pmd_beamphysics import single_particle\n\nfrom distgen import Generator\n\nimport matplotlib.pyplot as plt\nimport matplotlib\nmatplotlib.rcParams['figure.figsize'] = (13,8)\n%config InlineBackend.figure_format = 'retina'\nimport os\n</pre> from astra import Astra from pmd_beamphysics import single_particle  from distgen import Generator  import matplotlib.pyplot as plt import matplotlib matplotlib.rcParams['figure.figsize'] = (13,8) %config InlineBackend.figure_format = 'retina' import os In\u00a0[3]: Copied! <pre># Input template file \nASTRA_IN = '../templates/tesla_9cell_cavity/astra.in'\nDISTGEN_IN =  '../templates/tesla_9cell_cavity/distgen.yaml'\n</pre> # Input template file  ASTRA_IN = '../templates/tesla_9cell_cavity/astra.in' DISTGEN_IN =  '../templates/tesla_9cell_cavity/distgen.yaml' In\u00a0[4]: Copied! <pre>G = Generator(DISTGEN_IN)\nG.run()\nP0 = G.particles\n</pre> G = Generator(DISTGEN_IN) G.run() P0 = G.particles In\u00a0[5]: Copied! <pre># Make an Astra object\nA = Astra(input_file=ASTRA_IN, initial_particles=P0, verbose=True)\n</pre> # Make an Astra object A = Astra(input_file=ASTRA_IN, initial_particles=P0, verbose=True) In\u00a0[6]: Copied! <pre># Run\nA.input['charge']['lspch'] = True\nA.input['charge']['lspch3d'] = False\n\nA.run()\n</pre> # Run A.input['charge']['lspch'] = True A.input['charge']['lspch3d'] = False  A.run() <pre>Initial particles written to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp9yes1459/astra.particles\n --------------------------------------------------------------------------\n\n                Astra- A space charge tracking algorithm \n               Version 3.2 - macOS 64bit - Apple Silicon   \n                        DESY,  Hamburg 2011          \n                        Tue Oct  4 12:55:13 \n\n     Parameter file is:  astra.in                                          \n     TESLA 9-cell cavity example                                                     \n\n Initialize element settings:\n --------------------------------------------------------------------------\n Cavity:\n\n     Reading cavity field data from:      tesla_9cell_cavity_Ez.dat                                                       \n     field smoothing is applied\n     Cavity Frequency               f =    1.300     GHz\n     maximum gradient                      32.00     MV/m\n     at                                    1.136     m\n     estimated average gradient            12.44     MV/m\n     nominal phase                         0.000     deg\n\n --------------------------------------------------------------------------\n   10001 particles from file astra.particles                                   \n\n     Particles taken into account      N =      10001\n     total charge                      Q =     -1.000     nC\n     horizontal beam position          x =     6.0718E-18 mm\n     vertical beam position            y =     1.8565E-17 mm\n     longitudinal beam position        z =     1.5199E-19 m\n     horizontal beam size          sig x =     1.0000E-02 mm\n     vertical beam size            sig y =     1.0000E-02 mm\n     longitudinal beam size        sig z =     0.1000     mm\n     average kinetic energy            E =      99.49     MeV\n     energy spread                    dE =     1.6514E-08 keV\n     average momentum                  P =      100.0     MeV/c\n     transverse beam emittance     eps x =      0.000     pi mrad mm\n     correlated divergence         cor x =      0.000     mrad \n     transverse beam emittance     eps y =      0.000     pi mrad mm\n     correlated divergence         cor y =      0.000     mrad\n     longitudinal beam emittance   eps z =     1.6513E-09 pi keV mm\n     correlated energy spread      cor z =     1.4196E-25 keV\n     emittance ratio eps y/eps x         =      0.000    \n --------------------------------------------------------------------------\n     Start auto phasing: \n\n     WARNING: Particle starts inside cavity number:    1\n\n     Scan cavity number  :   1\n        0 unstable trajectories out of   50\n --------------------------------------------------------------------------\n     Start phase scan: \n\n     WARNING: Particle starts inside cavity number:    1\n\n     Cavity number  :   1 from :   0.000     m  to:   1.347     m\n        0 unstable trajectories out of  360\n\n     Cavity phasing completed:\n     Cavity number   Energy gain [MeV]  at  Phase [deg]\n           1             17.34               299.38    \n --------------------------------------------------------------------------\n on axis tracking of the reference particle:\n     initial position                  z =   2.0892E-21 m\n                                       x =    0.000     mm\n                                       y =  -1.9722E-19 mm\n     initial momentum                  p =    100.0     MeV/c\n     global phase shift              phi =    0.000     deg\n     time step for integration        dt =    3.000     ps\n --------------------------------------------------------------------------\n Online element settings:\n\n --------------------------------------------------------------------------\n\n     particle reaches position         z =    1.500     m\n     time of flight is                 t =    5.004     ns\n     final momentum                    p =    117.3     MeV/c\n     final phase (cavity 1)      phi_end =    299.4     deg\n --------------------------------------------------------------------------\n off axis tracking of the reference particle: \n     initial position                  z =   2.0892E-21 m\n                                       x =   1.0000E-02 mm\n                                       y =   1.0000E-02 mm\n\n     final position                    x =   9.1605E-03 mm\n                                       y =   9.1605E-03 mm\n     divergence                    px/pz =  -8.3798E-05 mrad\n                                   py/pz =  -8.3798E-05 mrad\n --------------------------------------------------------------------------\n tracking of    10001 particles :\n     tracking will stop at             z =    1.500     m\n\n     space charge forces are INCLUDED\n     cylindrical symmetric algorithm\n\n     final checkpoint at               z =    1.500     m\n     total number of iteration steps:          1828\n\n     **********************************************************************\n\n     Particles taken into account      N =      10001\n     total charge                      Q =     -1.000     nC\n     horizontal beam position          x =     2.3730E-05 mm\n     vertical beam position            y =     7.8206E-06 mm\n     longitudinal beam position        z =      1.500     m\n     horizontal beam size          sig x =     0.1443     mm\n     vertical beam size            sig y =     0.1443     mm\n     longitudinal beam size        sig z =     0.1000     mm\n     average kinetic energy            E =      116.9     MeV\n     energy spread                    dE =      58.64     keV\n     average momentum                  P =      117.4     MeV/c\n     transverse beam emittance     eps x =     4.7268E-02 pi mrad mm\n     correlated divergence         cor x =     0.1175     mrad \n     transverse beam emittance     eps y =     4.7712E-02 pi mrad mm\n     correlated divergence         cor y =     0.1174     mrad\n     longitudinal beam emittance   eps z =      5.261     pi keV mm\n     correlated energy spread      cor z =      25.91     keV\n     emittance ratio eps y/eps x         =     0.9907    \n\n     Particle Statistics: \n\n\n     Total number of particles on stack     =      10001\n     Electrons (total)                      =      10001\n     particles at the cathode               =          0\n     active particles                       =      10001\n     passive particles (lost out of bunch)  =          0\n     probe particles                        =          0\n     backward traveling particles           =          0\n     particles lost with z&lt;Zmin             =          0\n     particles lost due to cathode field    =          0\n     particles lost on aperture             =          0\n\n     Tracking ended with     2 warning(s)\n\n\n     **********************************************************************\n\n     Emittance information saved to file    : astra.Xemit.001               \n     Emittance information saved to file    : astra.Yemit.001               \n     Emittance information saved to file    : astra.Zemit.001               \n     Lost &amp; found saved to file             : astra.LandF.001               \n     Ref. part. information saved to file   : astra.ref.001                 \n     Phase-space distributions logged in    : astra.Log.001                 \n     Phase scan saved to file               : astra.PScan.001               \n     Core emittance data saved to file      : astra.Cemit.001               \n\n     **********************************************************************\n\n\n\n     finished simulation  Tue Oct  4 12:55:59 2022\n     elapsed time   :                45.8 seconds \n     execution time :                45.6 seconds \n     system time    :                 0.2 seconds\n     Goodbye.\n --------------------------------------------------------------------------\nloading 1 particle files\n[150.0]\n{'start_time': 1664902513.90176, 'run_script': '/Users/chrisonian/Code/Astra/bin/Astra astra.in', 'run_time': 45.97193694114685, 'run_error': False}\n</pre> <pre>Note: The following floating-point exceptions are signalling: IEEE_DIVIDE_BY_ZERO\n</pre> In\u00a0[7]: Copied! <pre># Compare these. \nkey1 = 'mean_z'\nkey2 = 'sigma_x'\nunits1 = str(A.units(key1))\nunits2 = str(A.units(key2))\nplt.xlabel(key1+f' ({units1})')\nplt.ylabel(key2+f' ({units2})')\nplt.plot(A.stat(key1), A.stat(key2))\nplt.scatter(A.particle_stat(key1), A.particle_stat(key2), color='red')\n#plt.scatter(A.particle_stat(key1, alive_only=False), A.particle_stat(key2, alive_only=False), color='green')\n</pre> # Compare these.  key1 = 'mean_z' key2 = 'sigma_x' units1 = str(A.units(key1)) units2 = str(A.units(key2)) plt.xlabel(key1+f' ({units1})') plt.ylabel(key2+f' ({units2})') plt.plot(A.stat(key1), A.stat(key2)) plt.scatter(A.particle_stat(key1), A.particle_stat(key2), color='red') #plt.scatter(A.particle_stat(key1, alive_only=False), A.particle_stat(key2, alive_only=False), color='green') Out[7]: <pre>&lt;matplotlib.collections.PathCollection at 0x13f164b20&gt;</pre> In\u00a0[8]: Copied! <pre>P = A.particles[-1]\n#P.plot('x', 'px')\nP.plot('z', 'pz', bins=100)\n</pre> P = A.particles[-1] #P.plot('x', 'px') P.plot('z', 'pz', bins=100) In\u00a0[9]: Copied! <pre># Compare these. \nkey1 = 'mean_z'\nkey2 = 'norm_emit_x'\nunits1 = str(A.units(key1))\nunits2 = str(A.units(key2))\nplt.xlabel(key1+f' ({units1})')\nplt.ylabel(key2+f' ({units2})')\nplt.plot(A.stat(key1), A.stat(key2), label='Astra', color='red')\n#plt.plot(I.stat(key1), I.stat(key2), '--', label='Impact-T', color='blue')\n\nplt.scatter(A.particle_stat(key1), A.particle_stat(key2), color='red')\nplt.legend()\n#plt.scatter(A.particle_stat(key1, alive_only=False), A.particle_stat(key2, alive_only=False), color='green')\n</pre> # Compare these.  key1 = 'mean_z' key2 = 'norm_emit_x' units1 = str(A.units(key1)) units2 = str(A.units(key2)) plt.xlabel(key1+f' ({units1})') plt.ylabel(key2+f' ({units2})') plt.plot(A.stat(key1), A.stat(key2), label='Astra', color='red') #plt.plot(I.stat(key1), I.stat(key2), '--', label='Impact-T', color='blue')  plt.scatter(A.particle_stat(key1), A.particle_stat(key2), color='red') plt.legend() #plt.scatter(A.particle_stat(key1, alive_only=False), A.particle_stat(key2, alive_only=False), color='green') Out[9]: <pre>&lt;matplotlib.legend.Legend at 0x14e781280&gt;</pre> In\u00a0[10]: Copied! <pre>#A.archive('astra_cavity9_SC_2D.h5')\n</pre> #A.archive('astra_cavity9_SC_2D.h5') In\u00a0[11]: Copied! <pre>#PI1 = I.particles['initial_particles']\n#PI2 = I.particles['final_particles']\n#\n#PA1 = P0\n#PA2 = A.particles[-1]\n</pre> #PI1 = I.particles['initial_particles'] #PI2 = I.particles['final_particles'] # #PA1 = P0 #PA2 = A.particles[-1] In\u00a0[\u00a0]: Copied! <pre>P0['sigma_x'], PI1['sigma_x']\n</pre> P0['sigma_x'], PI1['sigma_x'] In\u00a0[\u00a0]: Copied! <pre>k1 = 'x'\nk2 = 'px'\nskip = 1\nplt.scatter(PA1[k1][::skip], PA1[k2][::skip], label='Astra', marker='x', alpha=0.5)\nplt.scatter(PI1[k1][::skip], PI1[k2][::skip], label='Impact', marker='.', alpha=0.5)\nplt.legend()\n</pre> k1 = 'x' k2 = 'px' skip = 1 plt.scatter(PA1[k1][::skip], PA1[k2][::skip], label='Astra', marker='x', alpha=0.5) plt.scatter(PI1[k1][::skip], PI1[k2][::skip], label='Impact', marker='.', alpha=0.5) plt.legend() In\u00a0[\u00a0]: Copied! <pre>k1 = 'z'\nk2 = 'x'\nskip = 1\nplt.scatter(PA2[k1][::skip], PA2[k2][::skip], label='Astra', marker='x', alpha=0.5)\nplt.scatter(PI2[k1][::skip], PI2[k2][::skip], label='Impact', marker='.', alpha=0.5)\nplt.legend()\n</pre> k1 = 'z' k2 = 'x' skip = 1 plt.scatter(PA2[k1][::skip], PA2[k2][::skip], label='Astra', marker='x', alpha=0.5) plt.scatter(PI2[k1][::skip], PI2[k2][::skip], label='Impact', marker='.', alpha=0.5) plt.legend() In\u00a0[\u00a0]: Copied! <pre>PA2['sigma_x'], PI2['sigma_x']\n</pre> PA2['sigma_x'], PI2['sigma_x'] In\u00a0[\u00a0]: Copied! <pre>plt.hist(PA2['x'], bins=50, alpha=0.5, label='Astra')\nplt.hist(PI2['x'], bins=50, alpha=0.5, label='Impact')\nplt.legend()\n</pre> plt.hist(PA2['x'], bins=50, alpha=0.5, label='Astra') plt.hist(PI2['x'], bins=50, alpha=0.5, label='Impact') plt.legend() In\u00a0[\u00a0]: Copied! <pre>A2 = A.copy()\nA2.input['charge']['lspch'] = True\nA2.input['charge']['lspch3d'] = True\nA2.input['charge']['l2d_3d'] = False\nA2.input['charge']['nxf'] = 32\nA2.input['charge']['nyf'] = 32\nA2.input['charge']['nzf'] = 64\nA2.input['charge']['nx0'] = 4\nA2.input['charge']['ny0'] = 4\nA2.input['charge']['nz0'] = 4\nA2.configure()\nA2.run()\n</pre> A2 = A.copy() A2.input['charge']['lspch'] = True A2.input['charge']['lspch3d'] = True A2.input['charge']['l2d_3d'] = False A2.input['charge']['nxf'] = 32 A2.input['charge']['nyf'] = 32 A2.input['charge']['nzf'] = 64 A2.input['charge']['nx0'] = 4 A2.input['charge']['ny0'] = 4 A2.input['charge']['nz0'] = 4 A2.configure() A2.run() In\u00a0[\u00a0]: Copied! <pre>P2 = A2.particles[-1]\nP2.plot('x', 'px')\n</pre> P2 = A2.particles[-1] P2.plot('x', 'px') In\u00a0[\u00a0]: Copied! <pre>A2.archive('astra_cavity9_SC_3D.h5')\n</pre> A2.archive('astra_cavity9_SC_3D.h5') In\u00a0[\u00a0]: Copied! <pre># Compare these. \nkey1 = 'mean_z'\nkey2 = 'norm_emit_x'\nunits1 = str(A.units(key1))\nunits2 = str(A.units(key2))\nplt.xlabel(key1+f' ({units1})')\nplt.ylabel(key2+f' ({units2})')\nplt.plot(A.stat(key1), A.stat(key2), label='Astra 2D', color='red')\nplt.plot(A2.stat(key1), A2.stat(key2), label='Astra 3D', color='blue')\nplt.plot(I.stat(key1), I.stat(key2), '--', label='Impact-T', color='green')\n\nplt.scatter(A.particle_stat(key1), A.particle_stat(key2), color='red')\nplt.legend()\n#plt.scatter(A.particle_stat(key1, alive_only=False), A.particle_stat(key2, alive_only=False), color='green')\n</pre> # Compare these.  key1 = 'mean_z' key2 = 'norm_emit_x' units1 = str(A.units(key1)) units2 = str(A.units(key2)) plt.xlabel(key1+f' ({units1})') plt.ylabel(key2+f' ({units2})') plt.plot(A.stat(key1), A.stat(key2), label='Astra 2D', color='red') plt.plot(A2.stat(key1), A2.stat(key2), label='Astra 3D', color='blue') plt.plot(I.stat(key1), I.stat(key2), '--', label='Impact-T', color='green')  plt.scatter(A.particle_stat(key1), A.particle_stat(key2), color='red') plt.legend() #plt.scatter(A.particle_stat(key1, alive_only=False), A.particle_stat(key2, alive_only=False), color='green') In\u00a0[\u00a0]: Copied! <pre>k1 = 'x'\nk2 = 'px'\nskip = 10\nplt.title('Astra')\nplt.xlabel(k1)\nplt.ylabel(k2)\nplt.scatter(P[k1][::skip], P[k2][::skip], label='2d', marker='x', alpha=0.5)\nplt.scatter(P2[k1][::skip], P2[k2][::skip], label='3d', marker='.', alpha=0.5)\n\nplt.scatter(PI2[k1][::skip], PI2[k2][::skip], label='Impact', marker='.', alpha=0.5)\nplt.legend()\n</pre> k1 = 'x' k2 = 'px' skip = 10 plt.title('Astra') plt.xlabel(k1) plt.ylabel(k2) plt.scatter(P[k1][::skip], P[k2][::skip], label='2d', marker='x', alpha=0.5) plt.scatter(P2[k1][::skip], P2[k2][::skip], label='3d', marker='.', alpha=0.5)  plt.scatter(PI2[k1][::skip], PI2[k2][::skip], label='Impact', marker='.', alpha=0.5) plt.legend() In\u00a0[\u00a0]: Copied! <pre>k1 = 'x'\nk2 = 'px'\nskip = 1\nplt.scatter(P[k1][::skip], P[k2][::skip], label='2d', marker='x', alpha=0.5)\nplt.scatter(P2[k1][::skip], P2[k2][::skip], label='3d', marker='.', alpha=0.5)\nplt.legend()\n</pre> k1 = 'x' k2 = 'px' skip = 1 plt.scatter(P[k1][::skip], P[k2][::skip], label='2d', marker='x', alpha=0.5) plt.scatter(P2[k1][::skip], P2[k2][::skip], label='3d', marker='.', alpha=0.5) plt.legend() In\u00a0[\u00a0]: Copied! <pre>P['max_pz']/ P2['max_pz']\n</pre> P['max_pz']/ P2['max_pz'] In\u00a0[\u00a0]: Copied! <pre>from impact import Impact\nI = Impact()\nI.load_archive('impact_cavity9.h5')\n</pre> from impact import Impact I = Impact() I.load_archive('impact_cavity9.h5')"},{"location":"examples/elements/tesla_9cell_cavity/#tesla-9-cell-cavity","title":"TESLA 9-cell Cavity\u00b6","text":""},{"location":"examples/elements/tesla_9cell_cavity/#3d","title":"3D\u00b6","text":""},{"location":"examples/elements/tesla_9cell_cavity/#compare","title":"Compare\u00b6","text":""},{"location":"examples/elements/tesla_9cell_cavity/#compare-with-impact-t","title":"Compare with Impact-T\u00b6","text":""},{"location":"examples/elements/tws/","title":"TWS: Traveling Wave Structure","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>%pylab --no-import-all inline\n%config InlineBackend.figure_format = 'retina'\n</pre> %pylab --no-import-all inline %config InlineBackend.figure_format = 'retina' <pre>%pylab is deprecated, use %matplotlib inline and import the required libraries.\nPopulating the interactive namespace from numpy and matplotlib\n</pre> In\u00a0[3]: Copied! <pre>from astra import Astra, AstraGenerator\nfrom astra.fieldmaps import expand_tws_fmap\nimport os\n</pre> from astra import Astra, AstraGenerator from astra.fieldmaps import expand_tws_fmap import os In\u00a0[4]: Copied! <pre># Input template file \nASTRA_IN = '../templates/tws/astra.in'\nGENERATOR_IN = '../templates/tws/generator.in'\n</pre> # Input template file  ASTRA_IN = '../templates/tws/astra.in' GENERATOR_IN = '../templates/tws/generator.in' In\u00a0[5]: Copied! <pre>G = AstraGenerator(GENERATOR_IN)\nG.run()\nP0 = G.output['particles']\n</pre> G = AstraGenerator(GENERATOR_IN) G.run() P0 = G.output['particles'] In\u00a0[6]: Copied! <pre># Make an Astra object\nA = Astra(input_file=ASTRA_IN, initial_particles = P0, verbose=True)\n\n# Turn off space charge for this example\nA.input['charge']['lspch'] = False\n\n# This has a TWS cavity\nA.input['cavity']\n</pre> # Make an Astra object A = Astra(input_file=ASTRA_IN, initial_particles = P0, verbose=True)  # Turn off space charge for this example A.input['charge']['lspch'] = False  # This has a TWS cavity A.input['cavity'] <pre>Configured to run in: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp1xvos8w4\n</pre> Out[6]: <pre>{'lefield': True,\n 'file_efield(1)': '/Users/chrisonian/Code/GitHub/lume-astra/docs/examples/templates/tws/sonde_ideal_SF_100.dat',\n 'nue(1)': 2.99855,\n 'maxe(1)': 80,\n 'phi(1)': 0,\n 'c_pos(1)': 0,\n 'c_smooth(1)': 0,\n 'file_efield(2)': '/Users/chrisonian/Code/GitHub/lume-astra/docs/examples/templates/tws/tws.dat',\n 'nue(2)': 2.99855,\n 'maxe(2)': 14,\n 'phi(2)': 0,\n 'c_pos(2)': 1.528,\n 'c_smooth(2)': 0,\n 'c_numb(2)': 135}</pre> In\u00a0[7]: Copied! <pre># This is the fieldmap\nA.load_fieldmaps()\nfmap = A.fieldmap['tws.dat']\n\n# Attributes\nfmap['attrs']\n</pre> # This is the fieldmap A.load_fieldmaps() fmap = A.fieldmap['tws.dat']  # Attributes fmap['attrs'] <pre>Loading fieldmap file /Users/chrisonian/Code/GitHub/lume-astra/docs/examples/templates/tws/sonde_ideal_SF_100.dat\nLoading fieldmap file /Users/chrisonian/Code/GitHub/lume-astra/docs/examples/templates/tws/tws.dat\nLoading fieldmap file /Users/chrisonian/Code/GitHub/lume-astra/docs/examples/templates/tws/B3CV_23cm_sstilt.dat\n</pre> Out[7]: <pre>{'type': 'astra_tws', 'z1': 0.0463882, 'z2': 0.146368, 'n': 1, 'm': 3}</pre> In\u00a0[8]: Copied! <pre># Actual data \nfmap['data'].shape\n</pre> # Actual data  fmap['data'].shape Out[8]: <pre>(101, 2)</pre> In\u00a0[9]: Copied! <pre># This expands the data for 6 cells\nzfull, Ezfull = expand_tws_fmap(fmap, 6)\n\nplt.plot(zfull, Ezfull)\n</pre> # This expands the data for 6 cells zfull, Ezfull = expand_tws_fmap(fmap, 6)  plt.plot(zfull, Ezfull) Out[9]: <pre>[&lt;matplotlib.lines.Line2D at 0x12e7dfac0&gt;]</pre> In\u00a0[10]: Copied! <pre># Run\nA.run()\n</pre> # Run A.run() <pre>Initial particles written to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp1xvos8w4/astra.particles\n3 fieldmaps written to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp1xvos8w4\n --------------------------------------------------------------------------\n\n                Astra- A space charge tracking algorithm \n               Version 4.0 - macOS 64bit - Apple Silicon   \n                        DESY,  Hamburg 2022          \n                        Wed Aug  2 08:48:56 \n\n     Parameter file is:  astra.in                                          \n     TEST - LINAC - LIL                                                              \n\n Initialize element settings:\n     neglecting space charge forces \n\n --------------------------------------------------------------------------\n Cavity:\n\n     Reading cavity field data from:      sonde_ideal_SF_100.dat                                                          \n     Cavity Frequency               f =    2.999     GHz\n     maximum gradient                      80.00     MV/m\n     at                                   5.4000E-02 m\n     estimated average gradient            27.46     MV/m\n     nominal phase                         0.000     deg\n\n     Reading cavity field data from:      tws.dat                                                                         \n     Cavity Frequency               f =    2.999     GHz\n     beta = 1 traveling wave structure\n     TW Cell Length                        3.3327E-02 m\n     Number of Cells                       135\n     Phase Advance/Cell                     120.0     deg\n     TW Section starts at                   1.528     m\n     TW Section ends at                     6.120     m\n     Max E-field                            14.00     MV/m\n     at                                     1.675     m\n     nominal phase                          0.000     deg\n\n --------------------------------------------------------------------------\n Solenoid:\n\n     Reading solenoid field data from:    B3CV_23cm_sstilt.dat                                                            \n     maximum |Bz| field                    0.2500     T\n     at                                    0.2040     m\n     integral Bz squared                   8.0805E-03 T^2m\n\n --------------------------------------------------------------------------\n    1000 particles from file astra.particles                                   \n\n\n     Cathode located at:               z =      0.000     m\n     Particles taken into account      N =       1000\n     total charge                      Q =     -1.000     nC\n     horizontal beam position          x =     1.0140E-04 mm\n     vertical beam position            y =     7.4847E-05 mm\n     longitudinal beam position        z =      0.000     m\n     horizontal beam size          sig x =     0.5185     mm\n     vertical beam size            sig y =     0.5156     mm\n     longitudinal beam size        sig z =      0.000     mm\n     total emission time               t =     1.2621E-02 ns\n     rms emission time             sig t =     1.9926E-03 ns\n     average kinetic energy            E =     9.9997E-04 MeV\n     energy spread                    dE =     3.8783E-03 keV\n     average momentum                  P =     3.1984E-02 MeV/c\n     transverse beam emittance     eps x =      18.69     pi mrad mm\n     correlated divergence         cor x =    -3.2908E-02 mrad \n     transverse beam emittance     eps y =      18.61     pi mrad mm\n     correlated divergence         cor y =     2.3856E-02 mrad\n     longitudinal beam emittance   eps z =      0.000     pi keV mm\n     correlated energy spread      cor z =      0.000     keV\n     emittance ratio eps y/eps x         =      1.004    \n\n     WARNING: Bz is not zero at the cathode,\n     estimated emittance contribution: \n     eps x =   2.8776E-02 pi mrad mm\n     eps y =   2.8458E-02 pi mrad mm\n\n --------------------------------------------------------------------------\n     Start auto phasing: \n     Scan cavity number  :   1\n        6 unstable trajectories out of   50\n     Scan cavity number  :   2\n        0 unstable trajectories out of   50\n\n     Cavity phasing completed:\n     Cavity number   Energy gain [MeV]  at  Phase [deg]\n           1             5.380               46.221    \n           2             46.34               306.08    \n --------------------------------------------------------------------------\n on axis tracking of the reference particle:\n     initial position                  z =    0.000     m\n                                       x =   1.0140E-04 mm\n                                       y =   7.4847E-05 mm\n     initial momentum                  p =   1.6038E-02 MeV/c\n     global phase shift              phi =    0.000     deg\n     time step for integration        dt =    1.000     ps\n --------------------------------------------------------------------------\n Online element settings:\n\n --------------------------------------------------------------------------\n\n     particle reaches position         z =    6.200     m\n     time of flight is                 t =    20.73     ns\n     final momentum                    p =    52.23     MeV/c\n     final phase (cavity 1)      phi_end =    101.2     deg\n --------------------------------------------------------------------------\n off axis tracking of the reference particle: \n     initial position                  z =    0.000     m\n                                       x =   0.5186     mm\n                                       y =   0.5157     mm\n\n     final position                    x =    1.831     mm\n                                       y =   -2.459     mm\n     divergence                    px/pz =   0.3674     mrad\n                                   py/pz =  -0.4938     mrad\n --------------------------------------------------------------------------\n tracking of     1000 particles:\n     tracking will stop at             z =    6.200     m\n\n\n     final checkpoint at               z =    6.200     m\n     total number of iteration steps:         22023\n\n     **********************************************************************\n\n     Particles taken into account      N =       1000\n     total charge                      Q =     -1.000     nC\n     horizontal beam position          x =     6.3567E-04 mm\n     vertical beam position            y =    -8.9888E-04 mm\n     longitudinal beam position        z =      6.200     m\n     horizontal beam size          sig x =      2.534     mm\n     vertical beam size            sig y =      2.533     mm\n     longitudinal beam size        sig z =     0.5271     mm\n     average kinetic energy            E =      51.69     MeV\n     energy spread                    dE =      40.76     keV\n     average momentum                  P =      52.20     MeV/c\n     transverse beam emittance     eps x =      18.69     pi mrad mm\n     correlated divergence         cor x =     0.5528     mrad \n     transverse beam emittance     eps y =      18.72     pi mrad mm\n     correlated divergence         cor y =     0.5524     mrad\n     longitudinal beam emittance   eps z =      21.00     pi keV mm\n     correlated energy spread      cor z =      8.603     keV\n     emittance ratio eps y/eps x         =     0.9983    \n\n     Particle Statistics: \n\n\n     Total number of particles on stack     =       1000\n     Electrons (total)                      =       1000\n     particles at the cathode               =          0\n     active particles                       =       1000\n     passive particles (lost out of bunch)  =          0\n     probe particles                        =          6\n     backward traveling particles           =          0\n     particles lost with z&lt;Zmin             =          0\n     particles lost due to cathode field    =          0\n     particles lost on aperture             =          0\n\n     Tracking ended with     1 warning(s)\n\n\n     **********************************************************************\n\n     Emittance information saved to file    : astra.Xemit.001               \n     Emittance information saved to file    : astra.Yemit.001               \n     Emittance information saved to file    : astra.Zemit.001               \n     Lost &amp; found saved to file             : astra.LandF.001               \n     Phase-space distributions logged in    : astra.Log.001                 \n\n     **********************************************************************\n\n\n\n     finished simulation  Wed Aug  2 08:49:03 2023\n     elapsed time   :                 7.0 seconds \n     execution time :                 7.0 seconds \n     system time    :                 0.1 seconds\n     Goodbye.\n --------------------------------------------------------------------------\nloading 32 particle files\n[20.0, 41.0, 61.0, 82.0, 102.0, 120.0, 123.0, 143.0, 164.0, 184.0, 205.0, 225.0, 246.0, 266.0, 286.0, 307.0, 327.0, 348.0, 368.0, 389.0, 409.0, 430.0, 450.0, 471.0, 491.0, 511.0, 532.0, 552.0, 573.0, 593.0, 614.0, 620.0]\n{'start_time': 1690991336.888692, 'run_script': '/Users/chrisonian/Code/Astra/bin/Astra astra.in', 'run_time': 7.116514205932617}\n</pre> In\u00a0[11]: Copied! <pre>A.plot(y=['sigma_x', 'sigma_y'], y2='mean_kinetic_energy', xlim=(0,8), figsize=(16,9))\n</pre> A.plot(y=['sigma_x', 'sigma_y'], y2='mean_kinetic_energy', xlim=(0,8), figsize=(16,9)) In\u00a0[12]: Copied! <pre>P = A.particles[-1]\nP.plot('x', 'px')\nP.plot('z', 'pz')\n</pre> P = A.particles[-1] P.plot('x', 'px') P.plot('z', 'pz')"},{"location":"examples/elements/tws/#tws-traveling-wave-structure","title":"TWS: Traveling Wave Structure\u00b6","text":"<p>TWS are defined by special fieldmaps</p>"},{"location":"examples/interfaces/astra_to_bmad/","title":"Astra to Bmad interface","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n\n%pylab --no-import-all inline\n%config InlineBackend.figure_format = 'retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2  %pylab --no-import-all inline %config InlineBackend.figure_format = 'retina' <pre>%pylab is deprecated, use %matplotlib inline and import the required libraries.\nPopulating the interactive namespace from numpy and matplotlib\n</pre> In\u00a0[2]: Copied! <pre>from astra import Astra\n\nfrom astra.interfaces.bmad import bmad_cavity, bmad_solenoid\n\nfrom distgen import Generator\n\nimport os\n</pre> from astra import Astra  from astra.interfaces.bmad import bmad_cavity, bmad_solenoid  from distgen import Generator  import os In\u00a0[3]: Copied! <pre># Input template file \nASTRA_IN = '../templates/sc_inj/astra.in'\nDISTGEN_IN ='../templates/sc_inj/distgen.yaml'\n</pre> # Input template file  ASTRA_IN = '../templates/sc_inj/astra.in' DISTGEN_IN ='../templates/sc_inj/distgen.yaml' In\u00a0[4]: Copied! <pre>A = Astra(ASTRA_IN)\nA.load_fieldmaps()\nA.plot()\n</pre> A = Astra(ASTRA_IN) A.load_fieldmaps() A.plot() In\u00a0[5]: Copied! <pre>?bmad_cavity\n</pre> ?bmad_cavity In\u00a0[6]: Copied! <pre>from astra.fieldmaps import find_fieldmap_ixlist\n</pre> from astra.fieldmaps import find_fieldmap_ixlist In\u00a0[7]: Copied! <pre># Get indices for cavities\nixlist = sorted(find_fieldmap_ixlist(A.input, section='cavity'))\n\nline1 = bmad_cavity(A, 1, keyword='e_gun', ele_origin='beginning')['line']\n\nprint(line1)\n</pre> # Get indices for cavities ixlist = sorted(find_fieldmap_ixlist(A.input, section='cavity'))  line1 = bmad_cavity(A, 1, keyword='e_gun', ele_origin='beginning')['line']  print(line1) <pre>CAV1: e_gun,\n      rf_frequency = 187000000.0,\n      phi0 = -0.018321944444444446,\n      autoscale_amplitude = False,\n      field_autoscale = 20040000.0,\n      L = 0.199,\n      offset = 0,\n      superimpose = True,\n      ele_origin = beginning\n</pre> In\u00a0[8]: Copied! <pre># The remaining are LCAVITY elements\nfor ix in ixlist:\n    print(bmad_cavity(A, ix)['line'], '\\n')\n</pre> # The remaining are LCAVITY elements for ix in ixlist:     print(bmad_cavity(A, ix)['line'], '\\n') <pre>CAV1: lcavity,\n      rf_frequency = 187000000.0,\n      phi0 = -0.018321944444444446,\n      autoscale_amplitude = False,\n      field_autoscale = 20040000.0,\n      L = 0.199,\n      offset = 0,\n      superimpose = True,\n      ele_origin = center \n\nCAV2: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = -0.22298472222222224,\n      autoscale_amplitude = False,\n      field_autoscale = 1794200.0,\n      L = 0.358133,\n      offset = 0.809116,\n      superimpose = True,\n      ele_origin = center \n\nCAV3: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = -0.011111111111111112,\n      autoscale_amplitude = False,\n      field_autoscale = 15800000.0,\n      L = 1.318798,\n      offset = 3.3428,\n      superimpose = True,\n      ele_origin = center \n\nCAV4: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = 0.0,\n      voltage = 0,\n      L = 1.318798,\n      offset = 4.7264,\n      superimpose = True,\n      ele_origin = center \n\nCAV5: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = 0.0,\n      voltage = 0,\n      L = 1.318798,\n      offset = 6.11,\n      superimpose = True,\n      ele_origin = center \n\nCAV6: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = 0.0,\n      autoscale_amplitude = False,\n      field_autoscale = 28000000.0,\n      L = 1.318798,\n      offset = 7.4936,\n      superimpose = True,\n      ele_origin = center \n\nCAV7: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = 0.0,\n      autoscale_amplitude = False,\n      field_autoscale = 32000000.0,\n      L = 1.318798,\n      offset = 8.8772,\n      superimpose = True,\n      ele_origin = center \n\nCAV8: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = 0.0,\n      autoscale_amplitude = False,\n      field_autoscale = 32000000.0,\n      L = 1.318798,\n      offset = 10.2608,\n      superimpose = True,\n      ele_origin = center \n\nCAV9: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = 0.003472222222222222,\n      autoscale_amplitude = False,\n      field_autoscale = 32000000.0,\n      L = 1.318798,\n      offset = 11.6444,\n      superimpose = True,\n      ele_origin = center \n\nCAV10: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = 0.016666666666666666,\n      autoscale_amplitude = False,\n      field_autoscale = 32000000.0,\n      L = 1.318798,\n      offset = 13.028,\n      superimpose = True,\n      ele_origin = center \n\n</pre> In\u00a0[9]: Copied! <pre># Solenoids\nixlist2 = sorted(find_fieldmap_ixlist(A.input, section='solenoid'))\n\nfor ix in ixlist2:\n    print(bmad_solenoid(A, ix)['line']  )\n</pre> # Solenoids ixlist2 = sorted(find_fieldmap_ixlist(A.input, section='solenoid'))  for ix in ixlist2:     print(bmad_solenoid(A, ix)['line']  ) <pre>SOL1: solenoid,\n  ! B_max = 0 T\n! \\int B dL = B_max * 0.11722587420824254 m\n! \\int B^2 dL = B_max^2 * 0.08506403768280266 m\n! Hard edge L = 0.16154776987108496 m\n! Hard edge B = 0.0 T,\n      L = 0.5,\n      superimpose = True,\n      ele_origin = center,\n      offset = -0.062\nSOL2: solenoid,\n  ! B_max = 0.057 T\n! \\int B dL = B_max * 0.12896517423475376 m\n! \\int B^2 dL = B_max^2 * 0.08623994625099243 m\n! Hard edge L = 0.19285745050205194 m\n! Hard edge B = 0.03811631291528844 T,\n      L = 0.48,\n      superimpose = True,\n      ele_origin = center,\n      offset = 0.24653\nSOL3: solenoid,\n  ! B_max = 0.0322 T\n! \\int B dL = B_max * 0.12896517423475376 m\n! \\int B^2 dL = B_max^2 * 0.08623994625099243 m\n! Hard edge L = 0.19285745050205194 m\n! Hard edge B = 0.02153237326091733 T,\n      L = 0.48,\n      superimpose = True,\n      ele_origin = center,\n      offset = 1.64581\n</pre> In\u00a0[10]: Copied! <pre>def bmad_lattice(astra_object):\n\n    lines = []\n    \n    zendlist = []\n    \n        # Cavities\n    ixlist = sorted(find_fieldmap_ixlist(astra_object.input, section='cavity'))\n    for ix in ixlist:\n        dat = bmad_cavity(astra_object, ix)\n        #zendlist.append(dat['z_end'])\n        line = dat['line']\n        lines.append(line)\n        \n    # Solenoids\n    ixlist = sorted(find_fieldmap_ixlist(astra_object.input, section='solenoid'))\n    for ix in ixlist:\n        dat = bmad_solenoid(astra_object, ix)\n        #zendlist.append(dat['z_end'])\n        line = dat['line']\n        lines.append(line)        \n        \n        \n        \n    # drift:\n    #zmax = max(zendlist) + 0.01 # Pad a little\n    lines.append(f\"\"\"\ndrift0: drift, L = {np.round(10, 9)}\n\nlat: line = (drift0)\n\n\"\"\")\n    \n    return '\\n\\n'.join(lines)\nprint(bmad_lattice(A))\n</pre> def bmad_lattice(astra_object):      lines = []          zendlist = []              # Cavities     ixlist = sorted(find_fieldmap_ixlist(astra_object.input, section='cavity'))     for ix in ixlist:         dat = bmad_cavity(astra_object, ix)         #zendlist.append(dat['z_end'])         line = dat['line']         lines.append(line)              # Solenoids     ixlist = sorted(find_fieldmap_ixlist(astra_object.input, section='solenoid'))     for ix in ixlist:         dat = bmad_solenoid(astra_object, ix)         #zendlist.append(dat['z_end'])         line = dat['line']         lines.append(line)                                        # drift:     #zmax = max(zendlist) + 0.01 # Pad a little     lines.append(f\"\"\" drift0: drift, L = {np.round(10, 9)}  lat: line = (drift0)  \"\"\")          return '\\n\\n'.join(lines) print(bmad_lattice(A))             <pre>CAV1: lcavity,\n      rf_frequency = 187000000.0,\n      phi0 = -0.018321944444444446,\n      autoscale_amplitude = False,\n      field_autoscale = 20040000.0,\n      L = 0.199,\n      offset = 0,\n      superimpose = True,\n      ele_origin = center\n\nCAV2: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = -0.22298472222222224,\n      autoscale_amplitude = False,\n      field_autoscale = 1794200.0,\n      L = 0.358133,\n      offset = 0.809116,\n      superimpose = True,\n      ele_origin = center\n\nCAV3: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = -0.011111111111111112,\n      autoscale_amplitude = False,\n      field_autoscale = 15800000.0,\n      L = 1.318798,\n      offset = 3.3428,\n      superimpose = True,\n      ele_origin = center\n\nCAV4: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = 0.0,\n      voltage = 0,\n      L = 1.318798,\n      offset = 4.7264,\n      superimpose = True,\n      ele_origin = center\n\nCAV5: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = 0.0,\n      voltage = 0,\n      L = 1.318798,\n      offset = 6.11,\n      superimpose = True,\n      ele_origin = center\n\nCAV6: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = 0.0,\n      autoscale_amplitude = False,\n      field_autoscale = 28000000.0,\n      L = 1.318798,\n      offset = 7.4936,\n      superimpose = True,\n      ele_origin = center\n\nCAV7: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = 0.0,\n      autoscale_amplitude = False,\n      field_autoscale = 32000000.0,\n      L = 1.318798,\n      offset = 8.8772,\n      superimpose = True,\n      ele_origin = center\n\nCAV8: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = 0.0,\n      autoscale_amplitude = False,\n      field_autoscale = 32000000.0,\n      L = 1.318798,\n      offset = 10.2608,\n      superimpose = True,\n      ele_origin = center\n\nCAV9: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = 0.003472222222222222,\n      autoscale_amplitude = False,\n      field_autoscale = 32000000.0,\n      L = 1.318798,\n      offset = 11.6444,\n      superimpose = True,\n      ele_origin = center\n\nCAV10: lcavity,\n      rf_frequency = 1300000000.0,\n      phi0 = 0.016666666666666666,\n      autoscale_amplitude = False,\n      field_autoscale = 32000000.0,\n      L = 1.318798,\n      offset = 13.028,\n      superimpose = True,\n      ele_origin = center\n\nSOL1: solenoid,\n  ! B_max = 0 T\n! \\int B dL = B_max * 0.11722587420824254 m\n! \\int B^2 dL = B_max^2 * 0.08506403768280266 m\n! Hard edge L = 0.16154776987108496 m\n! Hard edge B = 0.0 T,\n      L = 0.5,\n      superimpose = True,\n      ele_origin = center,\n      offset = -0.062\n\nSOL2: solenoid,\n  ! B_max = 0.057 T\n! \\int B dL = B_max * 0.12896517423475376 m\n! \\int B^2 dL = B_max^2 * 0.08623994625099243 m\n! Hard edge L = 0.19285745050205194 m\n! Hard edge B = 0.03811631291528844 T,\n      L = 0.48,\n      superimpose = True,\n      ele_origin = center,\n      offset = 0.24653\n\nSOL3: solenoid,\n  ! B_max = 0.0322 T\n! \\int B dL = B_max * 0.12896517423475376 m\n! \\int B^2 dL = B_max^2 * 0.08623994625099243 m\n! Hard edge L = 0.19285745050205194 m\n! Hard edge B = 0.02153237326091733 T,\n      L = 0.48,\n      superimpose = True,\n      ele_origin = center,\n      offset = 1.64581\n\n\ndrift0: drift, L = 10\n\nlat: line = (drift0)\n\n\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/interfaces/astra_to_bmad/#astra-to-bmad-interface","title":"Astra to Bmad interface\u00b6","text":""},{"location":"examples/interfaces/astra_to_bmad/#cavities","title":"Cavities\u00b6","text":""},{"location":"examples/interfaces/astra_to_bmad/#solenoids","title":"Solenoids\u00b6","text":""},{"location":"examples/interfaces/astra_to_bmad/#full-lattice","title":"Full lattice\u00b6","text":""},{"location":"examples/interfaces/bmad_to_astra/","title":"Bmad to Astra interface","text":"In\u00a0[1]: Copied! <pre>from astra import Astra\nfrom pytao import Tao\nimport matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\n</pre> from astra import Astra from pytao import Tao import matplotlib.pyplot as plt %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>LAT = \"\"\"\nno_digested\nbeginning[beta_a] = 10\nbeginning[beta_b] = 10\nbeginning[e_tot] = 10e6\nparameter[particle] = electron\nparameter[geometry] = open\n\nd1: drift, L = 1\nd2: d1\nqf: quad, L = 0.1, k1 = 1\nqd: qf, k1 = -1\n\nfodo: line = (d1, qf, d2, qd)\n\nlat: line = (2*fodo)\n\nuse, lat\n\n\"\"\"\nLATFILE = 'lat.bmad'\nwith open(LATFILE, 'w') as f:\n    f.write(LAT)\n</pre> LAT = \"\"\" no_digested beginning[beta_a] = 10 beginning[beta_b] = 10 beginning[e_tot] = 10e6 parameter[particle] = electron parameter[geometry] = open  d1: drift, L = 1 d2: d1 qf: quad, L = 0.1, k1 = 1 qd: qf, k1 = -1  fodo: line = (d1, qf, d2, qd)  lat: line = (2*fodo)  use, lat  \"\"\" LATFILE = 'lat.bmad' with open(LATFILE, 'w') as f:     f.write(LAT) In\u00a0[3]: Copied! <pre>tao = Tao(f'-lat {LATFILE} -noplot')\ntao.cmd('set particle_start x = 1e-3')\n</pre> tao = Tao(f'-lat {LATFILE} -noplot') tao.cmd('set particle_start x = 1e-3') Out[3]: <pre>[]</pre> In\u00a0[4]: Copied! <pre>A = Astra.from_tao(tao)\n#A.input['output']['zstop'] = 10\n\nA.track1(x0=1e-3, pz0=10e6)\n</pre> A = Astra.from_tao(tao) #A.input['output']['zstop'] = 10  A.track1(x0=1e-3, pz0=10e6) <pre>Note: The following floating-point exceptions are signalling: IEEE_DIVIDE_BY_ZERO IEEE_UNDERFLOW_FLAG\n</pre> Out[4]: <pre>&lt;ParticleGroup with 1 particles at 0x135dafac0&gt;</pre> In\u00a0[5]: Copied! <pre>A.plot('mean_x')\n</pre> A.plot('mean_x') In\u00a0[6]: Copied! <pre>s1 = tao.lat_list('*', 'ele.s')\nx1 = tao.lat_list('*', 'orbit.vec.1')\n\nz2 = A.stat('mean_z')\nx2 = A.stat('mean_x')\n\nfix, ax = plt.subplots()\nax.plot(s1, x1*1e3, marker='.', label='Bmad', color='blue')\nax.plot(z2, x2*1e3,  label='Astra', color='red')\nplt.legend()\nax.set_xlabel(r'$z$ (m)')\nax.set_ylabel(r'$x$ (mm)')\n</pre> s1 = tao.lat_list('*', 'ele.s') x1 = tao.lat_list('*', 'orbit.vec.1')  z2 = A.stat('mean_z') x2 = A.stat('mean_x')  fix, ax = plt.subplots() ax.plot(s1, x1*1e3, marker='.', label='Bmad', color='blue') ax.plot(z2, x2*1e3,  label='Astra', color='red') plt.legend() ax.set_xlabel(r'$z$ (m)') ax.set_ylabel(r'$x$ (mm)') Out[6]: <pre>Text(0, 0.5, '$x$ (mm)')</pre> In\u00a0[7]: Copied! <pre>import os\nos.remove(LATFILE)\n</pre> import os os.remove(LATFILE)"},{"location":"examples/interfaces/bmad_to_astra/#bmad-to-astra-interface","title":"Bmad to Astra interface\u00b6","text":"<p>PyTao, based on Bmad, can be used to create an Astra lattice. This is a simple example of a FODO lattice in Bmad, converted to Astra</p>"},{"location":"examples/interfaces/bmad_to_astra/#create-bmad-lattice","title":"Create Bmad lattice\u00b6","text":""},{"location":"examples/interfaces/bmad_to_astra/#astra-from-tao","title":"Astra from Tao\u00b6","text":""},{"location":"examples/interfaces/bmad_to_astra/#compare","title":"Compare\u00b6","text":""},{"location":"examples/interfaces/bmad_to_astra/#cleanup","title":"Cleanup\u00b6","text":""},{"location":"examples/templates/apex_gun/apex_gun/","title":"APEX Gun","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\nimport matplotlib\nmatplotlib.rcParams['figure.figsize'] = (6,6)\n%config InlineBackend.figure_format = 'retina'\n</pre> import matplotlib.pyplot as plt import matplotlib matplotlib.rcParams['figure.figsize'] = (6,6) %config InlineBackend.figure_format = 'retina' In\u00a0[3]: Copied! <pre>from distgen import Generator\n\nG = Generator('distgen_laser.yaml')\nG['n_particle'] = 10000\nG\n</pre> from distgen import Generator  G = Generator('distgen_laser.yaml') G['n_particle'] = 10000 G Out[3]: <pre>&lt;disgten.Generator with input: \nn_particle: 10000\noutput:\n  type: null\nrandom_type: hammersley\nstart:\n  MTE:\n    units: millielectron_volt\n    value: 250.0\n  type: cathode\nt_dist:\n  avg_t:\n    units: picosecond\n    value: 0.0\n  n_sigma_cutoff: 3\n  sigma_t:\n    units: picosecond\n    value: 8.5\n  type: gaussian\ntotal_charge:\n  units: picocoulomb\n  value: 10.0\ntransforms: null\nxy_dist:\n  file: /Users/chrisonian/Code/GitHub/lume-astra/docs/examples/templates/apex_gun/2019_11_04_135614reg_out.txt\n  type: file2d\n\n&gt;</pre> In\u00a0[4]: Copied! <pre>G.run()\nG.particles\n</pre> G.run() G.particles Out[4]: <pre>&lt;ParticleGroup with 10000 particles at 0x15ab04130&gt;</pre> In\u00a0[5]: Copied! <pre>fig = G.particles.plot('x', 'y', bins=256, return_figure=True)\nplt.savefig('distgen-laser.png', dpi=150, bbox_inches='tight')\n</pre> fig = G.particles.plot('x', 'y', bins=256, return_figure=True) plt.savefig('distgen-laser.png', dpi=150, bbox_inches='tight') In\u00a0[6]: Copied! <pre>G.particles.write_astra('astra.particles')\n</pre> G.particles.write_astra('astra.particles') In\u00a0[7]: Copied! <pre>from astra import Astra\n</pre> from astra import Astra In\u00a0[8]: Copied! <pre>A = Astra('astra.in', initial_particles=G.particles)\n</pre> A = Astra('astra.in', initial_particles=G.particles) In\u00a0[9]: Copied! <pre># Turn space charge off\n#A.input['charge']['lspch'] = False \nA.verbose=False\n</pre> # Turn space charge off #A.input['charge']['lspch'] = False  A.verbose=False In\u00a0[10]: Copied! <pre>A.run()\n</pre> A.run() In\u00a0[11]: Copied! <pre>A.output.keys()\n</pre> A.output.keys() Out[11]: <pre>dict_keys(['stats', 'particles', 'run_info', 'other'])</pre> In\u00a0[12]: Copied! <pre>fig = A.plot(y=['norm_emit_x', 'norm_emit_y'], y2=['sigma_x', 'sigma_y'], xlim=(1e-3,.6), ylim=(0, 40e-6), ylim2=(0, 1800e-6),figsize=(6,6), return_figure=True)\n#fig.axes[0].set_title('LUME-Astra')\nplt.savefig('apex-gun-lume-astra.png', dpi=150, bbox_inches='tight')\n</pre> fig = A.plot(y=['norm_emit_x', 'norm_emit_y'], y2=['sigma_x', 'sigma_y'], xlim=(1e-3,.6), ylim=(0, 40e-6), ylim2=(0, 1800e-6),figsize=(6,6), return_figure=True) #fig.axes[0].set_title('LUME-Astra') plt.savefig('apex-gun-lume-astra.png', dpi=150, bbox_inches='tight') In\u00a0[13]: Copied! <pre>A.plot('sigma_z')\n</pre>  A.plot('sigma_z') In\u00a0[14]: Copied! <pre>A.particles[-1].plot('x', 'y', bins=50)\n</pre> A.particles[-1].plot('x', 'y', bins=50) In\u00a0[15]: Copied! <pre># A.archive()\n</pre> # A.archive()"},{"location":"examples/templates/apex_gun/apex_gun/#apex-gun","title":"APEX Gun\u00b6","text":""},{"location":"examples/templates/sc_inj/sc_inj/","title":"Sc inj","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from astra import Astra\n\nfrom ipywidgets import interact\n\n\nimport matplotlib.pyplot as plt\nimport matplotlib\nmatplotlib.rcParams['figure.figsize'] = (12,8)\n%config InlineBackend.figure_format = 'retina'\n</pre> from astra import Astra  from ipywidgets import interact   import matplotlib.pyplot as plt import matplotlib matplotlib.rcParams['figure.figsize'] = (12,8) %config InlineBackend.figure_format = 'retina' In\u00a0[3]: Copied! <pre>A = Astra.from_yaml('astra.yaml')\n</pre> A = Astra.from_yaml('astra.yaml') In\u00a0[4]: Copied! <pre>A.plot()\n</pre> A.plot() In\u00a0[5]: Copied! <pre>A['cryomodule:offset'] = 2\nA.plot()\n</pre> A['cryomodule:offset'] = 2 A.plot() In\u00a0[23]: Copied! <pre>\n</pre> <pre>interactive(children=(FloatSlider(value=1.0, description='x', max=3.0, step=0.01), Output()), _dom_classes=('w\u2026</pre> Out[23]: <pre>&lt;function __main__.f(x)&gt;</pre> In\u00a0[6]: Copied! <pre>from ipywidgets import interact, interactive\n\ndef f(x):\n    A['cryomodule:offset'] = x\n    A.plot(xlim=(0,20))\niplot = interactive(f, x=(0,3, .01))\nout = iplot.children[-1]\nout.layout.height='350px'\niplot\n</pre> from ipywidgets import interact, interactive  def f(x):     A['cryomodule:offset'] = x     A.plot(xlim=(0,20)) iplot = interactive(f, x=(0,3, .01)) out = iplot.children[-1] out.layout.height='350px' iplot Out[6]: In\u00a0[7]: Copied! <pre>from astra.astra_distgen import run_astra_with_distgen, evaluate_astra_with_distgen\n</pre> from astra.astra_distgen import run_astra_with_distgen, evaluate_astra_with_distgen In\u00a0[8]: Copied! <pre>A.input['output']\n</pre> A.input['output'] Out[8]: <pre>{'zstart': 0,\n 'zstop': 15,\n 'zemit': 1000,\n 'zphase': 1,\n 'screen(1)': 1.490314,\n 'screen(2)': 3.862,\n 'screen(3)': 5.245,\n 'screen(4)': 6.629,\n 'lmagnetized': True,\n 'lsub_rot': False,\n 'lproject_emit': False,\n 'larmors': False,\n 'emits': True,\n 'c_emits': True,\n 'landfs': True,\n 'phases': True,\n 'tracks': True,\n 'refs': True,\n 'tchecks': False,\n 'cathodes': True,\n 'high_res': True}</pre> In\u00a0[9]: Copied! <pre>settings = {'zstop':15, 'lspch':False, 'distgen:n_particle':100, 'cryomodule:offset':2}\nA2 = run_astra_with_distgen(settings, astra_input_file='astra.yaml', distgen_input_file='distgen.yaml', verbose=False)\n</pre> settings = {'zstop':15, 'lspch':False, 'distgen:n_particle':100, 'cryomodule:offset':2} A2 = run_astra_with_distgen(settings, astra_input_file='astra.yaml', distgen_input_file='distgen.yaml', verbose=False) In\u00a0[10]: Copied! <pre>A2.plot()\n</pre> A2.plot() In\u00a0[11]: Copied! <pre>evaluate_astra_with_distgen(settings, astra_input_file='astra.yaml', distgen_input_file='distgen.yaml', verbose=False)\n</pre> evaluate_astra_with_distgen(settings, astra_input_file='astra.yaml', distgen_input_file='distgen.yaml', verbose=False) Out[11]: <pre>{'error': False,\n 'end_mean_z': 15.0,\n 'end_norm_emit_x': 1.0064999999999998e-06,\n 'end_core_emit_95percent_x': 7.7815e-07,\n 'end_core_emit_90percent_x': 6.2095e-07,\n 'end_core_emit_80percent_x': 3.8185e-07,\n 'end_norm_emit_y': 1.0522e-06,\n 'end_core_emit_95percent_y': 7.7734e-07,\n 'end_core_emit_90percent_y': 6.2248e-07,\n 'end_core_emit_80percent_y': 3.9852999999999996e-07,\n 'end_norm_emit_z': 4307.9,\n 'end_core_emit_95percent_z': 0.0027501999999999995,\n 'end_core_emit_905percent_z': 0.0020096,\n 'end_core_emit_80percent_z': 0.001339,\n 'end_mean_t': 5.1570000000000005e-08,\n 'end_mean_x': 2.5044e-07,\n 'end_sigma_x': 0.00025459,\n 'end_sigma_xp': 0.00014366000000000002,\n 'end_cov_x__xp': -3.6062673500000004e-08,\n 'end_mean_y': 3.4249e-07,\n 'end_sigma_y': 0.00025444,\n 'end_sigma_yp': 0.000144,\n 'end_cov_y__yp': -3.6082136399999996e-08,\n 'end_mean_kinetic_energy': 83868000.0,\n 'end_sigma_z': 0.004772800000000001,\n 'end_sigma_energy': 938400.0,\n 'end_cov_z__energy': 1225.4164,\n 'end_n_particle_loss': 0,\n 'end_total_charge': 9.999999999999998e-11,\n 'end_higher_order_energy_spread': 10402.523234832583,\n 'fingerprint': '04d03422e1bec1866d5ef56ac436b6a8'}</pre> In\u00a0[12]: Copied! <pre># Double check this\nafile = A2.archive()\nA3 = Astra.from_archive(afile)\nA3.plot()\n</pre> # Double check this afile = A2.archive() A3 = Astra.from_archive(afile) A3.plot() In\u00a0[13]: Copied! <pre>from ipywidgets import interact\n\ndef f(x):\n    A['cryomodule:offset'] = x\n    A.plot(xlim=(0,20))\ninteract(f, x=(0,3, .01));\n</pre> from ipywidgets import interact  def f(x):     A['cryomodule:offset'] = x     A.plot(xlim=(0,20)) interact(f, x=(0,3, .01));"}]}