{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"lume-astra Python wrapper for Astra (A Space Charge Tracking Algorithm, DESY) for use in LUME Astra website Installing lume-astra Installing lume-astra from the conda-forge channel can be achieved by adding conda-forge to your channels with: conda config --add channels conda-forge Once the conda-forge channel has been enabled, lume-astra can be installed with: conda install lume-astra It is possible to list all of the versions of lume-astra available on your platform with: conda search lume-astra --channel conda-forge Installing Astra Executables For convenience, you can set $ASTRA_BIN and $GENERATOR_BIN to point to the Astra and generator binaries for your system. See the install_astra.ipynb example for easy installation. Basic usage See simple_astra_run.ipynb . In short: from astra import Astra A = Astra ( '../templates/Astra.in' ) A . verbose = True A . run () ... output = A . output","title":"Home"},{"location":"#lume-astra","text":"Python wrapper for Astra (A Space Charge Tracking Algorithm, DESY) for use in LUME Astra website","title":"lume-astra"},{"location":"#installing-lume-astra","text":"Installing lume-astra from the conda-forge channel can be achieved by adding conda-forge to your channels with: conda config --add channels conda-forge Once the conda-forge channel has been enabled, lume-astra can be installed with: conda install lume-astra It is possible to list all of the versions of lume-astra available on your platform with: conda search lume-astra --channel conda-forge","title":"Installing lume-astra"},{"location":"#installing-astra-executables","text":"For convenience, you can set $ASTRA_BIN and $GENERATOR_BIN to point to the Astra and generator binaries for your system. See the install_astra.ipynb example for easy installation.","title":"Installing Astra Executables"},{"location":"#basic-usage","text":"See simple_astra_run.ipynb . In short: from astra import Astra A = Astra ( '../templates/Astra.in' ) A . verbose = True A . run () ... output = A . output","title":"Basic usage"},{"location":"api/astra/","text":"astra.astra Astra Astra simulation object. Essential methods: . init (...) .configure() .run() Input deck is held in .input Output data is parsed into .output .load_particles() will load particle data into .output 'particles' The Astra binary file can be set on init. If it doesn't exist, configure will check the $ASTRA_BIN environmental variable. add_group ( self , name , ** kwargs ) Add a control group. See control.py Parameters: Name Type Description Default name str The group name required Source code in astra/astra.py def add_group ( self , name , ** kwargs ): \"\"\" Add a control group. See control.py Parameters ---------- name : str The group name \"\"\" assert name not in self . input , f ' { name } not allowed to be overwritten by group.' if name in self . group : self . vprint ( f 'Warning: group { name } already exists, overwriting.' ) g = ControlGroup ( ** kwargs ) g . link ( self . input ) self . group [ name ] = g return self . group [ name ] archive ( self , h5 = None ) Archive all data to an h5 handle or filename. If no file is given, a file based on the fingerprint will be created. Source code in astra/astra.py def archive ( self , h5 = None ): \"\"\" Archive all data to an h5 handle or filename. If no file is given, a file based on the fingerprint will be created. \"\"\" if not h5 : h5 = 'astra_' + self . fingerprint () + '.h5' if isinstance ( h5 , str ): h5 = os . path . expandvars ( h5 ) g = h5py . File ( h5 , 'w' ) self . vprint ( f 'Archiving to file { h5 } ' ) else : # store directly in the given h5 handle g = h5 # Write basic attributes archive . astra_init ( g ) # Initial particles if self . initial_particles : self . initial_particles . write ( g , name = 'initial_particles' ) # Fieldmaps if self . fieldmap : archive . write_fieldmap_h5 ( g , self . fieldmap , name = 'fieldmap' ) # All input archive . write_input_h5 ( g , self . input ) # All output archive . write_output_h5 ( g , self . output ) # Control groups if self . group : archive . write_control_groups_h5 ( g , self . group , name = 'control_groups' ) return h5 copy ( self ) Returns a deep copy of this object. If a tempdir is being used, will clear this and deconfigure. Source code in astra/astra.py def copy ( self ): \"\"\" Returns a deep copy of this object. If a tempdir is being used, will clear this and deconfigure. \"\"\" A2 = deepcopy ( self ) # Clear this if A2 . use_tempdir : A2 . path = None A2 . configured = False return A2 fingerprint ( self ) Data fingerprint using the input. Source code in astra/astra.py def fingerprint ( self ): \"\"\" Data fingerprint using the input. \"\"\" return tools . fingerprint ( self . input ) from_archive ( archive_h5 ) classmethod Class method to return an GPT object loaded from an archive file Source code in astra/astra.py @classmethod def from_archive ( cls , archive_h5 ): \"\"\" Class method to return an GPT object loaded from an archive file \"\"\" c = cls () c . load_archive ( archive_h5 ) return c from_yaml ( yaml_file ) classmethod Returns an Astra object instantiated from a YAML config file Will load intial_particles from an h5 file. Source code in astra/astra.py @classmethod def from_yaml ( cls , yaml_file ): \"\"\" Returns an Astra object instantiated from a YAML config file Will load intial_particles from an h5 file. \"\"\" # Try file if os . path . exists ( os . path . expandvars ( yaml_file )): config = yaml . safe_load ( open ( yaml_file )) # The input file might be relative to the yaml file if 'input_file' in config : f = os . path . expandvars ( config [ 'input_file' ]) if not os . path . isabs ( f ): # Get the yaml file root root , _ = os . path . split ( tools . full_path ( yaml_file )) config [ 'input_file' ] = os . path . join ( root , f ) else : #Try raw string config = yaml . safe_load ( yaml_file ) # Form ParticleGroup from file if 'initial_particles' in config : f = config [ 'initial_particles' ] if not os . path . isabs ( f ): root , _ = os . path . split ( tools . full_path ( yaml_file )) f = os . path . join ( root , f ) config [ 'initial_particles' ] = ParticleGroup ( f ) return cls ( ** config ) get_run_script ( self , write_to_path = True ) Assembles the run script. Optionally writes a file 'run' with this line to path. This expect to run with .path as the cwd. Source code in astra/astra.py def get_run_script ( self , write_to_path = True ): \"\"\" Assembles the run script. Optionally writes a file 'run' with this line to path. This expect to run with .path as the cwd. \"\"\" _ , infile = os . path . split ( self . input_file ) # Expect to run locally. Astra has problems with long paths. runscript = [ self . astra_bin , infile ] if write_to_path : with open ( os . path . join ( self . path , 'run' ), 'w' ) as f : f . write ( ' ' . join ( runscript )) return runscript load_archive ( self , h5 = None ) Loads input and output from archived h5 file. See: Astra.archive Source code in astra/astra.py def load_archive ( self , h5 = None ): \"\"\" Loads input and output from archived h5 file. See: Astra.archive \"\"\" if isinstance ( h5 , str ): h5 = os . path . expandvars ( h5 ) g = h5py . File ( h5 , 'r' ) glist = archive . find_astra_archives ( g ) n = len ( glist ) if n == 0 : # legacy: try top level message = 'legacy' elif n == 1 : gname = glist [ 0 ] message = f 'group { gname } from' g = g [ gname ] else : raise ValueError ( f 'Multiple archives found in file { h5 } : { glist } ' ) self . vprint ( f 'Reading { message } archive file { h5 } ' ) else : g = h5 self . input = archive . read_input_h5 ( g [ 'input' ]) self . output = archive . read_output_h5 ( g [ 'output' ]) if 'initial_particles' in g : self . initial_particles = ParticleGroup ( h5 = g [ 'initial_particles' ]) if 'fieldmap' in g : self . fieldmap = archive . read_fieldmap_h5 ( g [ 'fieldmap' ]) if 'control_groups' in g : self . group = archive . read_control_groups_h5 ( g [ 'control_groups' ], verbose = self . verbose ) self . vprint ( 'Loaded from archive. Note: Must reconfigure to run again.' ) self . configured = False # Re-link groups # TODO: cleaner logic for _ , cg in self . group . items (): cg . link ( self . input ) load_fieldmaps ( self , search_paths = []) Loads fieldmaps into Astra.fieldmap as a dict. Optionally, a list of paths can be included that will search for these. The default will search self.path. Source code in astra/astra.py def load_fieldmaps ( self , search_paths = []): \"\"\" Loads fieldmaps into Astra.fieldmap as a dict. Optionally, a list of paths can be included that will search for these. The default will search self.path. \"\"\" # Do not consider files if fieldmaps have been loaded. if self . fieldmap : strip_path = False else : strip_path = True if not search_paths : [ self . path ] self . fieldmap = load_fieldmaps ( self . input , fieldmap_dict = self . fieldmap , search_paths = search_paths , verbose = self . verbose , strip_path = strip_path ) load_initial_particles ( self , h5 ) Loads a openPMD-beamphysics particle h5 handle or file Source code in astra/astra.py def load_initial_particles ( self , h5 ): \"\"\"Loads a openPMD-beamphysics particle h5 handle or file\"\"\" P = ParticleGroup ( h5 = h5 ) self . initial_particles = P load_output ( self , include_particles = True ) Loads Astra output files into .output .output is a dict with dicts: .stats .run_info .other and if include_particles, .particles = list of ParticleGroup objects Source code in astra/astra.py def load_output ( self , include_particles = True ): \"\"\" Loads Astra output files into .output .output is a dict with dicts: .stats .run_info .other and if include_particles, .particles = list of ParticleGroup objects \"\"\" run_number = parsers . astra_run_extension ( self . input [ 'newrun' ][ 'run' ]) outfiles = parsers . find_astra_output_files ( self . input_file , run_number ) #assert len(outfiles)>0, 'No output files found' stats = self . output [ 'stats' ] = {} for f in outfiles : type = parsers . astra_output_type ( f ) d = parsers . parse_astra_output_file ( f ) if type in [ 'Cemit' , 'Xemit' , 'Yemit' , 'Zemit' ]: stats . update ( d ) elif type in [ 'LandF' ]: self . output [ 'other' ] = d else : raise ValueError ( f 'Unknown output type: { type } ' ) # Check that the lengths of all arrays are the same nlist = { len ( stats [ k ]) for k in stats } assert len ( nlist ) == 1 , f 'Stat keys do not all have the same length: { [ len ( stats [ k ]) for k in stats ] } ' if include_particles : self . load_particles () particle_stat ( self , key , alive_only = True ) Compute a statistic from the particles. Alive particles have status == 1. By default, statistics will only be computed on these. n_dead will override the alive_only flag, and return the number of particles with status < -6 (Astra convention) Source code in astra/astra.py def particle_stat ( self , key , alive_only = True ): \"\"\" Compute a statistic from the particles. Alive particles have status == 1. By default, statistics will only be computed on these. n_dead will override the alive_only flag, and return the number of particles with status < -6 (Astra convention) \"\"\" if key == 'n_dead' : return np . array ([ len ( np . where ( P . status < - 6 )[ 0 ]) for P in self . particles ]) if key == 'n_alive' : return np . array ([ len ( np . where ( P . status > - 6 )[ 0 ]) for P in self . particles ]) pstats = [] for P in self . particles : if alive_only and P . n_dead > 0 : P = P . where ( P . status == 1 ) pstats . append ( P [ key ]) return np . array ( pstats ) plot ( self , y = [ 'sigma_x' , 'sigma_y' ], x = 'mean_z' , xlim = None , ylim = None , ylim2 = None , y2 = [], nice = True , include_layout = True , include_labels = False , include_particles = True , include_legend = True , return_figure = False , ** kwargs ) Plots stat output multiple keys. If a list of ykeys2 is given, these will be put on the right hand axis. This can also be given as a single key. Logical switches: nice: a nice SI prefix and scaling will be used to make the numbers reasonably sized. Default: True include_legend: The plot will include the legend. Default: True include_particles: Plot the particle statistics as dots. Default: True include_layout: the layout plot will be displayed at the bottom. Default: True include_labels: the layout will include element labels. Default: False return_figure: return the figure object for further manipulation. Default: False If there is no output to plot, the fieldmaps will be plotted with .plot_fieldmaps Source code in astra/astra.py def plot ( self , y = [ 'sigma_x' , 'sigma_y' ], x = 'mean_z' , xlim = None , ylim = None , ylim2 = None , y2 = [], nice = True , include_layout = True , include_labels = False , include_particles = True , include_legend = True , return_figure = False , ** kwargs ): \"\"\" Plots stat output multiple keys. If a list of ykeys2 is given, these will be put on the right hand axis. This can also be given as a single key. Logical switches: nice: a nice SI prefix and scaling will be used to make the numbers reasonably sized. Default: True include_legend: The plot will include the legend. Default: True include_particles: Plot the particle statistics as dots. Default: True include_layout: the layout plot will be displayed at the bottom. Default: True include_labels: the layout will include element labels. Default: False return_figure: return the figure object for further manipulation. Default: False If there is no output to plot, the fieldmaps will be plotted with .plot_fieldmaps \"\"\" # Just plot fieldmaps if there are no if not self . output [ 'stats' ]: return plot_fieldmaps ( self , xlim = xlim , ** kwargs ) return plot_stats_with_layout ( self , ykeys = y , ykeys2 = y2 , xkey = x , xlim = xlim , ylim = ylim , ylim2 = ylim2 , nice = nice , include_layout = include_layout , include_labels = include_labels , include_particles = include_particles , include_legend = include_legend , return_figure = return_figure , ** kwargs ) run_astra ( self , verbose = False , parse_output = True , timeout = None ) Runs Astra Changes directory, so does not work with threads. Source code in astra/astra.py def run_astra ( self , verbose = False , parse_output = True , timeout = None ): \"\"\" Runs Astra Changes directory, so does not work with threads. \"\"\" run_info = self . output [ 'run_info' ] = {} t1 = time () run_info [ 'start_time' ] = t1 # Write all input self . write_input () runscript = self . get_run_script () run_info [ 'run_script' ] = ' ' . join ( runscript ) try : if timeout : res = tools . execute2 ( runscript , timeout = timeout , cwd = self . path ) log = res [ 'log' ] self . error = res [ 'error' ] run_info [ 'why_error' ] = res [ 'why_error' ] # Log file must have this to have finished properly if log . find ( 'finished simulation' ) == - 1 : run_info [ 'error' ] = True run_info . update ({ 'error' : True , 'why_error' : \"Couldn't find finished simulation\" }) else : # Interactive output, for Jupyter log = [] for path in tools . execute ( runscript , cwd = self . path ): self . vprint ( path , end = \"\" ) log . append ( path ) self . log = log if parse_output : self . load_output () except Exception as ex : err = str ( traceback . format_exc ()) print ( 'Run Aborted' , err ) self . error = True run_info [ 'why_error' ] = err finally : run_info [ 'run_time' ] = time () - t1 run_info [ 'run_error' ] = self . error self . finished = True self . vprint ( run_info ) write_fieldmaps ( self ) Writes any loaded fieldmaps to path Source code in astra/astra.py def write_fieldmaps ( self ): \"\"\" Writes any loaded fieldmaps to path \"\"\" if self . fieldmap : write_fieldmaps ( self . fieldmap , self . path ) self . vprint ( f ' { len ( self . fieldmap ) } fieldmaps written to { self . path } ' ) write_input ( self ) Writes all input. If fieldmaps have been loaded, these will also be written. Source code in astra/astra.py def write_input ( self ): \"\"\" Writes all input. If fieldmaps have been loaded, these will also be written. \"\"\" if self . initial_particles : fname = self . write_initial_particles () self . input [ 'newrun' ][ 'distribution' ] = fname self . write_fieldmaps () self . write_input_file () recommended_spacecharge_mesh ( n_particles ) ! -------------------------------------------------------- ! Suggested Nrad, Nlong_in settings from: ! A. Bartnik and C. Gulliford (Cornell University) ! ! Nrad = 35, Nlong_in = 75 !28K ! Nrad = 29, Nlong_in = 63 !20K ! Nrad = 20, Nlong_in = 43 !10K ! Nrad = 13, Nlong_in = 28 !4K ! Nrad = 10, Nlong_in = 20 !2K ! Nrad = 8, Nlong_in = 16 !1K ! ! Nrad ~ round(3.3 (n_particles/1000)^(2/3) + 5) ! Nlong_in ~ round(9.2 (n_particles/1000)^(0.603) + 6.5) ! ! Source code in astra/astra.py def recommended_spacecharge_mesh ( n_particles ): \"\"\" ! -------------------------------------------------------- ! Suggested Nrad, Nlong_in settings from: ! A. Bartnik and C. Gulliford (Cornell University) ! ! Nrad = 35, Nlong_in = 75 !28K ! Nrad = 29, Nlong_in = 63 !20K ! Nrad = 20, Nlong_in = 43 !10K ! Nrad = 13, Nlong_in = 28 !4K ! Nrad = 10, Nlong_in = 20 !2K ! Nrad = 8, Nlong_in = 16 !1K ! ! Nrad ~ round(3.3*(n_particles/1000)^(2/3) + 5) ! Nlong_in ~ round(9.2*(n_particles/1000)^(0.603) + 6.5) ! ! \"\"\" if n_particles < 1000 : # Set a minimum nrad = 8 nlong_in = 16 else : # Prefactors were recalculated from above note. nrad = round ( 3.3e-2 * n_particles ** ( 2 / 3 ) + 5 ) nlong_in = round ( 0.143 * n_particles ** ( 0.603 ) + 6.5 ) return { 'nrad' : nrad , 'nlong_in' : nlong_in } run_astra ( settings = None , astra_input_file = None , workdir = None , astra_bin = '$ASTRA_BIN' , timeout = 2500 , verbose = False ) Run Astra. settings: dict with keys that can appear in an Astra input file. Source code in astra/astra.py def run_astra ( settings = None , astra_input_file = None , workdir = None , astra_bin = '$ASTRA_BIN' , timeout = 2500 , verbose = False ): \"\"\" Run Astra. settings: dict with keys that can appear in an Astra input file. \"\"\" if verbose : print ( 'run_astra' ) # Make astra object A = Astra ( astra_bin = astra_bin , input_file = astra_input_file , workdir = workdir ) A . timeout = timeout A . verbose = verbose A . input [ 'newrun' ][ 'l_rm_back' ] = True # Remove backwards particles # Set inputs if settings : set_astra ( A , {}, settings , verbose = verbose ) # Run A . run () return A run_astra_with_generator ( settings = None , astra_input_file = None , generator_input_file = None , workdir = None , astra_bin = '$ASTRA_BIN' , generator_bin = '$GENERATOR_BIN' , timeout = 2500 , verbose = False , auto_set_spacecharge_mesh = True ) Run Astra with particles generated by Astra's generator. settings: dict with keys that can appear in an Astra or Generator input file. Source code in astra/astra.py def run_astra_with_generator ( settings = None , astra_input_file = None , generator_input_file = None , workdir = None , astra_bin = '$ASTRA_BIN' , generator_bin = '$GENERATOR_BIN' , timeout = 2500 , verbose = False , auto_set_spacecharge_mesh = True ): \"\"\" Run Astra with particles generated by Astra's generator. settings: dict with keys that can appear in an Astra or Generator input file. \"\"\" assert astra_input_file , 'No astra input file' # Call simpler evaluation if there is no generator: if not generator_input_file : return run_astra ( settings = settings , astra_input_file = astra_input_file , workdir = workdir , astra_bin = astra_bin , timeout = timeout , verbose = verbose ) if verbose : print ( 'run_astra_with_generator' ) # Make astra and generator objects A = Astra ( astra_bin = astra_bin , input_file = astra_input_file , workdir = workdir ) A . timeout = timeout A . verbose = verbose G = AstraGenerator ( generator_bin = generator_bin , input_file = generator_input_file , workdir = workdir ) G . verbose = verbose A . input [ 'newrun' ][ 'l_rm_back' ] = True # Remove backwards particles # Set inputs if settings : set_astra ( A , G . input , settings , verbose = verbose ) if auto_set_spacecharge_mesh : n_particles = G . input [ 'ipart' ] sc_settings = recommended_spacecharge_mesh ( n_particles ) A . input [ 'charge' ] . update ( sc_settings ) if verbose : print ( 'set spacecharge mesh for n_particles:' , n_particles , 'to' , sc_settings ) # Run Generator G . run () A . initial_particles = G . output [ 'particles' ] A . run () if verbose : print ( 'run_astra_with_generator finished' ) return A set_astra ( astra_object , generator_input , settings , verbose = False ) Searches astra and generator objects for keys in settings, and sets their values to the appropriate input Source code in astra/astra.py def set_astra ( astra_object , generator_input , settings , verbose = False ): \"\"\" Searches astra and generator objects for keys in settings, and sets their values to the appropriate input \"\"\" astra_input = astra_object . input # legacy syntax for k , v in settings . items (): found = False # Check for direct settable attribute if ':' in k : astra_object [ k ] = v continue for nl in astra_input : if k in astra_input [ nl ]: found = True if verbose : print ( k , 'is in astra' , nl ) astra_input [ nl ][ k ] = settings [ k ] if not found : if k in generator_input : found = True generator_input [ k ] = settings [ k ] if verbose : print ( k , 'is in generator' ) if not found and verbose : print ( k , 'not found' ) assert found","title":"Astra"},{"location":"api/astra/#astra.astra","text":"","title":"astra"},{"location":"api/astra/#astra.astra.Astra","text":"Astra simulation object. Essential methods: . init (...) .configure() .run() Input deck is held in .input Output data is parsed into .output .load_particles() will load particle data into .output 'particles' The Astra binary file can be set on init. If it doesn't exist, configure will check the $ASTRA_BIN environmental variable.","title":"Astra"},{"location":"api/astra/#astra.astra.Astra.add_group","text":"Add a control group. See control.py Parameters: Name Type Description Default name str The group name required Source code in astra/astra.py def add_group ( self , name , ** kwargs ): \"\"\" Add a control group. See control.py Parameters ---------- name : str The group name \"\"\" assert name not in self . input , f ' { name } not allowed to be overwritten by group.' if name in self . group : self . vprint ( f 'Warning: group { name } already exists, overwriting.' ) g = ControlGroup ( ** kwargs ) g . link ( self . input ) self . group [ name ] = g return self . group [ name ]","title":"add_group()"},{"location":"api/astra/#astra.astra.Astra.archive","text":"Archive all data to an h5 handle or filename. If no file is given, a file based on the fingerprint will be created. Source code in astra/astra.py def archive ( self , h5 = None ): \"\"\" Archive all data to an h5 handle or filename. If no file is given, a file based on the fingerprint will be created. \"\"\" if not h5 : h5 = 'astra_' + self . fingerprint () + '.h5' if isinstance ( h5 , str ): h5 = os . path . expandvars ( h5 ) g = h5py . File ( h5 , 'w' ) self . vprint ( f 'Archiving to file { h5 } ' ) else : # store directly in the given h5 handle g = h5 # Write basic attributes archive . astra_init ( g ) # Initial particles if self . initial_particles : self . initial_particles . write ( g , name = 'initial_particles' ) # Fieldmaps if self . fieldmap : archive . write_fieldmap_h5 ( g , self . fieldmap , name = 'fieldmap' ) # All input archive . write_input_h5 ( g , self . input ) # All output archive . write_output_h5 ( g , self . output ) # Control groups if self . group : archive . write_control_groups_h5 ( g , self . group , name = 'control_groups' ) return h5","title":"archive()"},{"location":"api/astra/#astra.astra.Astra.copy","text":"Returns a deep copy of this object. If a tempdir is being used, will clear this and deconfigure. Source code in astra/astra.py def copy ( self ): \"\"\" Returns a deep copy of this object. If a tempdir is being used, will clear this and deconfigure. \"\"\" A2 = deepcopy ( self ) # Clear this if A2 . use_tempdir : A2 . path = None A2 . configured = False return A2","title":"copy()"},{"location":"api/astra/#astra.astra.Astra.fingerprint","text":"Data fingerprint using the input. Source code in astra/astra.py def fingerprint ( self ): \"\"\" Data fingerprint using the input. \"\"\" return tools . fingerprint ( self . input )","title":"fingerprint()"},{"location":"api/astra/#astra.astra.Astra.from_archive","text":"Class method to return an GPT object loaded from an archive file Source code in astra/astra.py @classmethod def from_archive ( cls , archive_h5 ): \"\"\" Class method to return an GPT object loaded from an archive file \"\"\" c = cls () c . load_archive ( archive_h5 ) return c","title":"from_archive()"},{"location":"api/astra/#astra.astra.Astra.from_yaml","text":"Returns an Astra object instantiated from a YAML config file Will load intial_particles from an h5 file. Source code in astra/astra.py @classmethod def from_yaml ( cls , yaml_file ): \"\"\" Returns an Astra object instantiated from a YAML config file Will load intial_particles from an h5 file. \"\"\" # Try file if os . path . exists ( os . path . expandvars ( yaml_file )): config = yaml . safe_load ( open ( yaml_file )) # The input file might be relative to the yaml file if 'input_file' in config : f = os . path . expandvars ( config [ 'input_file' ]) if not os . path . isabs ( f ): # Get the yaml file root root , _ = os . path . split ( tools . full_path ( yaml_file )) config [ 'input_file' ] = os . path . join ( root , f ) else : #Try raw string config = yaml . safe_load ( yaml_file ) # Form ParticleGroup from file if 'initial_particles' in config : f = config [ 'initial_particles' ] if not os . path . isabs ( f ): root , _ = os . path . split ( tools . full_path ( yaml_file )) f = os . path . join ( root , f ) config [ 'initial_particles' ] = ParticleGroup ( f ) return cls ( ** config )","title":"from_yaml()"},{"location":"api/astra/#astra.astra.Astra.get_run_script","text":"Assembles the run script. Optionally writes a file 'run' with this line to path. This expect to run with .path as the cwd. Source code in astra/astra.py def get_run_script ( self , write_to_path = True ): \"\"\" Assembles the run script. Optionally writes a file 'run' with this line to path. This expect to run with .path as the cwd. \"\"\" _ , infile = os . path . split ( self . input_file ) # Expect to run locally. Astra has problems with long paths. runscript = [ self . astra_bin , infile ] if write_to_path : with open ( os . path . join ( self . path , 'run' ), 'w' ) as f : f . write ( ' ' . join ( runscript )) return runscript","title":"get_run_script()"},{"location":"api/astra/#astra.astra.Astra.load_archive","text":"Loads input and output from archived h5 file. See: Astra.archive Source code in astra/astra.py def load_archive ( self , h5 = None ): \"\"\" Loads input and output from archived h5 file. See: Astra.archive \"\"\" if isinstance ( h5 , str ): h5 = os . path . expandvars ( h5 ) g = h5py . File ( h5 , 'r' ) glist = archive . find_astra_archives ( g ) n = len ( glist ) if n == 0 : # legacy: try top level message = 'legacy' elif n == 1 : gname = glist [ 0 ] message = f 'group { gname } from' g = g [ gname ] else : raise ValueError ( f 'Multiple archives found in file { h5 } : { glist } ' ) self . vprint ( f 'Reading { message } archive file { h5 } ' ) else : g = h5 self . input = archive . read_input_h5 ( g [ 'input' ]) self . output = archive . read_output_h5 ( g [ 'output' ]) if 'initial_particles' in g : self . initial_particles = ParticleGroup ( h5 = g [ 'initial_particles' ]) if 'fieldmap' in g : self . fieldmap = archive . read_fieldmap_h5 ( g [ 'fieldmap' ]) if 'control_groups' in g : self . group = archive . read_control_groups_h5 ( g [ 'control_groups' ], verbose = self . verbose ) self . vprint ( 'Loaded from archive. Note: Must reconfigure to run again.' ) self . configured = False # Re-link groups # TODO: cleaner logic for _ , cg in self . group . items (): cg . link ( self . input )","title":"load_archive()"},{"location":"api/astra/#astra.astra.Astra.load_fieldmaps","text":"Loads fieldmaps into Astra.fieldmap as a dict. Optionally, a list of paths can be included that will search for these. The default will search self.path. Source code in astra/astra.py def load_fieldmaps ( self , search_paths = []): \"\"\" Loads fieldmaps into Astra.fieldmap as a dict. Optionally, a list of paths can be included that will search for these. The default will search self.path. \"\"\" # Do not consider files if fieldmaps have been loaded. if self . fieldmap : strip_path = False else : strip_path = True if not search_paths : [ self . path ] self . fieldmap = load_fieldmaps ( self . input , fieldmap_dict = self . fieldmap , search_paths = search_paths , verbose = self . verbose , strip_path = strip_path )","title":"load_fieldmaps()"},{"location":"api/astra/#astra.astra.Astra.load_initial_particles","text":"Loads a openPMD-beamphysics particle h5 handle or file Source code in astra/astra.py def load_initial_particles ( self , h5 ): \"\"\"Loads a openPMD-beamphysics particle h5 handle or file\"\"\" P = ParticleGroup ( h5 = h5 ) self . initial_particles = P","title":"load_initial_particles()"},{"location":"api/astra/#astra.astra.Astra.load_output","text":"Loads Astra output files into .output .output is a dict with dicts: .stats .run_info .other and if include_particles, .particles = list of ParticleGroup objects Source code in astra/astra.py def load_output ( self , include_particles = True ): \"\"\" Loads Astra output files into .output .output is a dict with dicts: .stats .run_info .other and if include_particles, .particles = list of ParticleGroup objects \"\"\" run_number = parsers . astra_run_extension ( self . input [ 'newrun' ][ 'run' ]) outfiles = parsers . find_astra_output_files ( self . input_file , run_number ) #assert len(outfiles)>0, 'No output files found' stats = self . output [ 'stats' ] = {} for f in outfiles : type = parsers . astra_output_type ( f ) d = parsers . parse_astra_output_file ( f ) if type in [ 'Cemit' , 'Xemit' , 'Yemit' , 'Zemit' ]: stats . update ( d ) elif type in [ 'LandF' ]: self . output [ 'other' ] = d else : raise ValueError ( f 'Unknown output type: { type } ' ) # Check that the lengths of all arrays are the same nlist = { len ( stats [ k ]) for k in stats } assert len ( nlist ) == 1 , f 'Stat keys do not all have the same length: { [ len ( stats [ k ]) for k in stats ] } ' if include_particles : self . load_particles ()","title":"load_output()"},{"location":"api/astra/#astra.astra.Astra.particle_stat","text":"Compute a statistic from the particles. Alive particles have status == 1. By default, statistics will only be computed on these. n_dead will override the alive_only flag, and return the number of particles with status < -6 (Astra convention) Source code in astra/astra.py def particle_stat ( self , key , alive_only = True ): \"\"\" Compute a statistic from the particles. Alive particles have status == 1. By default, statistics will only be computed on these. n_dead will override the alive_only flag, and return the number of particles with status < -6 (Astra convention) \"\"\" if key == 'n_dead' : return np . array ([ len ( np . where ( P . status < - 6 )[ 0 ]) for P in self . particles ]) if key == 'n_alive' : return np . array ([ len ( np . where ( P . status > - 6 )[ 0 ]) for P in self . particles ]) pstats = [] for P in self . particles : if alive_only and P . n_dead > 0 : P = P . where ( P . status == 1 ) pstats . append ( P [ key ]) return np . array ( pstats )","title":"particle_stat()"},{"location":"api/astra/#astra.astra.Astra.plot","text":"Plots stat output multiple keys. If a list of ykeys2 is given, these will be put on the right hand axis. This can also be given as a single key. Logical switches: nice: a nice SI prefix and scaling will be used to make the numbers reasonably sized. Default: True include_legend: The plot will include the legend. Default: True include_particles: Plot the particle statistics as dots. Default: True include_layout: the layout plot will be displayed at the bottom. Default: True include_labels: the layout will include element labels. Default: False return_figure: return the figure object for further manipulation. Default: False If there is no output to plot, the fieldmaps will be plotted with .plot_fieldmaps Source code in astra/astra.py def plot ( self , y = [ 'sigma_x' , 'sigma_y' ], x = 'mean_z' , xlim = None , ylim = None , ylim2 = None , y2 = [], nice = True , include_layout = True , include_labels = False , include_particles = True , include_legend = True , return_figure = False , ** kwargs ): \"\"\" Plots stat output multiple keys. If a list of ykeys2 is given, these will be put on the right hand axis. This can also be given as a single key. Logical switches: nice: a nice SI prefix and scaling will be used to make the numbers reasonably sized. Default: True include_legend: The plot will include the legend. Default: True include_particles: Plot the particle statistics as dots. Default: True include_layout: the layout plot will be displayed at the bottom. Default: True include_labels: the layout will include element labels. Default: False return_figure: return the figure object for further manipulation. Default: False If there is no output to plot, the fieldmaps will be plotted with .plot_fieldmaps \"\"\" # Just plot fieldmaps if there are no if not self . output [ 'stats' ]: return plot_fieldmaps ( self , xlim = xlim , ** kwargs ) return plot_stats_with_layout ( self , ykeys = y , ykeys2 = y2 , xkey = x , xlim = xlim , ylim = ylim , ylim2 = ylim2 , nice = nice , include_layout = include_layout , include_labels = include_labels , include_particles = include_particles , include_legend = include_legend , return_figure = return_figure , ** kwargs )","title":"plot()"},{"location":"api/astra/#astra.astra.Astra.run_astra","text":"Runs Astra Changes directory, so does not work with threads. Source code in astra/astra.py def run_astra ( self , verbose = False , parse_output = True , timeout = None ): \"\"\" Runs Astra Changes directory, so does not work with threads. \"\"\" run_info = self . output [ 'run_info' ] = {} t1 = time () run_info [ 'start_time' ] = t1 # Write all input self . write_input () runscript = self . get_run_script () run_info [ 'run_script' ] = ' ' . join ( runscript ) try : if timeout : res = tools . execute2 ( runscript , timeout = timeout , cwd = self . path ) log = res [ 'log' ] self . error = res [ 'error' ] run_info [ 'why_error' ] = res [ 'why_error' ] # Log file must have this to have finished properly if log . find ( 'finished simulation' ) == - 1 : run_info [ 'error' ] = True run_info . update ({ 'error' : True , 'why_error' : \"Couldn't find finished simulation\" }) else : # Interactive output, for Jupyter log = [] for path in tools . execute ( runscript , cwd = self . path ): self . vprint ( path , end = \"\" ) log . append ( path ) self . log = log if parse_output : self . load_output () except Exception as ex : err = str ( traceback . format_exc ()) print ( 'Run Aborted' , err ) self . error = True run_info [ 'why_error' ] = err finally : run_info [ 'run_time' ] = time () - t1 run_info [ 'run_error' ] = self . error self . finished = True self . vprint ( run_info )","title":"run_astra()"},{"location":"api/astra/#astra.astra.Astra.write_fieldmaps","text":"Writes any loaded fieldmaps to path Source code in astra/astra.py def write_fieldmaps ( self ): \"\"\" Writes any loaded fieldmaps to path \"\"\" if self . fieldmap : write_fieldmaps ( self . fieldmap , self . path ) self . vprint ( f ' { len ( self . fieldmap ) } fieldmaps written to { self . path } ' )","title":"write_fieldmaps()"},{"location":"api/astra/#astra.astra.Astra.write_input","text":"Writes all input. If fieldmaps have been loaded, these will also be written. Source code in astra/astra.py def write_input ( self ): \"\"\" Writes all input. If fieldmaps have been loaded, these will also be written. \"\"\" if self . initial_particles : fname = self . write_initial_particles () self . input [ 'newrun' ][ 'distribution' ] = fname self . write_fieldmaps () self . write_input_file ()","title":"write_input()"},{"location":"api/astra/#astra.astra.recommended_spacecharge_mesh","text":"! -------------------------------------------------------- ! Suggested Nrad, Nlong_in settings from: ! A. Bartnik and C. Gulliford (Cornell University) ! ! Nrad = 35, Nlong_in = 75 !28K ! Nrad = 29, Nlong_in = 63 !20K ! Nrad = 20, Nlong_in = 43 !10K ! Nrad = 13, Nlong_in = 28 !4K ! Nrad = 10, Nlong_in = 20 !2K ! Nrad = 8, Nlong_in = 16 !1K ! ! Nrad ~ round(3.3 (n_particles/1000)^(2/3) + 5) ! Nlong_in ~ round(9.2 (n_particles/1000)^(0.603) + 6.5) ! ! Source code in astra/astra.py def recommended_spacecharge_mesh ( n_particles ): \"\"\" ! -------------------------------------------------------- ! Suggested Nrad, Nlong_in settings from: ! A. Bartnik and C. Gulliford (Cornell University) ! ! Nrad = 35, Nlong_in = 75 !28K ! Nrad = 29, Nlong_in = 63 !20K ! Nrad = 20, Nlong_in = 43 !10K ! Nrad = 13, Nlong_in = 28 !4K ! Nrad = 10, Nlong_in = 20 !2K ! Nrad = 8, Nlong_in = 16 !1K ! ! Nrad ~ round(3.3*(n_particles/1000)^(2/3) + 5) ! Nlong_in ~ round(9.2*(n_particles/1000)^(0.603) + 6.5) ! ! \"\"\" if n_particles < 1000 : # Set a minimum nrad = 8 nlong_in = 16 else : # Prefactors were recalculated from above note. nrad = round ( 3.3e-2 * n_particles ** ( 2 / 3 ) + 5 ) nlong_in = round ( 0.143 * n_particles ** ( 0.603 ) + 6.5 ) return { 'nrad' : nrad , 'nlong_in' : nlong_in }","title":"recommended_spacecharge_mesh()"},{"location":"api/astra/#astra.astra.run_astra","text":"Run Astra. settings: dict with keys that can appear in an Astra input file. Source code in astra/astra.py def run_astra ( settings = None , astra_input_file = None , workdir = None , astra_bin = '$ASTRA_BIN' , timeout = 2500 , verbose = False ): \"\"\" Run Astra. settings: dict with keys that can appear in an Astra input file. \"\"\" if verbose : print ( 'run_astra' ) # Make astra object A = Astra ( astra_bin = astra_bin , input_file = astra_input_file , workdir = workdir ) A . timeout = timeout A . verbose = verbose A . input [ 'newrun' ][ 'l_rm_back' ] = True # Remove backwards particles # Set inputs if settings : set_astra ( A , {}, settings , verbose = verbose ) # Run A . run () return A","title":"run_astra()"},{"location":"api/astra/#astra.astra.run_astra_with_generator","text":"Run Astra with particles generated by Astra's generator. settings: dict with keys that can appear in an Astra or Generator input file. Source code in astra/astra.py def run_astra_with_generator ( settings = None , astra_input_file = None , generator_input_file = None , workdir = None , astra_bin = '$ASTRA_BIN' , generator_bin = '$GENERATOR_BIN' , timeout = 2500 , verbose = False , auto_set_spacecharge_mesh = True ): \"\"\" Run Astra with particles generated by Astra's generator. settings: dict with keys that can appear in an Astra or Generator input file. \"\"\" assert astra_input_file , 'No astra input file' # Call simpler evaluation if there is no generator: if not generator_input_file : return run_astra ( settings = settings , astra_input_file = astra_input_file , workdir = workdir , astra_bin = astra_bin , timeout = timeout , verbose = verbose ) if verbose : print ( 'run_astra_with_generator' ) # Make astra and generator objects A = Astra ( astra_bin = astra_bin , input_file = astra_input_file , workdir = workdir ) A . timeout = timeout A . verbose = verbose G = AstraGenerator ( generator_bin = generator_bin , input_file = generator_input_file , workdir = workdir ) G . verbose = verbose A . input [ 'newrun' ][ 'l_rm_back' ] = True # Remove backwards particles # Set inputs if settings : set_astra ( A , G . input , settings , verbose = verbose ) if auto_set_spacecharge_mesh : n_particles = G . input [ 'ipart' ] sc_settings = recommended_spacecharge_mesh ( n_particles ) A . input [ 'charge' ] . update ( sc_settings ) if verbose : print ( 'set spacecharge mesh for n_particles:' , n_particles , 'to' , sc_settings ) # Run Generator G . run () A . initial_particles = G . output [ 'particles' ] A . run () if verbose : print ( 'run_astra_with_generator finished' ) return A","title":"run_astra_with_generator()"},{"location":"api/astra/#astra.astra.set_astra","text":"Searches astra and generator objects for keys in settings, and sets their values to the appropriate input Source code in astra/astra.py def set_astra ( astra_object , generator_input , settings , verbose = False ): \"\"\" Searches astra and generator objects for keys in settings, and sets their values to the appropriate input \"\"\" astra_input = astra_object . input # legacy syntax for k , v in settings . items (): found = False # Check for direct settable attribute if ':' in k : astra_object [ k ] = v continue for nl in astra_input : if k in astra_input [ nl ]: found = True if verbose : print ( k , 'is in astra' , nl ) astra_input [ nl ][ k ] = settings [ k ] if not found : if k in generator_input : found = True generator_input [ k ] = settings [ k ] if verbose : print ( k , 'is in generator' ) if not found and verbose : print ( k , 'not found' ) assert found","title":"set_astra()"},{"location":"api/generator/","text":"astra.generator AstraGenerator Class to run Astra's particle generator The file for Astra is written in: .output_file get_run_script ( self , write_to_path = True ) Assembles the run script. Optionally writes a file 'run' with this line to path. Source code in astra/generator.py def get_run_script ( self , write_to_path = True ): \"\"\" Assembles the run script. Optionally writes a file 'run' with this line to path. \"\"\" _ , infile = os . path . split ( self . input_file ) runscript = [ self . generator_bin , infile ] if write_to_path : with open ( os . path . join ( self . path , 'run' ), 'w' ) as f : f . write ( ' ' . join ( runscript )) return runscript run ( self ) Runs Generator Note: do not use os.chdir Source code in astra/generator.py def run ( self ): \"\"\" Runs Generator Note: do not use os.chdir \"\"\" # Save #init_dir = os.getcwd() #print(f'changing to path {self.path}') #os.chdir(self.path) self . write_input_file () runscript = self . get_run_script () try : res = tools . execute2 ( runscript , timeout = None , cwd = self . path ) self . log = res [ 'log' ] self . vprint ( self . log ) # This is the file that should be written if os . path . exists ( self . output_file ): self . finished = True else : print ( 'AstraGenerator.output_file {self.output_file} does not exist.' ) #print('The input file already exists! This is a problem!') print ( f 'Here is what the current working dir looks like: { os . listdir ( self . path ) } ' ) self . load_output () except Exception as ex : print ( 'AstraGenerator.run exception:' , traceback . format_exc ()) self . error = True finally : pass","title":"Generator"},{"location":"api/generator/#astra.generator","text":"","title":"generator"},{"location":"api/generator/#astra.generator.AstraGenerator","text":"Class to run Astra's particle generator The file for Astra is written in: .output_file","title":"AstraGenerator"},{"location":"api/generator/#astra.generator.AstraGenerator.get_run_script","text":"Assembles the run script. Optionally writes a file 'run' with this line to path. Source code in astra/generator.py def get_run_script ( self , write_to_path = True ): \"\"\" Assembles the run script. Optionally writes a file 'run' with this line to path. \"\"\" _ , infile = os . path . split ( self . input_file ) runscript = [ self . generator_bin , infile ] if write_to_path : with open ( os . path . join ( self . path , 'run' ), 'w' ) as f : f . write ( ' ' . join ( runscript )) return runscript","title":"get_run_script()"},{"location":"api/generator/#astra.generator.AstraGenerator.run","text":"Runs Generator Note: do not use os.chdir Source code in astra/generator.py def run ( self ): \"\"\" Runs Generator Note: do not use os.chdir \"\"\" # Save #init_dir = os.getcwd() #print(f'changing to path {self.path}') #os.chdir(self.path) self . write_input_file () runscript = self . get_run_script () try : res = tools . execute2 ( runscript , timeout = None , cwd = self . path ) self . log = res [ 'log' ] self . vprint ( self . log ) # This is the file that should be written if os . path . exists ( self . output_file ): self . finished = True else : print ( 'AstraGenerator.output_file {self.output_file} does not exist.' ) #print('The input file already exists! This is a problem!') print ( f 'Here is what the current working dir looks like: { os . listdir ( self . path ) } ' ) self . load_output () except Exception as ex : print ( 'AstraGenerator.run exception:' , traceback . format_exc ()) self . error = True finally : pass","title":"run()"},{"location":"api/install/","text":"astra.install install_astra ( dest_dir = None , name = 'Astra' , verbose = False ) Installs Astra from Klaus Floettmann's DESY website for the detected platform. Sets environmental variable ASTRA_BIN Source code in astra/install.py def install_astra ( dest_dir = None , name = 'Astra' , verbose = False ): \"\"\" Installs Astra from Klaus Floettmann's DESY website for the detected platform. Sets environmental variable ASTRA_BIN \"\"\" system = platform . system () url = ASTRA_URL [ system ] dest = os . path . abspath ( os . path . join ( dest_dir , name )) install_executable ( url , dest , verbose = verbose ) os . environ [ 'ASTRA_BIN' ] = dest if verbose : print ( f 'Installed Astra in { dest } , and set $ASTRA_BIN equal to this.' ) return dest install_examples ( location ) Install lume-astra examples on the informed location. Parameters: Name Type Description Default location str The folder in which to install the examples required Source code in astra/install.py def install_examples ( location ): \"\"\" Install lume-astra examples on the informed location. Parameters ---------- location : str The folder in which to install the examples \"\"\" import requests import zipfile import io import os loc = os . path . expanduser ( os . path . expandvars ( location )) os . makedirs ( loc , exist_ok = True ) response = requests . get ( EXAMPLES_URL , stream = True ) if response . status_code == 200 : zip_file = zipfile . ZipFile ( io . BytesIO ( response . content )) zip_file . extractall ( loc ) else : raise RuntimeError ( f \"Could not download examples archive. Status code was: { response . status_code } \" ) install_executable ( url , dest , verbose = False ) Downloads a url into a destination and makes it executable. Will not overwrite. Source code in astra/install.py def install_executable ( url , dest , verbose = False ): \"\"\" Downloads a url into a destination and makes it executable. Will not overwrite. \"\"\" if os . path . exists ( dest ): print ( os . path . abspath ( dest ), 'exists, will not overwrite' ) else : if verbose : print ( f 'Downloading { url } to { dest } ' ) urllib . request . urlretrieve ( url , dest ) make_executable ( dest ) return dest install_generator ( dest_dir = None , name = 'generator' , verbose = False ) Installs Astra's generator from Klaus Floettmann's DESY website for the detected platform. Sets environmental variable GENERATOR_BIN Source code in astra/install.py def install_generator ( dest_dir = None , name = 'generator' , verbose = False ): \"\"\" Installs Astra's generator from Klaus Floettmann's DESY website for the detected platform. Sets environmental variable GENERATOR_BIN \"\"\" system = platform . system () url = GENERATOR_URL [ system ] dest = os . path . abspath ( os . path . join ( dest_dir , name )) install_executable ( url , dest , verbose = verbose ) os . environ [ 'GENERATOR_BIN' ] = dest if verbose : print ( f 'Installed Astra \\' s generator in { dest } , and set $GENERATOR_BIN equal to this.' ) return dest","title":"Install"},{"location":"api/install/#astra.install","text":"","title":"install"},{"location":"api/install/#astra.install.install_astra","text":"Installs Astra from Klaus Floettmann's DESY website for the detected platform. Sets environmental variable ASTRA_BIN Source code in astra/install.py def install_astra ( dest_dir = None , name = 'Astra' , verbose = False ): \"\"\" Installs Astra from Klaus Floettmann's DESY website for the detected platform. Sets environmental variable ASTRA_BIN \"\"\" system = platform . system () url = ASTRA_URL [ system ] dest = os . path . abspath ( os . path . join ( dest_dir , name )) install_executable ( url , dest , verbose = verbose ) os . environ [ 'ASTRA_BIN' ] = dest if verbose : print ( f 'Installed Astra in { dest } , and set $ASTRA_BIN equal to this.' ) return dest","title":"install_astra()"},{"location":"api/install/#astra.install.install_examples","text":"Install lume-astra examples on the informed location. Parameters: Name Type Description Default location str The folder in which to install the examples required Source code in astra/install.py def install_examples ( location ): \"\"\" Install lume-astra examples on the informed location. Parameters ---------- location : str The folder in which to install the examples \"\"\" import requests import zipfile import io import os loc = os . path . expanduser ( os . path . expandvars ( location )) os . makedirs ( loc , exist_ok = True ) response = requests . get ( EXAMPLES_URL , stream = True ) if response . status_code == 200 : zip_file = zipfile . ZipFile ( io . BytesIO ( response . content )) zip_file . extractall ( loc ) else : raise RuntimeError ( f \"Could not download examples archive. Status code was: { response . status_code } \" )","title":"install_examples()"},{"location":"api/install/#astra.install.install_executable","text":"Downloads a url into a destination and makes it executable. Will not overwrite. Source code in astra/install.py def install_executable ( url , dest , verbose = False ): \"\"\" Downloads a url into a destination and makes it executable. Will not overwrite. \"\"\" if os . path . exists ( dest ): print ( os . path . abspath ( dest ), 'exists, will not overwrite' ) else : if verbose : print ( f 'Downloading { url } to { dest } ' ) urllib . request . urlretrieve ( url , dest ) make_executable ( dest ) return dest","title":"install_executable()"},{"location":"api/install/#astra.install.install_generator","text":"Installs Astra's generator from Klaus Floettmann's DESY website for the detected platform. Sets environmental variable GENERATOR_BIN Source code in astra/install.py def install_generator ( dest_dir = None , name = 'generator' , verbose = False ): \"\"\" Installs Astra's generator from Klaus Floettmann's DESY website for the detected platform. Sets environmental variable GENERATOR_BIN \"\"\" system = platform . system () url = GENERATOR_URL [ system ] dest = os . path . abspath ( os . path . join ( dest_dir , name )) install_executable ( url , dest , verbose = verbose ) os . environ [ 'GENERATOR_BIN' ] = dest if verbose : print ( f 'Installed Astra \\' s generator in { dest } , and set $GENERATOR_BIN equal to this.' ) return dest","title":"install_generator()"}]}